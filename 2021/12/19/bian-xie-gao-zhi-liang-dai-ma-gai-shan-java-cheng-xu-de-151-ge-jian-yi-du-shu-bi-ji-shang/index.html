<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="《编写高质量代码 改善java程序的151个建议》读书笔记-上, Java,Flink,高级项目管理,Electron.js等">
    <meta name="description" content="《编写高质量代码 改善java程序的151个建议》读书笔记-上
本篇博客记录《编写高质量代码 改善java程序的151个建议》这本书的读书笔记。方便自己查看，也方便大家查阅，在此感谢原书作者秦小波对java的独特见解，帮助java爱好者的成">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="referrer" content="no-referrer" />
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《编写高质量代码 改善java程序的151个建议》读书笔记-上 | 梓妤</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="梓妤" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">梓妤</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">梓妤</div>
        <div class="logo-desc">
            
            一个不懂生活的程序猿
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《编写高质量代码 改善java程序的151个建议》读书笔记-上</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%90%8E%E7%AB%AF/">
                                <span class="chip bg-color">后端</span>
                            </a>
                        
                            <a href="/tags/java/">
                                <span class="chip bg-color">java</span>
                            </a>
                        
                            <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
                                <span class="chip bg-color">读书笔记</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="post-category">
                                学习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-12-19
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-12-25
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    74.8k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>《编写高质量代码 改善java程序的151个建议》读书笔记-上</p>
<p>本篇博客记录《编写高质量代码 改善java程序的151个建议》这本书的读书笔记。方便自己查看，也方便大家查阅，在此感谢原书作者<a target="_blank" rel="noopener" href="https://weread.qq.com/web/reader/3cc32750597de83cc5abc31ke4d32d5015e4da3b7fbb1fa">秦小波</a>对java的独特见解，帮助java爱好者的成长。</p>
<h2><span id="第1章-java开发中通用的方法和准则">第1章 Java开发中通用的方法和准则</span></h2><p>​    The reasonable man adapts himself to the world;the unreasonable onepersists in trying to adapt the world to himself.明白事理的人使自己适应世界；不明事理的人想让世界适应自己。——萧伯纳</p>
<h3><span id="建议1不要在常量和变量中出现易混淆的字母">建议1：不要在常量和变量中出现易混淆的字母</span></h3><p>​    包名全小写，类名首字母全大写，常量全部大写并用下划线分隔，变量采用驼峰命名法(Camel Case)命名等，这些都是最基本的Java编码规范，是每个javaer都应熟知的规则，但是在变量的声明中要注意不要引入容易混淆的字母。尝试阅读如下代码，思考打印结果的i是多少：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">long</span> i<span class="token operator">=</span>1l<span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i的两倍是："</span><span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>   肯定会有人说：这么简单的例子还能出错？运行结果肯定是22！实践是检验真理的唯一标准，将其Run一下看看，或许你会很奇怪，结果是2，而不是22.难道是编译器出问题了，少了个”2”?</p>
<p>   因为赋给变量i的值就是数字”1”,只是后面加了长整型变量的标示字母”l”而已。别说是我挖坑让你跳，如果有类似程序出现在项目中，当你试图通过阅读代码来理解作者的思想时，此情景就可能会出现。所以为了让你的程序更容易理解，字母”l”(包括大写字母”O”)尽量不要和数字混用，以免使读者的理解和程序意图产生偏差。如果字母和数字混合使用，字母”l”务必大写，字母”O”则增加注释。</p>
<p><strong><font color="red">注意：字母l作为长整型标志时务必大写。</font></strong></p>
<h3><span id="建议2莫让常量蜕变成变量">建议2：莫让常量蜕变成变量</span></h3><p>​    常量蜕变成变量？你胡扯吧，加了final和static的常量怎么可能会变呢？不可能为此赋值的呀。真的不可能吗？看看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"常量会变哦:"</span> <span class="token operator">+</span> Constant<span class="token punctuation">.</span>RAND_CONST<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Constant</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RAND_CONST <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    RAND_CONST是常量吗?它的值会变吗？绝对会变！这种常量的定义方式是绝对不可取的，常量就是常量，在编译期就必须确定其值，不应该在运行期更改，否则程序的可读性会非常差，甚至连作者自己都不能确定在运行期发生了何种神奇的事情。</p>
<p>  甭想着使用常量会变的这个功能来实现序列号算法、随机种子生成，除非这真的是项目中的唯一方案，否则就放弃吧，常量还是当常量使用。</p>
<p><strong><font color="red">注意：务必让常量的值在运行期保持不变。</font></strong></p>
<h3><span id="建议3三元操作符的类型务必一致">建议3：三元操作符的类型务必一致</span></h3><p>​    三元操作符是if-else的简化写法，在项目中使用它的地方很多，也非常好用，但是好用又简单的东西并不表示就可以随意使用，看看如下代码:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span>
    String str <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">?</span> <span class="token number">90</span> <span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String str1 <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">?</span> <span class="token number">90</span> <span class="token operator">:</span> <span class="token number">100.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"两者是否相等："</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    分析一下这段程序，i是80，小于100，两者的返回值肯定都是90，再转成String类型，其值也绝对相等，毋庸置疑的。嗯，分析的有点道理，但是变量str中的三元操作符的第二个操作数是100，而str1中的第二个操作数是100.0，难道木有影响吗?不可能有影响吧，三元操作符的条件都为真了，只返回第一个值嘛，于第二个值有毛线关系，貌似有道理。</p>
<p>　　运行之后，结果却是：”两者是否相等：false”，不相等，why?</p>
<p>　　问题就出在了100和100.0这两个数字上，在变量str中，三元操作符的第一个操作数90和第二个操作数100都是int类型，类型相同，返回的结果也是int类型的90，而变量str1中的第一个操作数(90)是int类型，第二个操作数100.0是浮点数，也就是两个操作数的类型不一致，可三元操作符必须要返回一个数据，而且类型要确定，不可能条件为真时返回int类型，条件为假时返回float类型，编译器是不允许如此的，所以它会进行类型转换int类型转换为浮点数90.0，也就是三元操作符的返回值是浮点数90.0，那么当然和整型的90不相等了。这里为什么是整型转成浮点型，而不是浮点型转成整型呢？这就涉及三元操作符类型的转换规则:</p>
<ol>
<li><p> 若两个操作数不可转换，则不作转换，返回值是Object类型；</p>
</li>
<li><p> 若两个操作数是明确类型的表达式(比如变量)，则按照正常的二进制数字转换，int转为long，long转为float等;</p>
</li>
<li><p> 若两个操作数中有一个是数字S,另外一个是表达式，且其类型标志位T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T的范围，则T转换为S;</p>
</li>
<li><p> 若两个操作数都是直接量数字，则返回值类型范围较大者。</p>
</li>
</ol>
<p>   转换规则：从存储范围小的类型到存储范围大的类型。<br>   <strong>具体规则为：byte→short(char)→int→long→float→double</strong></p>
<p><strong><font color="red">知道什么原因了，相应的解决办法也就有了：保证三元操作符中的两个操作数类型一致，避免此错误的发生。</font></strong></p>
<h3><span id="建议4避免带有变长参数的方法重载">建议4：避免带有变长参数的方法重载</span></h3><p>​    在项目和系统开发中，为了提高方法的灵活度和可复用性，我们经常要传递不确定数量的参数到方法中，在JAVA5之前常用的设计技巧就是把形参定义成Collection类型或其子类类型，或者数组类型，这种方法的缺点就是需要对空参数进行判断和筛选，比如实参为null值和长度为0的Collection或数组。而Java5引入了变长参数(varags)就是为了更好地挺好方法的复用性，让方法的调用者可以”随心所欲”地传递实参数量，当然变长参数也是要遵循一定规则的，比如<strong>变长参数必须是方法中的最后一个参数；一个方法不能定义多个变长参数</strong>等，这些基本规则需要牢记，但是即使记住了这些规则，仍然有可能出现错误，看如下代码:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Client client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 499元的货物 打75折</span>
        client<span class="token punctuation">.</span><span class="token function">calPrice</span><span class="token punctuation">(</span><span class="token number">499</span><span class="token punctuation">,</span> <span class="token number">75</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 简单折扣计算</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">calPrice</span><span class="token punctuation">(</span><span class="token keyword">int</span> price<span class="token punctuation">,</span> <span class="token keyword">int</span> discount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">float</span> knockdownPrice <span class="token operator">=</span> price <span class="token operator">*</span> discount <span class="token operator">/</span> <span class="token number">100.0F</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"简单折扣后的价格是："</span> <span class="token operator">+</span> <span class="token function">formatCurrency</span><span class="token punctuation">(</span>knockdownPrice<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 复杂多折扣计算</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">calPrice</span><span class="token punctuation">(</span><span class="token keyword">int</span> price<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> discounts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">float</span> knockdownPrice <span class="token operator">=</span> price<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> discount <span class="token operator">:</span> discounts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            knockdownPrice <span class="token operator">=</span> knockdownPrice <span class="token operator">*</span> discount <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"复杂折扣后的价格是："</span> <span class="token operator">+</span> <span class="token function">formatCurrency</span><span class="token punctuation">(</span>knockdownPrice<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">formatCurrency</span><span class="token punctuation">(</span><span class="token keyword">float</span> price<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> NumberFormat<span class="token punctuation">.</span><span class="token function">getCurrencyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    这是一个计算商品折扣的模拟类，带有两个参数的calPrice方法（该方法的业务逻辑是：提供商品的原价和折扣率，即可获得商品的折扣价）是一个简单的折扣计算方法，该方法在实际项目中经常会用到，这是单一的打折方法。而带有变长参数的calPrice方法是叫较复杂的折扣计算方式，多种折扣的叠加运算（模拟类是比较简单的实现）在实际中也经常见到，比如在大甩卖期间对VIP会员再度进行打折；或者当天是你的生日，再给你打个9折，也就是俗话中的折上折。</p>
<p>　　业务逻辑清楚了，我们来仔细看看这两个方法，它们是重载吗?当然是了，重载的定义是：”方法名相同，参数类型或数量不同”，很明显这两个方法是重载。但是这个重载有点特殊，calPrice(int price ,int… discounts)的参数范畴覆盖了calPrice（int price,int discount）的参数范畴。那问题就出来了：对于calPrice(499,75)这样的计算，到底该调用哪个方法来处理呢？</p>
<p>　　我们知道java编译器是很聪明的，它在编译时会根据方法签名来确定调用那个方法，比如：calPrice（499,75,95）这个调用，很明显75和95会被转成一个包含两个元素的数组，并传递到calPrice（int price,int…discounts）中，因为只有这一个方法符合这个实参类型，这很容易理解。但是我们现在面对的是calPrice(499,75)调用，这个75既可以被编译成int类型的75，也可以被编译成int数组{75}，即只包含一个元素的数组。那到底该调用哪一个方法呢？运行结果是:”简单折扣后的价格是：374.25”。看来调用了第一个方法，为什么会调用第一个方法，而不是第二个变长方法呢？因为java在编译时，首先会根据实参的数量和类型（这里2个实参，都为int类型，注意没有转成int数组）来进行处理，也就是找到calPrice(int price,int discount)方法，而且确认他是否符合方法签名条件。现在的问题是编译器为什么会首先根据两个int类型的实参而不是一个int类型，一个int数组类型的实参来查找方法呢？</p>
<p>　　因为int是一个原生数据类型，而数组本身是一个对象，编译器想要”偷懒”,于是它会从最简单的开始”猜想”，只要符合编译条件的即可通过，于是就出现了此问题。</p>
<p>　　问题阐述清楚了，为了让我们的程序能被”人类”看懂，还是<strong>慎重考虑变长参数的方法重载</strong>吧，否则让人伤脑筋不说，说不定哪天就陷入这类小陷阱里了。</p>
<h3><span id="建议5别让null值和空值威胁到变长方法">建议5：别让null值和空值威胁到变长方法</span></h3><p>上一建议讲解了变长参数的重载问题，本建议会继续讨论变长参数的重载问题，上一建议的例子是变长参数的范围覆盖了非变长参数的范围，这次讨论两个都是变长参数的方法说起，代码如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client5</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> is<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Client5 client5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Client5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        client5<span class="token punctuation">.</span><span class="token function">methodA</span><span class="token punctuation">(</span><span class="token string">"china"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        client5<span class="token punctuation">.</span><span class="token function">methodA</span><span class="token punctuation">(</span><span class="token string">"china"</span><span class="token punctuation">,</span> <span class="token string">"people"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        client5<span class="token punctuation">.</span><span class="token function">methodA</span><span class="token punctuation">(</span><span class="token string">"china"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        client5<span class="token punctuation">.</span><span class="token function">methodA</span><span class="token punctuation">(</span><span class="token string">"china"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    两个methodA都进行了重载，现在的问题是：上面的client5.methodA(“china”);client5.methodA(“china”, null);编译不通过，提示相同：方法模糊不清，编译器不知道调用哪一个方法，但这两处代码反应的味道是不同的。</p>
<p>　　对于methodA(“china”)方法，根据实参”china”(String类型)，两个方法都符合形参格式，编译器不知道调用那个方法，于是报错。我们思考一下此问题：Client5这个类是一个复杂的商业逻辑，提供了两个重载方法，从其它模块调用（系统内本地调用系统或系统外远程系统调用）时，调用者根据变长参数的规范调用，传入变长参数的参数数量可以是N个（N&gt;=0）,那当然可以写成client5.methodA(“china”)方法啊！完全符合规范，但是这个却让编译器和调用者郁闷，程序符合规则却不能运行，如此问题，谁之责任呢？是Client5类的设计者，他违反了KISS原则(Keep it Smile,Stupid,即懒人原则)，按照此设计的方法应该很容一调用，可是现在遵循规范却编译不通过，这对设计者和开发者而言都是应该禁止出现的。</p>
<p>　　对于Client5.methodA(“China”,null),直接量null是没有类型的，虽然两个methodA方法都符合调用要求，但不知道调用哪一个，于是报错了。仔细分析一下，除了不符合上面的懒人原则之外，还有一个非常不好的编码习惯，即调用者隐藏了实参类型，这是非常危险的，不仅仅调用者需要”猜测调用那个方法”，而且被调用者也可能产生内部逻辑混乱的情况。对于本例来说应该如此修改:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Client5 client5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Client5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String strs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
    client5<span class="token punctuation">.</span><span class="token function">methodA</span><span class="token punctuation">(</span><span class="token string">"china"</span><span class="token punctuation">,</span> strs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>也就是说让编译器知道这个null值是String类型的，编译即可顺利通过，也就减少了错误的发生。</p>
<h3><span id="建议6覆写变长方法也循规蹈矩">建议6：覆写变长方法也循规蹈矩</span></h3><p>在JAVA中，子类覆写父类的中的方法很常见，这样做既可以修正bug，也可以提供扩展的业务功能支持，同时还符合开闭原则(Open-Closed Principle)。</p>
<p>符合开闭原则(Open-Closed Principle)的主要特征：</p>
<p>　　1.对于扩展是开放的（Open for extension）。这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。</p>
<p>　　2.对于修改是关闭的（Closed for modification）。对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二进制可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。</p>
<p>下面我们看一下覆写必须满足的条件：</p>
<ol>
<li>覆写方法不能缩小访问权限；</li>
<li>参数列表必须与被覆写方法相同；</li>
<li>返回类型必须与被重写方法的相同；</li>
<li>重写方法不能抛出新的异常，或者超出父类范围的异常，但是可以抛出更少，更有限的异常，或者不抛出异常。</li>
</ol>
<p>看下面这段代码:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client6</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 向上转型</span>
        Base base <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        base<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 不转型</span>
        Sub sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sub<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 基类</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> price<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> discounts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base......fun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 子类，覆写父类方法</span>
<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> price<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> discounts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sub......fun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>该程序中sub.fun(100, 50)报错，提示找不到fun(int,int)方法。这太奇怪了：子类继承了父类的所有属性和方法，甭管是私有的还是公开的访问权限，同样的参数，同样的方法名，通过父类调用没有任何问题，通过子类调用，却编译不过，为啥？难到是没继承下来？或者子类缩小了父类方法的前置条件？如果是这样，就不应该覆写，@Override就应该报错呀。</p>
<p>　　事实上，<strong>base对象是把子类对象做了向上转型，形参列表由父类决定，由于是变长参数，在编译时,base.fun(100, 50);中的50这个实参会被编译器”猜测”而编译成”{50}”数组，再由子类Sub执行</strong>。我们再来看看直接调用子类的情况，这时编译器并不会把”50”座类型转换因为数组本身也是一个对象，编译器还没有聪明到要在两个没有继承关系的类之间转换，要知道JAVA是要求严格的类型匹配的，类型不匹配编译器自然就会拒绝执行，并给予错误提示。</p>
<p>　　这是个特例，覆写的方法参数列表竟然与父类不相同，这违背了覆写的定义，并且会引发莫名其妙的错误。所以读者在对变长参数进行覆写时，如果要使用次类似的方法，请仔细想想是不是要一定如此。</p>
<p><strong><font color="red">注意：覆写的方法参数与父类相同，不仅仅是类型、数量，还包括显示形式.</font></strong></p>
<h3><span id="建议7警惕自增的陷阱">建议7：警惕自增的陷阱</span></h3><p>​    记得大学刚开始学C语言时，老师就说：自增有两种形式，分别是i++和++i,i++表示的先赋值后加1，++i是先加1后赋值，这样理解了很多年也木有问题，直到遇到如下代码，我才怀疑我的理解是不是错了:　　　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client7</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            count<span class="token operator">=</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count = "</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这个程序输出的count等于几？是count自加10次吗？答案等于10？可以肯定的说，这个运行结果是count=0。为什么呢？</p>
<p>　　count++是一个表达式，是由返回值的，它的返回值就是count自加前的值，Java对自加是这样处理的：首先把count的值(注意是值，不是引用)拷贝到一个临时变量区，然后对count变量+1，最后返回临时变量区的值。程序第一次循环处理步骤如下:</p>
<ol>
<li>JVM把count的值（其值是0）拷贝到临时变量区；</li>
<li>count的值+1，这时候count的值是1；</li>
<li>返回临时变量区的值，注意这个值是0，没修改过；</li>
<li>返回值赋给count，此时count的值被重置为0.</li>
</ol>
<p>“count=count++”这条语句可以按照如下代码理解：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mockAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 先保存初始值</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> count<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 做自增操作</span>
    count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 返回原始值</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    于是第一次循环后count的值为0，其它9次循环也是一样的，最终你会发现count的值始终没有改变，仍然保持着最初的状态.</p>
<p>　　此例中代码作者的本意是希望count自增，所以想当然的赋值给自身就可以了，不曾想到调到Java自增的陷阱中了，解决办法很简单，把”count=count++”改为”count++”即可。该问题在不同的语言环境中有着不同的实现：C++中”count=count++”与”count++”是等效的，而在PHP中保持着与JAVA相同的处理方式。每种语言对自增的实现方式各不相同。</p>
<h3><span id="建议8不要让旧语法困扰你">建议8：不要让旧语法困扰你</span></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client8</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 数据定义初始化</span>
        <span class="token keyword">int</span> fee <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 其它业务处理</span>
        saveDefault<span class="token operator">:</span> <span class="token function">save</span><span class="token punctuation">(</span>fee<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">saveDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　　　System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"saveDefault...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">int</span> fee<span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　　　System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"save...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这段代码分析一下，输出结果，以及语法含义：</p>
<ol>
<li>首先这段代码中有标号(:)操作符，C语言的同学一看便知，类似JAVA中的保留关键字 go to 语句，但Java中抛弃了goto语法，只是不进行语义处理，与此类似的还有const关键字。</li>
<li>Java中虽然没有了goto语法，但扩展了break和continue关键字，他们的后面都可以加上标号做跳转，完全实现了goto功能，同时也把goto的诟病带进来了。</li>
<li>运行之后代码输入为”save….”,运行时没错，但这样的代码，给大家阅读上造成了很大的问题，所以就语法就让他随风远去吧!</li>
</ol>
<h3><span id="建议9少用静态导入">建议9：少用静态导入</span></h3><p>​    从Java5开始引入了静态导入语法(import static),其目的是为了减少字符的输入量，提高代码的可阅读性，以便更好地理解程序。我们先俩看一个不用静态导入的例子，也就是一般导入：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client9</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 计算圆面积</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">claCircleArea</span><span class="token punctuation">(</span><span class="token keyword">double</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 计算球面积</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">claBallArea</span><span class="token punctuation">(</span><span class="token keyword">double</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">4</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    这是很简单的两个方法，我们再这两个计算面积的方法中都引入了java.lang.Math类(该类是默认导入的)中的PI(圆周率)常量，而Math这个类写在这里有点多余，特别是如果Client9类中的方法比较多时。如果每次输入都需要敲入Math这个类，繁琐且多余，静态导入可以解决此问题，使用静态导入后的程序如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>PI<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client9</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 计算圆面积</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">claCircleArea</span><span class="token punctuation">(</span><span class="token keyword">double</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> PI <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 计算球面积</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">claBallArea</span><span class="token punctuation">(</span><span class="token keyword">double</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">4</span> <span class="token operator">*</span> PI <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    静态导入的作用是把Math类中的Pi常量引入到本类中，这会是程序更简单，更容易阅读，只要看到PI就知道这是圆周率，不用每次都把类名写全了。但是，滥用静态导入会使程序更难阅读，更难维护，静态导入后，代码中就不需要再写类名了，但我们知道类是”一类事物的描述”，缺少了类名的修饰，静态属性和静态方法的表象意义可以被无限放大，这会让阅读者很难弄清楚其属性或者方法代表何意，绳子哪一类的属性(方法)都要思考一番（当然IDE的友好提示功能另说），把一个类的静态导入元素都引入进来了，那简直就是噩梦。我们来看下面的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Double<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Integer<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>NumberFormat<span class="token punctuation">.</span>*<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>NumberFormat<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client9</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">formatMessage</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"圆面积是: "</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">double</span> s <span class="token operator">=</span> PI <span class="token operator">*</span> <span class="token function">parseDouble</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        NumberFormat nf <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nf<span class="token punctuation">.</span><span class="token function">setMaximumFractionDigits</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">formatMessage</span><span class="token punctuation">(</span>nf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>就这么一段程序，看着就让人恼火，常量PI，这知道是圆周率；parseDouble方法可能是Double类的一个转换方法，这看名称可以猜的到。那紧接着getInstance()方法是哪个类的？是Client9本地类？不对呀，本地没有这个方法，哦，原来是NumberFormat类的方法，这个和formatMessage本地方法没有任何区别了—这代码太难阅读了，肯定有人骂娘。</p>
<p>　　所以，对于静态导入，一定要追寻两个原则：</p>
<ol>
<li><em><em>不使用</em>(星号)通配符，除非是导入静态常量类(只包含常量的类或接口)；</em>*</li>
<li><strong>方法名是具有明确、清晰表象意义的工具类。</strong></li>
</ol>
<p>何为具有明确、清晰表象意义的工具类，我们看看Junit中使用静态导入的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Assert<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">DaoTest</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//断言</span>
        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assertFalse</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    我们从程序中很容易判断出assertEquals方法是用来断言两个值是否相等的，assertFalse方法则是断言表达式为假，如此确实减少了代码量，而且代码的可读性也提高了，这也是静态导入用到正确的地方带来的好处。</p>
<h3><span id="建议10不要在本类中覆盖静态导入的变量和方法">建议10：不要在本类中覆盖静态导入的变量和方法</span></h3><p>如果在一个类中的方法及属性与静态导入的方法及属性相同会出现什么问题呢?看下面的代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>PI<span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>abs<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client10</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 常量名于静态导入的PI相同</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String PI <span class="token operator">=</span> <span class="token string">"祖冲之"</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//方法名于静态导入的方法相同</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token keyword">int</span> abs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"PI = "</span><span class="token operator">+</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"abs(-100) = "</span><span class="token operator">+</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>以上代码中定义了一个String类型的常量PI，又定义了一个abs方法，与静态导入的相同。首先说好消息，代码没有报错，接下来是坏消息:我们不知道那个属性和方法别调用了，因为常量名和方法名相同，到底调用了那一个方法呢？运行之后结果为：</p>
<p>　　PI = “祖冲之”，abs(-100) = 0;<br>　　很明显是本地的方法被调用了，为何不调用Math类中的属性和方法呢？那是因为编译器有一个**”最短路径”原则:如果能够在本类中查找到相关的变量、常量、方法、就不会去其它包或父类、接口中查找，以确保本类中的属性、方法优先。**</p>
<p><strong><font color="red">因此，如果要变更一个被静态导入的方法，最好的办法是在原始类中重构，而不是在本类中覆盖.</font></strong></p>
<h3><span id="建议11养成良好习惯显示声明uid">建议11：养成良好习惯，显示声明UID</span></h3><p>​    我们编写一个实现了Serializable接口（序列化标志接口）的类，Eclipse马上就会给一个黄色警告：需要添加一个Serial Version ID。为什么要增加？他是怎么计算出来的？有什么用?下面就来解释该问题。</p>
<p>　　类实现Serializable接口的目的是为了可持久化，比如网络传输或本地存储，为系统的分布和异构部署提供先决条件支持。若没有序列化，现在我们熟悉的远程调用、对象数据库都不可能存在，我们来看一个简单的序列化类：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>这是一个简单的JavaBean，实现了Serializable接口，可以在网络上传输，也可以在本地存储然后读取。这里我们以java消息服务(Java Message Service)方式传递对象（即通过网络传递一个对象），定义在消息队列中的数据类型为ObjectMessage，首先定义一个消息的生产者（Producer）,代码如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"混世魔王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 序列化，保存到磁盘上</span>
        SerializationUtils<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这里引入了一个工具类SerializationUtils，其作用是对一个类进行序列化和反序列化，并存储到硬盘上（模拟网络传输），其代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileInputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileOutputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectOutputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SerializationUtils</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> String FILE_NAME <span class="token operator">=</span> <span class="token string">"c:/obj.bin"</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//序列化</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span>Serializable s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>FILE_NAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            oos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//反序列化</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Object obj <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            ObjectInputStream input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>FILE_NAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            obj<span class="token operator">=</span>input<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>通过对象序列化过程，把一个内存块转化为可传输的数据流，然后通过网络发送到消息消费者（Customer）哪里，进行反序列化，生成实验对象，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//反序列化</span>
        Person p<span class="token operator">=</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span> SerializationUtils<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    这是一个反序列化的过程，也就是对象数据流转换为一个实例的过程，其运行后的输出结果为“混世魔王”。这太easy了,是的，这就是序列化和反序列化的典型Demo。但此处藏着一个问题：如果消息的生产者和消息的消费者（Person类）有差异，会出现何种神奇事件呢？比如：消息生产者中的Person类添加一个年龄属性，而消费者没有增加该属性。为啥没有增加？因为这个是分布式部署的应用，你甚至不知道这个应用部署在何处，特别是通过广播方式发消息的情况，漏掉一两个订阅者也是很正常的。</p>
<p>　　这中序列化和反序列化的类在不一致的情况下，反序列化时会报一个InalidClassException异常，原因是序列化和反序列化所对应的类版本发生了变化，JVM不能把数据流转换为实例对象。刨根问底：JVM是根据什么来判断一个类的版本呢？</p>
<p>   好问题，通过SerializableUID，也叫做流标识符（Stream Unique Identifier），即类的版本定义的，它可以显示声明也可以隐式声明。显示声明格式如下：</p>
<p>　　 private static final long serialVersionUID = 1867341609628930239L; </p>
<p> 而隐式声明则是我不声明，你编译器在编译的时候帮我生成。生成的依据是通过包名、类名、继承关系、非私有的方法和属性，以及参数、返回值等诸多因子算出来的，极度复杂，基本上计算出来的这个值是唯一的。</p>
<p>　　serialVersionUID如何生成已经说明了，我们再来看看serialVersionUID的作用。JVM在反序列化时，会比较数据流中的serialVersionUID与类的serialVersionUID是否相同，如果相同，则认为类没有改变，可以把数据load为实例相同；如果不相同，对不起，我JVM不干了，抛个异常InviladClassException给你瞧瞧。这是一个非常好的校验机制，可以保证一个对象即使在网络或磁盘中“滚过”一次，仍能做到“出淤泥而不染”，完美的实现了类的一致性。</p>
<p>　但是，有时候我们需要一点特例场景，例如我的类改变不大，JVM是否可以把我以前的对象反序列化回来？就是依据显示声明的serialVersionUID，向JVM撒谎说”我的类版本没有变化”，如此我买你编写的类就实现了向上兼容，我们修改Person类,里面添加private static final long serialVersionUID = 1867341609628930239L;</p>
<p>　　刚开始生产者和消费者持有的Person类一致，都是V1.0，某天生产者的Person类变更了，增加了一个“年龄”属性，升级为V2.0，由于种种原因（比如程序员疏忽，升级时间窗口不同等）消费端的Person类还是V1.0版本，添加的代码为 priavte int age;以及对应的setter和getter方法。</p>
<p>　　此时虽然生产这和消费者对应的类版本不同，但是显示声明的serialVersionUID相同，序列化也是可以运行的，所带来的业务问题就是消费端不能读取到新增的业务属性(age属性而已)。通过此例，我们反序列化也实现了版本向上兼容的功能，使用V1.0版本的应用访问了一个V2.0的对象，这无疑提高了代码的健壮性。我们在编写序列化类代码时随手添加一个serialVersionUID字段，也不会带来太多的工作量，但它却可以在关键时候发挥异乎寻常的作用。</p>
<p><strong><font color="red">显示声明serialVersionUID可以避免对象的不一致，但尽量不要以这种方式向JVM撒谎。</font></strong></p>
<h3><span id="建议12避免用序列化类在构造函数中为不变量赋值">建议12：避免用序列化类在构造函数中为不变量赋值</span></h3><p>​    我们知道带有final标识的属性是不变量，也就是只能赋值一次，不能重复赋值，但是在序列化类中就有点复杂了，比如这个类：</p>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1867341609628930239L<span class="token punctuation">;</span>
     <span class="token keyword">public</span> <span class="token keyword">final</span> String perName<span class="token operator">=</span><span class="token string">"程咬金"</span><span class="token punctuation">;</span>
｝
</code></pre>
<p>　这个Peson类（此时V1.0版本）被序列化，然后存储在磁盘上，在反序列化时perName属性会重新计算其值(这与static变量不同，static变量压根就没有保存到数据流中)比如perName属性修改成了”秦叔宝”(版本升级为V2.0)，那么反序列化的perName值就是”秦叔宝”。保持新旧对象的final变量相同，有利于代码业务逻辑统一，这是序列化的基本原则之一，也就是说，如果final属性是一个直接量，在反序列化时就会重新计算。对于基本原则不多说，现在说一下final变量的另一种赋值方式：通过构造函数赋值。代码如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1867341609628930239L<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> String perName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        perName <span class="token operator">=</span> <span class="token string">"程咬金"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    这也是我们常用的一种赋值方式，可以把Person类定义为版本V1.0，然后进行序列化，看看序列化后有什么问题,序列化代码如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Serialize</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//序列化以持久保持</span>
        SerializationUtils<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    Person的实习对象保存到了磁盘上，它时一个贫血对象(承载业务属性定义，但不包含其行为定义)，我们做一个简单的模拟，修改一下PerName值代表变更，要注意的是serialVersionUID不变，修改后的代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1867341609628930239L<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> String perName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        perName <span class="token operator">=</span> <span class="token string">"秦叔宝"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>此时Person类的版本时V2.0但serialVersionUID没有改变，仍然可以反序列化，代码如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Deserialize</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Person p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> SerializationUtils<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>perName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>现在问题出来了，打印出来的结果是”程咬金” 还是”秦叔宝”？答案是:”程咬金”。final类型的变量不是会重新计算嘛，打印出来的应该是秦叔宝才对呀。为什么会是程咬金？这是因为这里触及到了反序列化的两一个原则:<strong>反序列化时构造函数不会执行.</strong></p>
<p>　　反序列化的执行过程是这样的：JVM从数据流中获取一个Object对象，然后根据数据流中的类文件描述信息(在序列化时，保存到磁盘的对象文件中包含了类描述信息，注意是描述信息，不是类)查看，发现是final变量，需要重新计算，于是引用Person类中的perName值，而此时JVM又发现perName竟没有赋值，不能引用，于是它很聪明的不再初始化，保持原值状态，所以结果就是”程咬金”了。</p>
<p><strong><font color="red">注意：在序列化类中不使用构造函数为final变量赋值.</font></strong></p>
<h3><span id="建议13避免为final变量复杂赋值">建议13：避免为final变量复杂赋值</span></h3><p>​    为final变量赋值还有另外一种方式：通过方法赋值，及直接在声明时通过方法的返回值赋值，还是以Person类为例来说明，代码如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1867341609628930239L<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//通过方法返回值为final变量赋值</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> String pName <span class="token operator">=</span> <span class="token function">initName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> String <span class="token function">initName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"程咬金"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　pName属性是通过initName方法的返回值赋值的，这在复杂的类中经常用到，这比使用构造函数赋值更简洁，易修改，那么如此用法在序列化时会不会有问题呢？我们一起看看。Person类写好了（定义为V1.0版本），先把它序列化，存储到本地文件，其代码与之前相同，不在赘述。现在Person类的代码需要修改，initName的返回值改为”秦叔宝”.那么我们之前存储在磁盘上的的实例加载上来，pName的会是什么呢？</p>
<p>　　现在,Person类的代码需要修改，initName的返回值也改变了，代码如下:　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1867341609628930239L<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//通过方法返回值为final变量赋值</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> String pName <span class="token operator">=</span> <span class="token function">initName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> String <span class="token function">initName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"秦叔宝"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    上段代码仅仅修改了initName的返回值(Person类为V2.0版本)也就是通过new生成的对象的final变量的值都是”秦叔宝”，那么我们把之前存储在磁盘上的实例加载上来，pName的值会是什么呢？</p>
<p>　结果是”程咬金”，很诧异，上一建议说过final变量会被重新赋值，但是这个例子又没有重新赋值，为什么？</p>
<p>　　上个建议说的重新赋值，其中的”值”指的是简单对象。简单对象包括：8个基本类型，以及数组、字符串(字符串情况复杂，不通过new关键字生成的String对象的情况下，final变量的赋值与基本类型相同)，但是不能方法赋值。</p>
<p>　　其中的原理是这样的，保存到磁盘上(或网络传输)的对象文件包括两部分:</p>
<p>　　(1).类描述信息：包括类路径、继承关系、访问权限、变量描述、变量访问权限、方法签名、返回值、以及变量的关联类信息。要注意一点是，它并不是class文件的翻版，它不记录方法、构造函数、static变量等的具体实现。之所以类描述会被保存，很简单，是因为能去也能回嘛，这保证反序列化的健壮运行。</p>
<p>　　(2).非瞬态(transient关键字)和非静态(static关键字)的实体变量值</p>
<p>　　注意，这里的值如果是一个基本类型，好说，就是一个简单值保存下来；如果是复杂对象，也简单，连该对象和关联类信息一起保存，并且持续递归下去（关联类也必须实现Serializable接口，否则会出现序列化异常），也就是递归到最后，还是基本数据类型的保存。</p>
<p>　　正是因为这两个原因，一个持久化的对象文件会比一个class类文件大很多，有兴趣的读者可以自己测试一下，体积确实膨胀了不少。</p>
<p><strong>总结一下：反序列化时final变量在以下情况下不会被重新赋值:</strong></p>
<ol>
<li><strong>通过构造函数为final变量赋值</strong></li>
<li><strong>通过方法返回值为final变量赋值</strong></li>
<li><strong>final修饰的属性不是基本类型</strong></li>
</ol>
<h3><span id="建议14使用序列化类的私有方法巧妙解决部分属性持久化问题">建议14：使用序列化类的私有方法巧妙解决部分属性持久化问题</span></h3><p>​    部分属性持久化问题看似很简单，只要把不需要持久化的属性加上瞬态关键字(transient关键字)即可。这是一种解决方案，但有时候行不通。例如一个计税系统和一个HR系统，通过RMI(Remote Method Invocation,远程方法调用)对接，计税系统需要从HR系统获得人员的姓名和基本工资，以作为纳税的依据，而HR系统的工资分为两部分：基本工资和绩效工资，基本工资没什么秘密，绩效工资是保密的，不能泄露到外系统，这明显是连个相互关联的类，先看看薪水类Salary的代码：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Salary</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 2706085398747859680L<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 基本工资</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> basePay<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 绩效工资</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> bonus<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Salary</span><span class="token punctuation">(</span><span class="token keyword">int</span> _basepay<span class="token punctuation">,</span> <span class="token keyword">int</span> _bonus<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>basePay <span class="token operator">=</span> _basepay<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>bonus <span class="token operator">=</span> _bonus<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//Setter和Getter方法略</span>

<span class="token punctuation">}</span>
</code></pre>
<p>Person类和Salary类是关联关系，代码如下:　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 9146176880143026279L<span class="token punctuation">;</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">private</span> Salary salary<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String _name<span class="token punctuation">,</span> Salary _salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> _salary<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//Setter和Getter方法略</span>

<span class="token punctuation">}</span>
</code></pre>
<p>这是两个简单的JavaBean，都实现了Serializable接口，具备了序列化的条件。首先计税系统请求HR系统对一个Person对象进行序列化，把人员信息和工资信息传递到计税系统中，代码如下:　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Serialize</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 基本工资1000元，绩效工资2500元</span>
        Salary salary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Salary</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">2500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 记录人员信息</span>
        Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// HR系统持久化,并传递到计税系统</span>
        SerializationUtils<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在通过网络传输到计税系统后，进行反序列化，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Deserialize</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Person p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> SerializationUtils<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        StringBuffer buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        buf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"姓名: "</span><span class="token operator">+</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        buf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\t基本工资: "</span><span class="token operator">+</span>p<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBasePay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        buf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\t绩效工资: "</span><span class="token operator">+</span>p<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBonus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>打印出的结果为:姓名: 张三   基本工资: 1000   绩效工资: 2500</p>
<p>但是这不符合需求，因为计税系统只能从HR系统中获取人员姓名和基本工资，而绩效工资是不能获得的，这是个保密数据，不允许发生泄漏。怎么解决这个问题呢？你可能会想到以下四种方案:</p>
<ol>
<li>在bonus前加上关键字transient：这是一个方法，但不是一个好方法，加上transient关键字就标志着Salary失去了分布式部署的功能，它可能是HR系统核心的类了，一旦遭遇性能瓶颈，再想实现分布式部署就可能了，此方案否定;</li>
<li>新增业务对象：增加一个Person4Tax类，完全为计税系统服务，就是说它只有两个属性：姓名和基本工资。符合开闭原则，而且对原系统也没有侵入性，只是增加了工作量而已。但是这个方法不是最优方法;</li>
<li>请求端过滤：在计税系统获得Person对象后，过滤掉Salary的bonus属性，方案可行但不符合规矩，因为HR系统中的Salary类安全性竟然然外系统(计税系统来承担)，设计严重失职;</li>
<li>变更传输契约：例如改用XML传输，或者重建一个WebSerive服务，可以做但成本很高。</li>
</ol>
<p>下面展示一个优秀的方案，其中实现了Serializable接口的类可以实现两个私有方法：writeObject和readObject，以影响和控制序列化和反序列化的过程。我们把Person类稍作修改，看看如何控制序列化和反序列化，代码如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 9146176880143026279L<span class="token punctuation">;</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">transient</span> Salary salary<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String _name<span class="token punctuation">,</span> Salary _salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> _salary<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//序列化委托方法</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span>ObjectOutputStream oos<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
        oos<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        oos<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>salary<span class="token punctuation">.</span><span class="token function">getBasePay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//反序列化委托方法</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>ObjectInputStream input<span class="token punctuation">)</span><span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>
        input<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        salary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Salary</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>其它代码不做任何改动，运行之后结果为：姓名: 张三   基本工资: 1000   绩效工资: 0</p>
<p>在Person类中增加了writeObject和readObject两个方法，并且访问权限都是私有级别，为什么会改变程序的运行结果呢？其实这里用了序列化的独有机制：序列化回调。Java调用ObjectOutputStream类把一个对象转换成数据流时，会通过反射（Refection）检查被序列化的类是否有writeObject方法，并且检查其是否符合私有，无返回值的特性，若有，则会委托该方法进行对象序列化，若没有，则由ObjectOutputStream按照默认规则继续序列化。同样，在从流数据恢复成实例对象时，也会检查是否有一个私有的readObject方法，如果有，则会通过该方法读取属性值，此处有几个关键点需要说明：</p>
<ol>
<li>oos.defaultWriteObject():告知JVM按照默认的规则写入对象，惯例的写法是写在第一行。</li>
<li>input.defaultReadObject():告知JVM按照默认规则读入对象，惯例的写法是写在第一行。</li>
<li>oos.writeXX和input.readXX</li>
</ol>
<p>分别是写入和读出相应的值，类似一个队列，先进先出，如果此处有复杂的数据逻辑，建议按封装Collection对象处理。大家可能注意到上面的方式也是Person失去了分布式部署的能了，确实是，但是HR系统的难点和重点是薪水的计算，特别是绩效工资，它所依赖的参数很复杂（仅从数量上说就有上百甚至上千种），计算公式也不简单(一般是引入脚本语言，个性化公式定制)而相对来说Person类基本上都是静态属性，计算的可能性不大，所以即使为性能考虑，Person类为分布式部署的意义也不大。</p>
<h3><span id="建议15break万万不可忘">建议15：break万万不可忘</span></h3><p>​    我们经常会写一些转换类，比如货币转换，日期转换，编码转换等，在金融领域里用到的最多的要数中文数字转换了，比如把”1”转换为”壹”　，不过开源工具是不会提供此工具类的，因为它太贴近中国文化了，需要自己编写：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client15</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">toChineseNuberCase</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toChineseNuberCase</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String chineseNumber <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>
            chineseNumber <span class="token operator">=</span> <span class="token string">"零"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
            chineseNumber <span class="token operator">=</span> <span class="token string">"壹"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
            chineseNumber <span class="token operator">=</span> <span class="token string">"贰"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>
            chineseNumber <span class="token operator">=</span> <span class="token string">"叁"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>
            chineseNumber <span class="token operator">=</span> <span class="token string">"肆"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>
            chineseNumber <span class="token operator">=</span> <span class="token string">"伍"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span>
            chineseNumber <span class="token operator">=</span> <span class="token string">"陆"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span>
            chineseNumber <span class="token operator">=</span> <span class="token string">"柒"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">8</span><span class="token operator">:</span>
            chineseNumber <span class="token operator">=</span> <span class="token string">"捌"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">9</span><span class="token operator">:</span>
            chineseNumber <span class="token operator">=</span> <span class="token string">"玖"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> chineseNumber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    这是一个简单的代码，但运行结果却是”玖”，这个很简单，可能大家在刚接触语法时都学过，但虽简单，如果程序员漏写了，简单的问题会造成很大的后果，甚至经济上的损失。所以在用switch语句上记得加上break，养成良好的习惯。对于此类问题，除了平常小心之外，可以使用单元测试来避免，但大家都晓得，项目紧的时候，可能但单元测试都覆盖不了。所以对于此类问题，一个最简单的办法就是：修改IDE的警告级别，例如在Eclipse中，可以依次点击PerFormaces–&gt;Java–&gt;Compiler–&gt;Errors/Warings–&gt;Potential Programming problems,然后修改’switch’ case fall-through为Errors级别，如果你胆敢不在case语句中加入break，那Eclipse直接就报个红叉给你看，这样可以避免该问题的发生了。但还是啰嗦一句，养成良好习惯更重要!</p>
<h3><span id="建议16易变业务使用脚本语言编写">建议16：易变业务使用脚本语言编写</span></h3><p>　Java世界一直在遭受着异种语言的入侵，比如PHP，Ruby，Groovy、Javascript等，这些入侵者都有一个共同特征：全是同一类语言—–脚本语言，它们都是在运行期解释执行的。为什么Java这种强编译型语言会需要这些脚本语言呢？那是因为脚本语言的三大特征，如下所示：</p>
<ol>
<li>灵活：脚本语言一般都是动态类型，可以不用声明变量类型而直接使用，可以再运行期改变类型。　　</li>
<li>便捷：脚本语言是一种解释性语言，不需要编译成二进制代码，也不需要像Java一样生成字节码。它的执行时依靠解释器解释的，因此在运行期间变更代码很容易，而且不用停止应用；</li>
<li>简单：只能说部分脚本语言简单，比如Groovy，对于程序员来说，没有多大的门槛。</li>
</ol>
<p>　　脚本语言的这些特性是Java缺少的，引入脚本语言可以使Java更强大，于是Java6开始正式支持脚本语言。但是因为脚本语言比较多，Java的开发者也很难确定该支持哪种语言，于是JSCP（Java Community ProCess）很聪明的提出了JSR233规范，只要符合该规范的语言都可以在Java平台上运行（它对JavaScript是默认支持的）。</p>
<p>　　简单看看下面这个小例子：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">formual</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> var1 <span class="token operator">+</span> var2 <span class="token operator">*</span> factor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这就是一个简单的脚本语言函数，可能你会很疑惑:factor(因子)这个变量是从那儿来的？它是从上下文来的，类似于一个运行的环境变量。该js保存在C:/model.js中，下一步需要调用JavaScript公式，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileReader<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span>

<span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>Bindings<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>Invocable<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>ScriptContext<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>ScriptEngine<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>ScriptEngineManager<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>ScriptException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client16</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> FileNotFoundException<span class="token punctuation">,</span>
            ScriptException<span class="token punctuation">,</span> NoSuchMethodException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 获得一个JavaScript执行引擎</span>
        ScriptEngine engine <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScriptEngineManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEngineByName</span><span class="token punctuation">(</span><span class="token string">"javascript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 建立上下文变量</span>
        Bindings bind <span class="token operator">=</span> engine<span class="token punctuation">.</span><span class="token function">createBindings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bind<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"factor"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 绑定上下文，作用于是当前引擎范围</span>
        engine<span class="token punctuation">.</span><span class="token function">setBindings</span><span class="token punctuation">(</span>bind<span class="token punctuation">,</span> ScriptContext<span class="token punctuation">.</span>ENGINE_SCOPE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Scanner input <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">hasNextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> first <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> second <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入参数是："</span><span class="token operator">+</span>first<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 执行Js代码</span>
            engine<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"C:/model.js"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 是否可调用方法</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>engine <span class="token keyword">instanceof</span> <span class="token class-name">Invocable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                Invocable in <span class="token operator">=</span> <span class="token punctuation">(</span>Invocable<span class="token punctuation">)</span> engine<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 执行Js中的函数</span>
                Double result <span class="token operator">=</span> <span class="token punctuation">(</span>Double<span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">invokeFunction</span><span class="token punctuation">(</span><span class="token string">"formula"</span><span class="token punctuation">,</span> first<span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运算结果是："</span> <span class="token operator">+</span> result<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上段代码使用Scanner类接受键盘输入的两个数字，然后调用JavaScript脚本的formula函数计算其结果，注意，除非输入了一个非int数字，否则当前JVM会一直运行，这也是模拟生成系统的在线变更情况。运行结果如下：</p>
<p>　输入参数是;1,2 运算结果是：3</p>
<p>此时，保持JVM的运行状态，我们修改一下formula函数，代码如下：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">formual</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> var1 <span class="token operator">+</span> var2 <span class="token operator">-</span> factor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>其中,乘号变成了减号，计算公式发生了重大改变。回到JVM中继续输入，运行结果如下：</p>
<p>输入参数：1,2 运行结果是：2</p>
<p>   修改Js代码，JVM没有重启，输入参数也没有任何改变，仅仅改变脚本函数即可产生不同的效果。这就是脚本语言对系统设计最有利的地方：可以随时发布而不用部署；这也是我们javaer最喜爱它的地方—-即使进行变更，也能提供不间断的业务服务。</p>
<p>  Java6不仅仅提供了代码级的脚本内置，还提供了jrunscript命令工具，它可以再批处理中发挥最大效能，而且不需要通过JVM解释脚本语言，可以直接通过该工具运行脚本。想想看。这是多么大的诱惑力呀！而且这个工具是可以跨操作系统的，脚本移植就更容易了。</p>
<h3><span id="建议17慎用动态编译">建议17：慎用动态编译</span></h3><p>​    动态编译一直是java的梦想，从Java6开始支持动态编译了，可以再运行期直接编译.java文件，执行.class，并且获得相关的输入输出，甚至还能监听相关的事件。不过，我们最期望的还是定一段代码，直接编译，然后运行，也就是空中编译执行（on-the-fly），看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URI<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span>

<span class="token keyword">import</span> javax<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>JavaCompiler<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>JavaFileObject<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>SimpleJavaFileObject<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>StandardJavaFileManager<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>ToolProvider<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client17</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Java源代码</span>
        String sourceStr <span class="token operator">=</span> <span class="token string">"public class Hello { public String sayHello (String name) {return \"Hello,\"+name+\"!\";}}"</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 类名及文件名</span>
        String clsName <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 方法名</span>
        String methodName <span class="token operator">=</span> <span class="token string">"sayHello"</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 当前编译器</span>
        JavaCompiler cmp <span class="token operator">=</span> ToolProvider<span class="token punctuation">.</span><span class="token function">getSystemJavaCompiler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Java标准文件管理器</span>
        StandardJavaFileManager fm <span class="token operator">=</span> cmp<span class="token punctuation">.</span><span class="token function">getStandardFileManager</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">,</span>
                null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Java文件对象</span>
        JavaFileObject jfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringJavaObject</span><span class="token punctuation">(</span>clsName<span class="token punctuation">,</span> sourceStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 编译参数，类似于javac &lt;options>中的options</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">></span> optionsList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 编译文件的存放地方，注意：此处是为Eclipse工具特设的</span>
        optionsList<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"-d"</span><span class="token punctuation">,</span> <span class="token string">"./bin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 要编译的单元</span>
        List<span class="token operator">&lt;</span>JavaFileObject<span class="token operator">></span> jfos <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>jfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 设置编译环境</span>
        JavaCompiler<span class="token punctuation">.</span>CompilationTask task <span class="token operator">=</span> cmp<span class="token punctuation">.</span><span class="token function">getTask</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> fm<span class="token punctuation">,</span> null<span class="token punctuation">,</span>
                optionsList<span class="token punctuation">,</span> null<span class="token punctuation">,</span> jfos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 编译成功</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 生成对象</span>
            Object obj <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>clsName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span><span class="token operator">></span> cls <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 调用sayHello方法</span>
            Method m <span class="token operator">=</span> cls<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            String str <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"Dynamic Compilation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">StringJavaObject</span> <span class="token keyword">extends</span> <span class="token class-name">SimpleJavaFileObject</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 源代码</span>
    <span class="token keyword">private</span> String content <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 遵循Java规范的类名及文件</span>
    <span class="token keyword">public</span> <span class="token function">StringJavaObject</span><span class="token punctuation">(</span>String _javaFileName<span class="token punctuation">,</span> String _content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token function">_createStringJavaObjectUri</span><span class="token punctuation">(</span>_javaFileName<span class="token punctuation">)</span><span class="token punctuation">,</span> Kind<span class="token punctuation">.</span>SOURCE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        content <span class="token operator">=</span> _content<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 产生一个URL资源路径</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> URI <span class="token function">_createStringJavaObjectUri</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 注意，此处没有设置包名</span>
        <span class="token keyword">return</span> URI<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"String:///"</span> <span class="token operator">+</span> name <span class="token operator">+</span> Kind<span class="token punctuation">.</span>SOURCE<span class="token punctuation">.</span>extension<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 文本文件代码</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> CharSequence <span class="token function">getCharContent</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> ignoreEncodingErrors<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
        <span class="token keyword">return</span> content<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码较多，可以作为一个动态编译的模板程序。只要是在本地静态编译能够实现的任务，比如编译参数，输入输出，错误监控等，动态编译都能实现。</p>
<p>　　Java的动态编译对源提供了多个渠道。比如，可以是字符串，文本文件，字节码文件，还有存放在数据库中的明文代码或者字节码。汇总一句话，只要符合Java规范的就可以在运行期动态加载，其实现方式就是实现JavaFileObject接口，重写getCharContent、openInputStream、openOutputStream，或者实现JDK已经提供的两个SimpleJavaFileObject、ForwardingJavaFileObject,具体代码可以参考上个例子。</p>
<p>　　动态编译虽然是很好的工具，让我们可以更加自如的控制编译过程，但是在我们目前所接触的项目中还是使用较少。原因很简单，静态编译已经能够帮我们处理大部分的工作，甚至是全部的工作，即使真的需要动态编译，也有很好的替代方案，比如Jruby、Groovy等无缝的脚本语言。另外，我们在使用动态编译时，需要注意以下几点：</p>
<ol>
<li><strong>在框架中谨慎使用</strong>：比如要在struts中使用动态编译，动态实现一个类，它若继承自ActionSupport就希望它成为一个Action。能做到，但是debug很困难；再比如在Spring中，写一个动态类，要让它注入到Spring容器中，这是需要花费老大功夫的。</li>
<li><strong>不要在要求性能高的项目中使用</strong>：如果你在web界面上提供了一个功能，允许上传一个java文件然后运行，那就等于说:”我的机器没有密码，大家都可以看看”，这是非常典型的注入漏洞，只要上传一个恶意Java程序就可以让你所有的安全工作毁于一旦。</li>
<li><strong>记录动态编译过程</strong>：建议记录源文件，目标文件，编译过程，执行过程等日志，不仅仅是为了诊断，还是为了安全和审计，对Java项目来说，空中编译和运行时很不让人放心的，留下这些依据可以很好地优化程序。</li>
</ol>
<h3><span id="建议18避免instanceof非预期结果">建议18：避免instanceof非预期结果</span></h3><p> instanceof是一个简单的二元操作符，它是用来判断一个对象是否是一个类的实现，其操作类似于&gt;=、==，非常简单，我们看段程序，代码如下:　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client18</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// String对象是否是Object的实例 true</span>
        <span class="token keyword">boolean</span> b1 <span class="token operator">=</span> <span class="token string">"String"</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// String对象是否是String的实例 true</span>
        <span class="token keyword">boolean</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Object对象是否是String的实例 false</span>
        <span class="token keyword">boolean</span> b3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 拆箱类型是否是装箱类型的实例 编译不通过</span>
        <span class="token keyword">boolean</span> b4 <span class="token operator">=</span> <span class="token string">'A'</span> <span class="token keyword">instanceof</span> <span class="token class-name">Character</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 空对象是否是String的实例 false</span>
        <span class="token keyword">boolean</span> b5 <span class="token operator">=</span> null <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 转换后的空对象是否是String的实例 false</span>
        <span class="token keyword">boolean</span> b6 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> null <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Date是否是String的实例 编译不通过</span>
        <span class="token keyword">boolean</span> b7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 在泛型类型中判断String对象是否是Date的实例 false</span>
        <span class="token keyword">boolean</span> b8 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericClass</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isDateInstance</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">GenericClass</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 判断是否是Date类型</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isDateInstance</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> t <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>就这么一段程序，instanceof的应用场景基本都出现了，同时问题也产生了：这段程序中哪些语句编译不通过，我们一个一个的解释说:</p>
<ul>
<li><p>“String” instanceof Object：返回值是true，这很正常,”String”是一个字符串，字符串又继承了Object，那当然返回true了。</p>
</li>
<li><p>new String() instanceof String：返回值是true，没有任何问题，一个类的对象当然是它的实例了。</p>
</li>
<li><p>new Object() instanceof String：返回值为false，Object是父类，其对象当然不是String类的实例了。要注意的是，这句话其实完全可以编译通过，只要instanceof关键字的左右两个操作数有继承或实现关系，就可以编译通过。</p>
</li>
<li><p>‘A’ instanceof Character：这句话编译不通过，为什么呢？因为’A’是一个char类型，也就是一个基本类型，不是一个对象，instanceof只能用于<strong>对象的判断</strong>，不能用于基本类型的判断。</p>
</li>
<li><p>null instanceof String：返回值为false，这是instanceof特有的规则，若做操作数为null，结果就直接返回false，不再运算右操作数是什么类。这对我们的程序非常有利，在使用instanceof操作符时，不用关心被判断的类(也就是左操作数)是否为null，这与我们经常用到的equals、toString方法不同。</p>
</li>
<li><p>(String) null instanceof String：返回值为false，不要看这里有个强制类型转换就认为结果是true，不是的，null是一个万用类型，也就是说它可以没类型，即使做类型转换还是个null。</p>
</li>
<li><p>new Date() instanceof String：编译不通过，因为Date类和String没有继承或实现关系，所以在编译时就直接报错了，instanceof操作符的左右操作数必须有继承或实现关系，否则编译会失败。</p>
</li>
<li><p>new GenericClass<string>().isDateInstance(“”)：编译不通过，非也，编译通过了，返回值为false，T是个String类型，于Date之间没有继承或实现关系，为什么”t instanceof Date”会编译通过呢？那是因为Java的泛型是为编码服务的，在编译成字节码时，T已经是Object类型了传递的实参是String类型，也就是说T的表面类型是Object，实际类型是String，那么”t instanceof Date”等价于”Object instanceof Date”了，所以返回false就很正常了。</string></p>
</li>
</ul>
<h3><span id="建议19断言绝对不是鸡肋">建议19：断言绝对不是鸡肋</span></h3><p>在防御式编程中经常会用断言(Assertion)对参数和环境做出判断，避免程序因不当的判断或输入错误而产生逻辑异常，断言在很多语言中都存在，C、C++、Python都有不同的断言表现形式.在Java中断言使用的是assert关键字，其基本用法如下：</p>
<p>　　assert&lt;布尔表达式&gt;</p>
<p>　　assert&lt;布尔表达式&gt; : &lt;错误信息&gt;</p>
<p>在布尔表达式为假时，跑出AssertionError错误，并附带了错误信息。assert的语法比较简单，有以下两个特性：</p>
<p>　　（1）、assert默认是不启用的</p>
<p>　　　　　　我们知道断言是为调试程序服务的，目的是为了能够迅速、方便地检查到程序异常，但Java在默认条件下是不启用的，要启用就要在编译、运行时加上相关的关键字，这就不多说，有需要的话可以参考一下Java规范。</p>
<p>　　（2）、assert跑出的异常AssertionError是继承自Error的</p>
<p>　　　　　　断言失败后，JVM会抛出一个AssertionError的错误，它继承自Error，注意，这是一个错误，不可恢复，也就是表明这是一个严重问题，开发者必须予以关注并解决之。</p>
<p>　　assert虽然是做断言的，但不能将其等价于if…else…这样的条件判断，它在以下两种情况下不可使用：</p>
<p>　　(1)、在对外的公开方法中</p>
<p>　　　　我们知道防御式编程最核心的一点就是：所有的外部因素(输入参数、环境变量、上下文)都是”邪恶”的，都存在着企图摧毁程序的罪恶本源，为了抵制它，我们要在程序处处检验。满地设卡，不满足条件，就不执行后续程序，以保护后续程序的正确性，处处设卡没问题，但就是不能用断言做输入校验，特别是公开方法。我们开看一个例子：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client19</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">StringUtils</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">encode</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">assert</span>    str <span class="token operator">!=</span> null <span class="token operator">:</span> <span class="token string">"加密的字符串为null"</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/*加密处理*/</span>
        <span class="token keyword">return</span> str<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>encode方法对输入参数做了不为空的假设，如果为空，则抛出AssertionError错误，但这段程序存在一个严重的问题，encode是一个public方法，这标志着它时对外公开的，任何一个类只要能传递一个String类型的参数（遵守契约）就可以调用，但是Client19类按照规定和契约调用encode方法，却获得了一个AssertionError错误信息，是谁破坏了契约协议？—是encode方法自己。</p>
<p>　　(2)、在执行逻辑代码的情况下</p>
<p>　　　　assert的支持是可选的，在开发时可以让他运行，但在生产环境中系统则不需要其运行了（以便提高性能），因此在assert的布尔表达式中不能执行逻辑代码，否则会因为环境的不同而产生不同的逻辑，例如：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> Object element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span> list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"删除元素"</span> <span class="token operator">+</span> element <span class="token operator">+</span> <span class="token string">"失败"</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/*业务处理*/</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这段代码在assert启用的环境下没有任何问题，但是一但投入到生成环境，就不会启用断言了，而这个方法就彻底完蛋了，list的删除动作永远不会执行，所以就永远不会报错或异常了，因为根本就没有执行嘛！</p>
<p>　　以上两种情况下不能使用断言assert，那在什么情况下能够使用assert呢？一句话：按照正常的执行逻辑不可能到达的代码区域可以防止assert。具体分为三种情况：</p>
<ol>
<li>在私有方法中放置assert作为输入参数的校验：在私有方法中可以放置assert校验输入参数，因为私有方法的使用者是作者自己，私有的方法的调用者和被调用者是一种契约关系，或者说没有契约关系，期间的约束是靠作者自己控制的，因此加上assert可以更好地预防自己犯错，或者无意的程序犯错。</li>
<li>流程控制中不可能到达的区域：这类似于Junit的fail方法，其标志性的意义就是，程序执行到这里就是错误的，例如：</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/* 业务处理 */</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">assert</span> <span class="token boolean">false</span> <span class="token operator">:</span> <span class="token string">"到达这里就表示错误"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>3.建立程序探针：我们可能会在一段程序中定义两个变量，分别代两个不同的业务含义，但是两者有固定的关系，例如:var1=var2 * 2，那我们就可以在程序中到处设”桩”了，断言这两者的关系，如果不满足即表明程序已经出现了异常，业务也就没有必要运行下去了。</p>
<h3><span id="建议20不要只替换一个类">建议20：不要只替换一个类</span></h3><p>​    我们经常在系统中定义一个常量接口（或常量类），以囊括系统中所涉及的常量，从而简化代码，方便开发，在很多的开源项目中已经采用了类似的方法，比如在struts2中，org.apache.struts2.StrutsConstants就是一个常量类，它定义Struts框架中与配置有关的常量，而org.apache.struts2.StrutsConstants则是一个常量接口，其中定义了OGNL访问的关键字。</p>
<p>​    关于常量接口(类)我们开看一个例子，首先定义一个常量类：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Constant</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//定义人类寿命极限</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_AGE<span class="token operator">=</span><span class="token number">150</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这是一个非常简单的常量类，定义了人类的最大年龄，我们引用这个常量，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"人类的寿命极限是："</span><span class="token operator">+</span>Constant<span class="token punctuation">.</span>MAX_AGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    运行结果easy，故省略。目前的代码是写在”智能型”IDE工具中完成的，下面暂时回溯到原始时代，也就是回归到用记事本编写代码的年代，然后看看会发生什么事情（为什么要如此，下面会给出答案）</p>
<p>　　修改常量Constant类，人类的寿命极限增加了，最大活到180,代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Constant</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//定义人类寿命极限</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_AGE<span class="token operator">=</span><span class="token number">180</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    然后重新编译，javac Constant，编译完成后执行：java Client，大家猜猜输出的年龄是多少？</p>
<p>　　输出的结果是:”人类的寿命极限是150”，竟然没有改成180，太奇怪了，这是为何？</p>
<p>　　原因是：对于final修饰的基本类型和String类型，编译器会认为它是稳定态的(Immutable Status)所以在编译时就直接把值编译到字节码中了，避免了在运行期引用（Run-time Reference），以提高代码的执行效率。对于我们的例子来说，Client类在编译时字节码中就写上了”150”,这个常量，而不是一个地址引用，因此无论你后续怎么修改常量类，只要不重新编译Client类，输出还是照旧。</p>
<p>　　对于final修饰的类(即非基本类型)，编译器会认为它不是稳定态的（Mutable Status），编译时建立的则是引用关系（该类型也叫作Soft Final）。如果Client类引入的常量是一个类或实例，及时不重新编译也会输出最新值。</p>
<p>　　<strong>千万不可小看了这点知识，细坑也能绊倒大象，比如在一个web项目中，开发人员修改了一个final类型的值（基本类型）考虑到重新发布的风险较大，或者是审批流程过于繁琐，反正是为了偷懒，于是直接采用替换class类文件的方式发布，替换完毕后应用服务器自动重启，然后简单测试一下，一切Ok，可运行几天后发现业务数据对不上，有的类(引用关系的类)使用了旧值，有的类（继承关系的类）使用的是新值，而且毫无头绪，让人一筹莫展，其实问题的根源就在于此。</strong></p>
<p>　　还有个小问题没有说明，我们的例子为什么不在IDE工具(比如Eclipse)中运行呢？那是因为在IDE中设置了自动编译不能重现此问题，若修改了Constant类，IDE工具会自动编译所有的引用类,”智能”化屏蔽了该问题，但潜在的风险其实仍然存在，我记得Eclipse应该有个设置自动编译的入口，有兴趣大家可以自己尝试一下。</p>
<p><strong><font color="red">注意：发布应用系统时禁止使用类文件替换方式，整体WAR包发布才是万全之策。但我觉得应特殊情况特殊对待，</font></strong></p>
<p><strong><font color="red">并不可以偏概全，大家以为呢？</font></strong></p>
<h2><span id="第2章-基本类型">第2章 基本类型</span></h2><p>​    不积跬步，无以至千里；不积小流，无以成江海。——荀子《劝学篇》</p>
<p>​    Java中的基本数据类型（Primitive Data Types）有8个：byte、char、short、int、long、float、double、boolean，它们是Java最基本的单元，我们的每一段程序中都有它们的身影，但我们对如此熟悉的“伙伴”又了解多少呢？积少成多，积土成山，本章我们就来一探这最基本的8个数据类型。</p>
<h3><span id="建议21用偶判断不用奇判断">建议21：用偶判断，不用奇判断</span></h3><p>​    判断一个数是奇数还是偶数是小学里的基本知识，能够被2整除的整数是偶数，不能被2整除的数是奇数，这规则简单明了，还有什么可考虑的？好，我们来看一个例子，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client21</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 接收键盘输入参数</span>
        Scanner input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入多个数字判断奇偶："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">hasNextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            String str <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token string">"-->"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">"奇数"</span> <span class="token operator">:</span> <span class="token string">"偶数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>输入多个数字，然后判断每个数字的奇偶性，不能被2整除的就是奇数，其它的都是偶数，完全是根据奇偶数的定义编写的程序，我们开看看打印的结果：</p>
<p>　　输入多个数字判断奇偶：1 2 0 -1 -2   1–&gt;奇数  2–&gt;偶数  0–&gt;偶数   <strong>-1–&gt;偶数</strong>    -2–&gt;偶数</p>
<p>前三个还很靠谱，第四个参数-1怎么可能是偶数呢，这Java也太差劲了吧。如此简单的计算也会出错！别忙着下结论，我们先来了解一下Java中的取余(%标识符)算法，模拟代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 模拟取余计算，dividend被除数，divisor除数</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">remainder</span><span class="token punctuation">(</span><span class="token keyword">int</span> dividend<span class="token punctuation">,</span> <span class="token keyword">int</span> divisor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> dividend <span class="token operator">-</span> dividend <span class="token operator">/</span> divisor <span class="token operator">*</span> divisor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>看到这段程序，大家都会心的笑了，原来Java这么处理取余计算的呀，根据上面的模拟取余可知，当输入-1的时候，运算结果为-1，当然不等于1了，所以它就被判定为偶数了，也就是我们的判断失误了。问题明白了，修正也很简单，改为判断是否是偶数即可。代码如下：   i % 2 == 0 ? “偶数” : “奇数”;</p>
<p><strong><font color="red">注意：对于基础知识，我们应该”知其然，并知其所以然” </font></strong></p>
<h3><span id="建议22用整数类型处理货币">建议22：用整数类型处理货币</span></h3><p>在日常生活中，最容易接触到的小数就是货币，比如，你付给售货员10元钱购买一个9.6元的零食，售货员应该找你0.4元，也就是4毛钱才对，我们来看下面的程序：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client22</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">10.00</span><span class="token operator">-</span><span class="token number">9.60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>我们的期望结果是0.4，也应该是这个数字，但是打印出来的却是:0.40000000000000036,这是为什么呢？</p>
<p>　　这是因为在计算机中浮点数有可能（注意是有可能）是不准确的，它只能无限接近准确值，而不能完全精确。为什么会如此呢？这是由浮点数的存储规则所决定的，我们先来看看0.4这个十进制小数如何转换成二进制小数，使用”乘2取整，顺序排列”法（不懂，这就没招了，这太基础了），我们发现0.4不能使用二进制准确的表示，在二进制数世界里它是一个无限循环的小数，也就是说，”展示” 都不能 “展示”，更别说在内存中存储了(浮点数的存储包括三部分：符号位、指数位、尾数，具体不再介绍)，可以这样理解，在十进制的世界里没有办法唯一准确表示1/3，那么在二进制的世界里当然也无法准确表示1/5(如果二进制也有分数的话倒是可以表示)，在二进制的世界里1/5是一个无限循环的小数。</p>
<p>　　大家可能要说了，那我对结果取整不就对了吗？代码如下</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client22</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        NumberFormat f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecimalFormat</span><span class="token punctuation">(</span><span class="token string">"#.##"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token number">10.00</span><span class="token operator">-</span><span class="token number">9.60</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>打印出的结果是0.4，看似解决了。但是隐藏了一个很深的问题。我们来思考一下金融行业的计算方法，会计系统一般记录小数点后的4为小数，但是在汇总、展现、报表中、则只记录小数点后的2位小数，如果使用浮点数来计算货币，想想看，在大批量加减乘除后结果会有很大的差距(其中还涉及到四舍五入的问题)！会计系统要求的就是准确，但是因为计算机的缘故不准确了，那真是罪过，要解决此问题有两种方法：</p>
<p>(1)、使用BigDecimal</p>
<p>　　　　BigDecimal是专门为弥补浮点数无法精确计算的缺憾而设计的类，并且它本身也提供了加减乘除的常用数学算法。特别是与数据库Decimal类型的字段映射时，BigDecimal是最优的解决方案。</p>
<p>(2)、<strong>使用整型</strong></p>
<p>　　　　把参与运算的值扩大100倍，并转为整型，然后在展现时再缩小100倍，这样处理的好处是计算简单，准确，一般在非金融行业(如零售行业)应用较多。此方法还会用于某些零售POS机，他们输入和输出的全部是整数，那运算就更简单了.</p>
<h3><span id="建议23不要让类型默默转换">建议23：不要让类型默默转换</span></h3><p>​    我们做一个小学生的题目，光速每秒30万公里，根据光线的旅行时间，计算月球和地球，太阳和地球之间的距离。代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client23</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 光速是30万公里/秒，常量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> LIGHT_SPEED <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">*</span> <span class="token number">10000</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"题目1：月球照射到地球需要一秒，计算月亮和地球的距离。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> dis1 <span class="token operator">=</span> LIGHT_SPEED <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"月球与地球的距离是："</span> <span class="token operator">+</span> dis1 <span class="token operator">+</span> <span class="token string">" 米 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"题目2：太阳光照射到地球需要8分钟，计算太阳到地球的距离."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 可能要超出整数范围，使用long型</span>
        <span class="token keyword">long</span> dis2 <span class="token operator">=</span> LIGHT_SPEED <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"太阳与地球之间的距离是："</span> <span class="token operator">+</span> dis2 <span class="token operator">+</span> <span class="token string">" 米"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>估计有人鄙视了，这种小学生的乘法有神么可做的，不错，就是一个乘法运算，我们运行之后的结果如下：</p>
<p>　　　　<strong>题目1：月球照射到地球需要一秒，计算月亮和地球的距离。</strong><br>  　　 <strong>月球与地球的距离是：300000000 米</strong><br>   　 <strong>——————————-</strong><br>   　　<strong>题目2：太阳光照射到地球需要8分钟，计算太阳到地球的距离.</strong><br>   　　<strong>太阳与地球之间的距离是：-2028888064 米</strong></p>
<p>　　太阳和地球的距离竟然是负的，诡异。dis2不是已经考虑到int类型可能越界的问题，并使用了long型吗，怎么还会出现负值呢？</p>
<p>　　那是因为Java是先运算然后进行类型转换的，具体的说就是因为dis2的三个运算参数都是int型，三者相乘的结果虽然也是int型，但是已经超过了int的最大值，所以其值就是负值了(为什么是负值，因为过界了就会重头开始)，再转换为long型，结果还是负值。</p>
<p>　　问题知道了，解决起来也很简单，只要加个小小的L即可，代码如下：</p>
<p>　　long dis2 = LIGHT_SPEED * 60L * 8;</p>
<p>　　60L是一个长整型，乘出来的结果也是一个长整型的（此乃Java的基本转换规则，向数据范围大的方向转换，也就是加宽类型），在还没有超过int类型的范围时就已经转换为long型了，彻底解决了越界问题。在实际开发中，更通用的做法是主动声明类型转化(注意，不是强制类型转换)代码如下：</p>
<p>　　long dis2 = 1L * LIGHT_SPEED * 60L * 8</p>
<p>　　<strong>既然期望的结果是long型，那就让第一个参与的参数也是Long(1L)吧</strong>，也就说明”嗨”我已经是长整型了，你们都跟着我一块转为长整型吧。</p>
<p><strong><font color="red">注意：基本类型转换时，使用主动声明方式减少不必要的Bug. </font></strong></p>
<h3><span id="建议24边界还是边界">建议24：边界还是边界</span></h3><p>​    某商家生产的电子产品非常畅销，需要提前30天预订才能抢到手，同时还规定了一个会员可拥有的最多产品数量，目的是为了防止囤积压货肆意加价。会员的预订过程是这样的：先登录官方网站，选择产品型号，然后设置需要预订的数量，提交，符合规则即提示下单成功，不符合规则提示下单失败，后台的处理模拟如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client24</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 一个会员拥有产品的最多数量</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> LIMIT <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 会员当前用有的产品数量</span>
        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
        Scanner input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入需要预定的数量："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">hasNextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> order <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>order <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> order <span class="token operator">+</span> cur <span class="token operator">&lt;=</span> LIMIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你已经成功预定："</span> <span class="token operator">+</span> order <span class="token operator">+</span> <span class="token string">" 个产品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"超过限额，预定失败！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这是一个简单的订单处理程序，其中cur代表的是会员当前拥有的产品数量，LIMIT是一个会员最多拥有的产品数量（现实中，这两个参数当然是从数据库中获得的，不过这里是一个模拟程序），如果当前预订数量与拥有数量之和超过了最大数量，则预订失败，否则下单成功。业务逻辑很简单，同时在web界面上对订单数量做了严格的校验，比如不能是负值、不能超过最大数量等，但是人算不如天算，运行不到两小时数据库中就出现了异常数据：某会员拥有的产品数量与预定数量之和远远大于限额。怎么会这样呢？程序逻辑上不可能有问题呀，这如何产生的呢？我们来模拟一下，第一次输入：</p>
<p>　　请输入需要预定的数量：800   你已经成功预定800个产品</p>
<p>　　这完全满足条件，没有任何问题，继续输入：</p>
<p>　　请输入需要预定的数量：2147483647  你已经成功预定2147483647个产品</p>
<p>　　看到没有，这个数字已经远远超过了2000的限额，但是竟然预定成功了，真实神奇！<br>　　看着2147483647这个数字很眼熟？那就对了，这个数字就是int类型的最大值，没错，有人输入了一个最大值，使校验条件失败了，Why？我们来看程序，order的值是2147483647那再加上1000就超出int的范围了，其结果是-2147482649，那当然是小于正数2000了！一句归其原因：数字越界使校验条件失效。</p>
<p>　　<strong>在单元测试中，有一项测试叫做边界测试(也叫临界测试)，如果一个方法接收的是int类型的参数，那么以下三个值是必须测试的:0、正最大、负最小，其中正最大、负最小是边界值，如果这三个值都没有问题，方法才是比较安全可靠的。我们的例子就是因为缺少边界测试，致使生产系统产生了严重的偏差。</strong></p>
<p>　　也许你要疑惑了，Web界面已经做了严格的校验，为什么还能输入2147483647 这么大的数字呢？是否说明Web校验不严格?错了，不是这样的，Web校验都是在页面上通过JavaScript实现的，只能限制普通用户(这里的普通用户是指不懂html，不懂HTTP，不懂Java的简单使用者)，而对于高手，这些校验基本上就是摆设，HTTP是明文传输的，将其拦截几次，分析一下数据结构，然后写一个模拟器，一切前端校验就成了浮云！想往后台提交个什么数据还不是信手拈来！</p>
<h3><span id="建议25不要让四舍五入亏了一方">建议25：不要让四舍五入亏了一方</span></h3><p>​    本建议还是来重温一个小学数学问题：四舍五入。四舍五入是一种近似精确的计算方法，在Java5之前，我们一般是通过Math.round来获得指定精度的整数或小数的，这种方法使用非常广泛，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client25</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10.5近似值: "</span><span class="token operator">+</span>Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">10.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-10.5近似值: "</span><span class="token operator">+</span>Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>输出结果为：10.5近似值: 11    -10.5近似值: -10<br>　　这是四舍五入的经典案例，也是初级面试官很乐意选择的考题，绝对值相同的两个数字，近似值为什么就不同了呢？这是由Math.round采用的舍入规则决定的(采用的是正无穷方向舍入规则)，我们知道四舍五入是有误差的：其误差值是舍入的一半。我们以舍入运用最频繁的银行利息计算为例来阐述此问题。</p>
<p>　　我们知道银行的盈利渠道主要是利息差，从储户手里收拢资金，然后房贷出去，期间的利息差额便是所获得利润，对一个银行来说，对付给储户的利息计算非常频繁，人民银行规定每个季度末月的20日为银行结息日，一年有4次的结息日。</p>
<p>　　场景介绍完毕，我们回头来看看四舍五入，小于5的数字被舍去，大于5的数字进位后舍去，由于单位上的数字都是自然计算出来的，按照利率计算可知，被舍去的数字都分布在0~9之间，下面以10笔存款利息计算作为模型，以银行家的身份来思考这个算法：</p>
<p>　　四舍：舍弃的数值是：0.000、0.001、0.002、0.003、0.004因为是舍弃的，对于银行家来说就不需要付款给储户了，那每舍一个数字就会赚取相应的金额：0.000、0.001、0.002、0.003、0.004.</p>
<p>　　五入：进位的数值是：0.005、0.006、0.007、0.008、0.009，因为是进位，对银行家来说，每进一位就会多付款给储户，也就是亏损了，那亏损部分就是其对应的10进制补数：0.005、.0004、0.003、0.002、0.001.</p>
<p>　　因为舍弃和进位的数字是均匀分布在0~9之间，对于银行家来说，没10笔存款的利息因采用四舍五入而获得的盈利是：</p>
<p>　　0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = - 0.005；</p>
<p>　　也就是说，每10笔利息计算中就损失0.005元，即每笔利息计算就损失0.0005元，这对一家有5千万储户的银行家来说(对国内银行来说，5千万是个小数字)，每年仅仅因为四舍五入的误差而损失的金额是：</p>
<p>　　银行账户数量（5千万）<em>4（一年计算四次利息）</em>0.0005（每笔利息损失的金额）</p>
<p>　　5000<em>10000</em>0.0005*4=100000.0；即，每年因为一个算法误差就损失了10万元，事实上以上的假设条件都是非常保守的，实际情况可能损失的更多。那各位可能要说了，银行还要放贷呀，放出去这笔计算误差不就抵消了吗？不会抵消，银行的贷款数量是非常有限的其数量级根本无法和存款相比。</p>
<p>　　这个算法误差是由美国银行家发现的(那可是私人银行，钱是自己的，白白损失了可不行)，并且对此提出了一个修正算法，叫做银行家舍入(Banker’s Round)的近似算法，其规则如下：</p>
<ol>
<li>舍去位的数值小于5时，直接舍去；</li>
<li>舍去位的数值大于等于6时，进位后舍去；</li>
<li>当舍去位的数值等于5时，分两种情况：5后面还有其它数字(非0)，则进位后舍去；若5后面是0(即5是最后一个数字)，则根据5前一位数的奇偶性来判断是否需要进位，奇数进位，偶数舍去。</li>
</ol>
<p>　　以上规则汇总成一句话：<strong>四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一</strong>。我们举例说明，取2位精度；</p>
<p>　　round(10.5551) = 10.56  round(10.555) = 10.56  round(10.545) = 10.54 </p>
<p>　　要在Java5以上的版本中使用银行家的舍入法则非常简单，直接使用RoundingMode类提供的Round模式即可，示例代码如下：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>math<span class="token punctuation">.</span>BigDecimal<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>math<span class="token punctuation">.</span>RoundingMode<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client25</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 存款</span>
        BigDecimal d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">888888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 月利率，乘3计算季利率</span>
        BigDecimal r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">0.001875</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//计算利息</span>
        BigDecimal i <span class="token operator">=</span>d<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setScale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>RoundingMode<span class="token punctuation">.</span>HALF_EVEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"季利息是："</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在上面的例子中，我们使用了BigDecimal类，并且采用了setScale方法设置了精度，同时传递了一个RoundingMode.HALF_EVEN参数表示使用银行家法则进行近似计算，BigDecimal和RoundingMode是一个绝配，想要采用什么方式使用RoundingMode设置即可。目前Java支持以下七种舍入方式：</p>
<ol>
<li>ROUND_UP：原理零方向舍入。向远离0的方向舍入，也就是说，向绝对值最大的方向舍入，只要舍弃位非0即进位。</li>
<li>ROUND_DOWN：趋向0方向舍入。向0方向靠拢，也就是说，向绝对值最小的方向输入，注意：所有的位都舍弃，不存在进位情况。</li>
<li>ROUND_CEILING：向正无穷方向舍入。向正最大方向靠拢，如果是正数，舍入行为类似于ROUND_UP；如果为负数，则舍入行为类似于ROUND_DOWN.注意：Math.round方法使用的即为此模式。</li>
<li>ROUND_FLOOR：向负无穷方向舍入。向负无穷方向靠拢，如果是正数，则舍入行为类似ROUND_DOWN，如果是负数，舍入行为类似以ROUND_UP。</li>
<li>HALF_UP：最近数字舍入(5舍)，这就是我们经典的四舍五入。</li>
<li>HALF_DOWN：最近数字舍入(5舍)。在四舍五入中，5是进位的，在HALF_DOWN中却是舍弃不进位。</li>
<li><strong>HALF_EVEN：银行家算法</strong></li>
</ol>
<p>　　在普通的项目中舍入模式不会有太多影响，可以直接使用Math.round方法，但在大量与货币数字交互的项目中，一定要选择好近似的计算模式，尽量减少因算法不同而造成的损失。</p>
<p>==<strong>注意：根据不同的场景，慎重选择不同的舍入模式，以提高项目的精准度，减少算法损失。</strong>==</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>math<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/**
 * Specifies a &lt;i>rounding behavior&lt;/i> for numerical operations
 * capable of discarding precision. Each rounding mode indicates how
 * the least significant returned digit of a rounded result is to be
 * calculated.  If fewer digits are returned than the digits needed to
 * represent the exact numerical result, the discarded digits will be
 * referred to as the &lt;i>discarded fraction&lt;/i> regardless the digits'
 * contribution to the value of the number.  In other words,
 * considered as a numerical value, the discarded fraction could have
 * an absolute value greater than one.
 *
 * &lt;p>Each rounding mode description includes a table listing how
 * different two-digit decimal values would round to a one digit
 * decimal value under the rounding mode in question.  The result
 * column in the tables could be gotten by creating a
 * {@code BigDecimal} number with the specified value, forming a
 * {@link MathContext} object with the proper settings
 * ({@code precision} set to {@code 1}, and the
 * {@code roundingMode} set to the rounding mode in question), and
 * calling {@link BigDecimal#round round} on this number with the
 * proper {@code MathContext}.  A summary table showing the results
 * of these rounding operations for all rounding modes appears below.
 *
 *&lt;p>
 *&lt;table border>
 * &lt;caption>&lt;b>Summary of Rounding Operations Under Different Rounding Modes&lt;/b>&lt;/caption>
 * &lt;tr>&lt;th>&lt;/th>&lt;th colspan=8>Result of rounding input to one digit with the given
 *                           rounding mode&lt;/th>
 * &lt;tr valign=top>
 * &lt;th>Input Number&lt;/th>         &lt;th>{@code UP}&lt;/th>
 *                                           &lt;th>{@code DOWN}&lt;/th>
 *                                                        &lt;th>{@code CEILING}&lt;/th>
 *                                                                       &lt;th>{@code FLOOR}&lt;/th>
 *                                                                                    &lt;th>{@code HALF_UP}&lt;/th>
 *                                                                                                   &lt;th>{@code HALF_DOWN}&lt;/th>
 *                                                                                                                    &lt;th>{@code HALF_EVEN}&lt;/th>
 *                                                                                                                                     &lt;th>{@code UNNECESSARY}&lt;/th>
 *
 * &lt;tr align=right>&lt;td>5.5&lt;/td>  &lt;td>6&lt;/td>  &lt;td>5&lt;/td>    &lt;td>6&lt;/td>    &lt;td>5&lt;/td>  &lt;td>6&lt;/td>      &lt;td>5&lt;/td>       &lt;td>6&lt;/td>       &lt;td>throw {@code ArithmeticException}&lt;/td>
 * &lt;tr align=right>&lt;td>2.5&lt;/td>  &lt;td>3&lt;/td>  &lt;td>2&lt;/td>    &lt;td>3&lt;/td>    &lt;td>2&lt;/td>  &lt;td>3&lt;/td>      &lt;td>2&lt;/td>       &lt;td>2&lt;/td>       &lt;td>throw {@code ArithmeticException}&lt;/td>
 * &lt;tr align=right>&lt;td>1.6&lt;/td>  &lt;td>2&lt;/td>  &lt;td>1&lt;/td>    &lt;td>2&lt;/td>    &lt;td>1&lt;/td>  &lt;td>2&lt;/td>      &lt;td>2&lt;/td>       &lt;td>2&lt;/td>       &lt;td>throw {@code ArithmeticException}&lt;/td>
 * &lt;tr align=right>&lt;td>1.1&lt;/td>  &lt;td>2&lt;/td>  &lt;td>1&lt;/td>    &lt;td>2&lt;/td>    &lt;td>1&lt;/td>  &lt;td>1&lt;/td>      &lt;td>1&lt;/td>       &lt;td>1&lt;/td>       &lt;td>throw {@code ArithmeticException}&lt;/td>
 * &lt;tr align=right>&lt;td>1.0&lt;/td>  &lt;td>1&lt;/td>  &lt;td>1&lt;/td>    &lt;td>1&lt;/td>    &lt;td>1&lt;/td>  &lt;td>1&lt;/td>      &lt;td>1&lt;/td>       &lt;td>1&lt;/td>       &lt;td>1&lt;/td>
 * &lt;tr align=right>&lt;td>-1.0&lt;/td> &lt;td>-1&lt;/td> &lt;td>-1&lt;/td>   &lt;td>-1&lt;/td>   &lt;td>-1&lt;/td> &lt;td>-1&lt;/td>     &lt;td>-1&lt;/td>      &lt;td>-1&lt;/td>      &lt;td>-1&lt;/td>
 * &lt;tr align=right>&lt;td>-1.1&lt;/td> &lt;td>-2&lt;/td> &lt;td>-1&lt;/td>   &lt;td>-1&lt;/td>   &lt;td>-2&lt;/td> &lt;td>-1&lt;/td>     &lt;td>-1&lt;/td>      &lt;td>-1&lt;/td>      &lt;td>throw {@code ArithmeticException}&lt;/td>
 * &lt;tr align=right>&lt;td>-1.6&lt;/td> &lt;td>-2&lt;/td> &lt;td>-1&lt;/td>   &lt;td>-1&lt;/td>   &lt;td>-2&lt;/td> &lt;td>-2&lt;/td>     &lt;td>-2&lt;/td>      &lt;td>-2&lt;/td>      &lt;td>throw {@code ArithmeticException}&lt;/td>
 * &lt;tr align=right>&lt;td>-2.5&lt;/td> &lt;td>-3&lt;/td> &lt;td>-2&lt;/td>   &lt;td>-2&lt;/td>   &lt;td>-3&lt;/td> &lt;td>-3&lt;/td>     &lt;td>-2&lt;/td>      &lt;td>-2&lt;/td>      &lt;td>throw {@code ArithmeticException}&lt;/td>
 * &lt;tr align=right>&lt;td>-5.5&lt;/td> &lt;td>-6&lt;/td> &lt;td>-5&lt;/td>   &lt;td>-5&lt;/td>   &lt;td>-6&lt;/td> &lt;td>-6&lt;/td>     &lt;td>-5&lt;/td>      &lt;td>-6&lt;/td>      &lt;td>throw {@code ArithmeticException}&lt;/td>
 *&lt;/table>
 *
 *
 * &lt;p>This {@code enum} is intended to replace the integer-based
 * enumeration of rounding mode constants in {@link BigDecimal}
 * ({@link BigDecimal#ROUND_UP}, {@link BigDecimal#ROUND_DOWN},
 * etc. ).
 *
 * @see     BigDecimal
 * @see     MathContext
 * @author  Josh Bloch
 * @author  Mike Cowlishaw
 * @author  Joseph D. Darcy
 * @since 1.5
 */</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> RoundingMode <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">/**
         * Rounding mode to round away from zero.  Always increments the
         * digit prior to a non-zero discarded fraction.  Note that this
         * rounding mode never decreases the magnitude of the calculated
         * value.
         *
         *&lt;p>Example:
         *&lt;table border>
         *&lt;tr valign=top>&lt;th>Input Number&lt;/th>
         *    &lt;th>Input rounded to one digit&lt;br> with {@code UP} rounding
         *&lt;tr align=right>&lt;td>5.5&lt;/td>  &lt;td>6&lt;/td>
         *&lt;tr align=right>&lt;td>2.5&lt;/td>  &lt;td>3&lt;/td>
         *&lt;tr align=right>&lt;td>1.6&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.1&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.0&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.0&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.1&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-1.6&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-2.5&lt;/td> &lt;td>-3&lt;/td>
         *&lt;tr align=right>&lt;td>-5.5&lt;/td> &lt;td>-6&lt;/td>
         *&lt;/table>
         */</span>
    <span class="token function">UP</span><span class="token punctuation">(</span>BigDecimal<span class="token punctuation">.</span>ROUND_UP<span class="token punctuation">)</span><span class="token punctuation">,</span>

        <span class="token comment" spellcheck="true">/**
         * Rounding mode to round towards zero.  Never increments the digit
         * prior to a discarded fraction (i.e., truncates).  Note that this
         * rounding mode never increases the magnitude of the calculated value.
         *
         *&lt;p>Example:
         *&lt;table border>
         *&lt;tr valign=top>&lt;th>Input Number&lt;/th>
         *    &lt;th>Input rounded to one digit&lt;br> with {@code DOWN} rounding
         *&lt;tr align=right>&lt;td>5.5&lt;/td>  &lt;td>5&lt;/td>
         *&lt;tr align=right>&lt;td>2.5&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.6&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>1.1&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>1.0&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.0&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.1&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.6&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-2.5&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-5.5&lt;/td> &lt;td>-5&lt;/td>
         *&lt;/table>
         */</span>
    <span class="token function">DOWN</span><span class="token punctuation">(</span>BigDecimal<span class="token punctuation">.</span>ROUND_DOWN<span class="token punctuation">)</span><span class="token punctuation">,</span>

        <span class="token comment" spellcheck="true">/**
         * Rounding mode to round towards positive infinity.  If the
         * result is positive, behaves as for {@code RoundingMode.UP};
         * if negative, behaves as for {@code RoundingMode.DOWN}.  Note
         * that this rounding mode never decreases the calculated value.
         *
         *&lt;p>Example:
         *&lt;table border>
         *&lt;tr valign=top>&lt;th>Input Number&lt;/th>
         *    &lt;th>Input rounded to one digit&lt;br> with {@code CEILING} rounding
         *&lt;tr align=right>&lt;td>5.5&lt;/td>  &lt;td>6&lt;/td>
         *&lt;tr align=right>&lt;td>2.5&lt;/td>  &lt;td>3&lt;/td>
         *&lt;tr align=right>&lt;td>1.6&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.1&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.0&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.0&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.1&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.6&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-2.5&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-5.5&lt;/td> &lt;td>-5&lt;/td>
         *&lt;/table>
         */</span>
    <span class="token function">CEILING</span><span class="token punctuation">(</span>BigDecimal<span class="token punctuation">.</span>ROUND_CEILING<span class="token punctuation">)</span><span class="token punctuation">,</span>

        <span class="token comment" spellcheck="true">/**
         * Rounding mode to round towards negative infinity.  If the
         * result is positive, behave as for {@code RoundingMode.DOWN};
         * if negative, behave as for {@code RoundingMode.UP}.  Note that
         * this rounding mode never increases the calculated value.
         *
         *&lt;p>Example:
         *&lt;table border>
         *&lt;tr valign=top>&lt;th>Input Number&lt;/th>
         *    &lt;th>Input rounded to one digit&lt;br> with {@code FLOOR} rounding
         *&lt;tr align=right>&lt;td>5.5&lt;/td>  &lt;td>5&lt;/td>
         *&lt;tr align=right>&lt;td>2.5&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.6&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>1.1&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>1.0&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.0&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.1&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-1.6&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-2.5&lt;/td> &lt;td>-3&lt;/td>
         *&lt;tr align=right>&lt;td>-5.5&lt;/td> &lt;td>-6&lt;/td>
         *&lt;/table>
         */</span>
    <span class="token function">FLOOR</span><span class="token punctuation">(</span>BigDecimal<span class="token punctuation">.</span>ROUND_FLOOR<span class="token punctuation">)</span><span class="token punctuation">,</span>

        <span class="token comment" spellcheck="true">/**
         * Rounding mode to round towards {@literal "nearest neighbor"}
         * unless both neighbors are equidistant, in which case round up.
         * Behaves as for {@code RoundingMode.UP} if the discarded
         * fraction is ≥ 0.5; otherwise, behaves as for
         * {@code RoundingMode.DOWN}.  Note that this is the rounding
         * mode commonly taught at school.
         *
         *&lt;p>Example:
         *&lt;table border>
         *&lt;tr valign=top>&lt;th>Input Number&lt;/th>
         *    &lt;th>Input rounded to one digit&lt;br> with {@code HALF_UP} rounding
         *&lt;tr align=right>&lt;td>5.5&lt;/td>  &lt;td>6&lt;/td>
         *&lt;tr align=right>&lt;td>2.5&lt;/td>  &lt;td>3&lt;/td>
         *&lt;tr align=right>&lt;td>1.6&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.1&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>1.0&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.0&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.1&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.6&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-2.5&lt;/td> &lt;td>-3&lt;/td>
         *&lt;tr align=right>&lt;td>-5.5&lt;/td> &lt;td>-6&lt;/td>
         *&lt;/table>
         */</span>
    <span class="token function">HALF_UP</span><span class="token punctuation">(</span>BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">,</span>

        <span class="token comment" spellcheck="true">/**
         * Rounding mode to round towards {@literal "nearest neighbor"}
         * unless both neighbors are equidistant, in which case round
         * down.  Behaves as for {@code RoundingMode.UP} if the discarded
         * fraction is > 0.5; otherwise, behaves as for
         * {@code RoundingMode.DOWN}.
         *
         *&lt;p>Example:
         *&lt;table border>
         *&lt;tr valign=top>&lt;th>Input Number&lt;/th>
         *    &lt;th>Input rounded to one digit&lt;br> with {@code HALF_DOWN} rounding
         *&lt;tr align=right>&lt;td>5.5&lt;/td>  &lt;td>5&lt;/td>
         *&lt;tr align=right>&lt;td>2.5&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.6&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.1&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>1.0&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.0&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.1&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.6&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-2.5&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-5.5&lt;/td> &lt;td>-5&lt;/td>
         *&lt;/table>
         */</span>
    <span class="token function">HALF_DOWN</span><span class="token punctuation">(</span>BigDecimal<span class="token punctuation">.</span>ROUND_HALF_DOWN<span class="token punctuation">)</span><span class="token punctuation">,</span>

        <span class="token comment" spellcheck="true">/**
         * Rounding mode to round towards the {@literal "nearest neighbor"}
         * unless both neighbors are equidistant, in which case, round
         * towards the even neighbor.  Behaves as for
         * {@code RoundingMode.HALF_UP} if the digit to the left of the
         * discarded fraction is odd; behaves as for
         * {@code RoundingMode.HALF_DOWN} if it's even.  Note that this
         * is the rounding mode that statistically minimizes cumulative
         * error when applied repeatedly over a sequence of calculations.
         * It is sometimes known as {@literal "Banker's rounding,"} and is
         * chiefly used in the USA.  This rounding mode is analogous to
         * the rounding policy used for {@code float} and {@code double}
         * arithmetic in Java.
         *
         *&lt;p>Example:
         *&lt;table border>
         *&lt;tr valign=top>&lt;th>Input Number&lt;/th>
         *    &lt;th>Input rounded to one digit&lt;br> with {@code HALF_EVEN} rounding
         *&lt;tr align=right>&lt;td>5.5&lt;/td>  &lt;td>6&lt;/td>
         *&lt;tr align=right>&lt;td>2.5&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.6&lt;/td>  &lt;td>2&lt;/td>
         *&lt;tr align=right>&lt;td>1.1&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>1.0&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.0&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.1&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.6&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-2.5&lt;/td> &lt;td>-2&lt;/td>
         *&lt;tr align=right>&lt;td>-5.5&lt;/td> &lt;td>-6&lt;/td>
         *&lt;/table>
         */</span>
    <span class="token function">HALF_EVEN</span><span class="token punctuation">(</span>BigDecimal<span class="token punctuation">.</span>ROUND_HALF_EVEN<span class="token punctuation">)</span><span class="token punctuation">,</span>

        <span class="token comment" spellcheck="true">/**
         * Rounding mode to assert that the requested operation has an exact
         * result, hence no rounding is necessary.  If this rounding mode is
         * specified on an operation that yields an inexact result, an
         * {@code ArithmeticException} is thrown.
         *&lt;p>Example:
         *&lt;table border>
         *&lt;tr valign=top>&lt;th>Input Number&lt;/th>
         *    &lt;th>Input rounded to one digit&lt;br> with {@code UNNECESSARY} rounding
         *&lt;tr align=right>&lt;td>5.5&lt;/td>  &lt;td>throw {@code ArithmeticException}&lt;/td>
         *&lt;tr align=right>&lt;td>2.5&lt;/td>  &lt;td>throw {@code ArithmeticException}&lt;/td>
         *&lt;tr align=right>&lt;td>1.6&lt;/td>  &lt;td>throw {@code ArithmeticException}&lt;/td>
         *&lt;tr align=right>&lt;td>1.1&lt;/td>  &lt;td>throw {@code ArithmeticException}&lt;/td>
         *&lt;tr align=right>&lt;td>1.0&lt;/td>  &lt;td>1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.0&lt;/td> &lt;td>-1&lt;/td>
         *&lt;tr align=right>&lt;td>-1.1&lt;/td> &lt;td>throw {@code ArithmeticException}&lt;/td>
         *&lt;tr align=right>&lt;td>-1.6&lt;/td> &lt;td>throw {@code ArithmeticException}&lt;/td>
         *&lt;tr align=right>&lt;td>-2.5&lt;/td> &lt;td>throw {@code ArithmeticException}&lt;/td>
         *&lt;tr align=right>&lt;td>-5.5&lt;/td> &lt;td>throw {@code ArithmeticException}&lt;/td>
         *&lt;/table>
         */</span>
    <span class="token function">UNNECESSARY</span><span class="token punctuation">(</span>BigDecimal<span class="token punctuation">.</span>ROUND_UNNECESSARY<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Corresponding BigDecimal rounding constant</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> oldMode<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * Constructor
     *
     * @param oldMode The {@code BigDecimal} constant corresponding to
     *        this mode
     */</span>
    <span class="token keyword">private</span> <span class="token function">RoundingMode</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>oldMode <span class="token operator">=</span> oldMode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * Returns the {@code RoundingMode} object corresponding to a
     * legacy integer rounding mode constant in {@link BigDecimal}.
     *
     * @param  rm legacy integer rounding mode to convert
     * @return {@code RoundingMode} corresponding to the given integer.
     * @throws IllegalArgumentException integer is out of range
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> RoundingMode <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span><span class="token punctuation">(</span>rm<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">case</span> BigDecimal<span class="token punctuation">.</span>ROUND_UP<span class="token operator">:</span>
            <span class="token keyword">return</span> UP<span class="token punctuation">;</span>

        <span class="token keyword">case</span> BigDecimal<span class="token punctuation">.</span>ROUND_DOWN<span class="token operator">:</span>
            <span class="token keyword">return</span> DOWN<span class="token punctuation">;</span>

        <span class="token keyword">case</span> BigDecimal<span class="token punctuation">.</span>ROUND_CEILING<span class="token operator">:</span>
            <span class="token keyword">return</span> CEILING<span class="token punctuation">;</span>

        <span class="token keyword">case</span> BigDecimal<span class="token punctuation">.</span>ROUND_FLOOR<span class="token operator">:</span>
            <span class="token keyword">return</span> FLOOR<span class="token punctuation">;</span>

        <span class="token keyword">case</span> BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token operator">:</span>
            <span class="token keyword">return</span> HALF_UP<span class="token punctuation">;</span>

        <span class="token keyword">case</span> BigDecimal<span class="token punctuation">.</span>ROUND_HALF_DOWN<span class="token operator">:</span>
            <span class="token keyword">return</span> HALF_DOWN<span class="token punctuation">;</span>

        <span class="token keyword">case</span> BigDecimal<span class="token punctuation">.</span>ROUND_HALF_EVEN<span class="token operator">:</span>
            <span class="token keyword">return</span> HALF_EVEN<span class="token punctuation">;</span>

        <span class="token keyword">case</span> BigDecimal<span class="token punctuation">.</span>ROUND_UNNECESSARY<span class="token operator">:</span>
            <span class="token keyword">return</span> UNNECESSARY<span class="token punctuation">;</span>

        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"argument out of range"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><span id="建议26提防包装类型的null值">建议26：提防包装类型的null值</span></h3><p>​    我们知道Java引入包装类型(Wrapper Types)是为了解决基本类型的实例化问题，以便让一个基本类型也能参与到面向对象的编程世界中。而在Java5中泛型更是对基本类型说了”不”，如果把一个整型放入List中，就必须使用Integer包装类型。我们看一段代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client26</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">testMethod</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count <span class="token operator">+=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">testMethod</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　testMethod接收一个元素是整型的List参数，计算所有元素之和，这在统计和项目中很常见，然后编写一个测试testMethod，在main方法中把1、2和空值都放到List中，然后调用方法计算，现在思考一下会不会报错。应该不会吧，基本类型和包装类型都是可以通过自动装箱（Autoboxing）和自动拆箱(AutoUnboxing)自由转换的，null应该可以转换为0吧，真的是这样吗？运行之后的结果是：　　Exception in thread “main” java.lang.NullPointerException　　运行失败，报空指针异常，我们稍稍思考一下很快就知道原因了：在程序for循环中，隐含了一个拆箱过程，在此过程中包装类型转换为了基本类型。我们知道拆箱过程是通过调用包装对象的intValue方法来实现的，由于包装类型为null，访问其intValue方法报空指针异常就在所难免了。问题清楚了，修改也很简单，加入null值检查即可，代码如下：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">testMethod</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer i <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count <span class="token operator">+=</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    上面以Integer和int为例说明了拆箱问题，其它7个包装对象的拆箱过程也存在着同样的问题。包装对象和拆箱对象可以自由转换，这不假，但是要剔除null值，null值并不能转换为基本类型。对于此问题，我们谨记一点：<font color="red">包装类型参与运算时，要做null值校验。</font></p>
<h3><span id="建议27谨慎包装类型的大小比较">建议27：谨慎包装类型的大小比较</span></h3><p>​    基本类型是可以比较大小的，其所对应的包装类型都实现了Comparable接口，也说明了此问题，那我们来比较一下两个包装类型的大小，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client27</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Integer i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Integer j <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">compare</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer i<span class="token punctuation">,</span> Integer j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">></span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>代码很简单，产生了两个Integer对象，然后比较两个的大小关系，既然包装类型和基本类型是可以自由转换的，那上面的代码是不是就可以打印出两个相等的值呢？让事实说话，运行结果如下：</p>
<p>　　false false false</p>
<p>　　竟然是3个false，也就是说两个值之间不相等，也没大小关系，这个也太奇怪了吧。不奇怪，我们来一 一解释：</p>
<ol>
<li>i= =j：在java中”= =”是用来判断两个操作数是否有相等关系的，如果是基本类型则判断值是否相等，如果是对象则判断是否是一个对象的两个引用，也就是地址是否相等，这里很明显是两个对象，两个地址不可能相等。</li>
<li>i&gt;j 和 i&lt;j：在Java中，”&gt;” 和 “&lt;” 用来判断两个数字类型的大小关系，注意只能是数字类型的判断，对于Integer包装类型，是根据其intValue()方法的返回值(也就是其相应的基本类型)进行比较的(其它包装类型是根据相应的value值比较的，如doubleValue,floatValue等)，那很显然，两者不肯能有大小关系的。</li>
</ol>
<p>问题清楚了，修改总是比较容易的，直接使用Integer的实例compareTo方法即可，但是这类问题的产生更应该说是习惯问题，只要是两个对象之间的比较就应该采用相应的方法，而不是通过Java的默认机制来处理，除非你确定对此非常了解。</p>
<h3><span id="建议28优先使用整型池">建议28：优先使用整型池</span></h3><p>上一个建议我们解释了包装对象的比较问题，本建议将继续深入讨论相关问题，首先看看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client28</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Scanner input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">hasNextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> tempInt <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n====="</span> <span class="token operator">+</span> tempInt <span class="token operator">+</span> <span class="token string">" 的相等判断====="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 两个通过new产生的对象</span>
            Integer i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>tempInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Integer j <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>tempInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" new 产生的对象："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 基本类型转换为包装类型后比较</span>
            i <span class="token operator">=</span> tempInt<span class="token punctuation">;</span>
            j <span class="token operator">=</span> tempInt<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 基本类型转换的对象："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 通过静态方法生成一个实例</span>
            i <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tempInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            j <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tempInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" valueOf产生的对象："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>输入多个数字，然后按照3中不同的方式产生Integer对象，判断其是否相等，注意这里使用了”==”，这说明判断的不是同一个对象。我们输入三个数字127、128、555，结果如下：</p>
<p>　　<strong>127</strong><br><strong>= = = = =127 的相等判断 = = == =</strong><br> <strong>new 产生的对象：false</strong><br> <strong>基本类型转换的对象：true</strong><br> <strong>valueOf产生的对象：true</strong><br><strong>128</strong><br><strong>= = = = =128 的相等判断= = = = =</strong><br> <strong>new 产生的对象：false</strong><br> <strong>基本类型转换的对象：false</strong><br> <strong>valueOf产生的对象：false</strong><br><strong>555</strong><br><strong>= = = = =555 的相等判断= = = = =</strong><br> <strong>new 产生的对象：false</strong><br> <strong>基本类型转换的对象：false</strong><br> <strong>valueOf产生的对象：false</strong></p>
<p>很不可思议呀，数字127的比较结果竟然和其它两个数字不同，它的装箱动作所产生的对象竟然是同一个对象，valueOf产生的也是同一个对象，但是大于127的数字和128和555的比较过程中产生的却不是同一个对象，这是为什么？我们来一个一个解释。</p>
<p>(1)、new产生的Integer对象</p>
<p>　　　　new声明的就是要生成一个新的对象，没二话，这是两个对象，地址肯定不等，比较结果为false。</p>
<p>(2)、装箱生成的对象</p>
<p>　　对于这一点，首先要说明的是装箱动作是通过valueOf方法实现的，也就是说后两个算法相同的，那结果肯定也是一样的，现在问题是：valueOf是如何生成对象的呢？我们来阅读以下Integer.valueOf的源码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
     * Returns an {@code Integer} instance representing the specified
     * {@code int} value.  If a new {@code Integer} instance is not
     * required, this method should generally be used in preference to
     * the constructor {@link #Integer(int)}, as this method is likely
     * to yield significantly better space and time performance by
     * caching frequently requested values.
     *
     * This method will always cache values in the range -128 to 127,
     * inclusive, and may cache other values outside of this range.
     *
     * @param  i an {@code int} value.
     * @return an {@code Integer} instance representing {@code i}.
     * @since  1.5
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">assert</span> IntegerCache<span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>
            <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>​    这段代码的意思已经很明了了，如果是-128到127之间的int类型转换为Integer对象，则直接从cache数组中获得，那cache数组里是什么东西，JDK7的源代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
     * Cache to support the object identity semantics of autoboxing for values between
     * -128 and 127 (inclusive) as required by JLS.
     *
     * The cache is initialized on first usage.  The size of the cache
     * may be controlled by the -XX:AutoBoxCacheMax=&lt;size> option.
     * During VM initialization, java.lang.Integer.IntegerCache.high property
     * may be set and saved in the private system properties in the
     * sun.misc.VM class.
     */</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">static</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// high value may be configured by property</span>
            <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
            String integerCacheHighPropValue <span class="token operator">=</span>
                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
                i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>
                h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            high <span class="token operator">=</span> h<span class="token punctuation">;</span>

            cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
                cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">private</span> <span class="token function">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>​    cache是IntegerCache内部类的一个静态数组，容纳的是-128到127之间的Integer对象。通过valueOf产生包装对象时，如果int参数在-128到127之间，则直接从整型池中获得对象，不在该范围内的int类型则通过new生成包装对象。</p>
<p>　　明白了这一点，要理解上面的输出结果就迎刃而解了，127的包装对象是直接从整型池中获得的，不管你输入多少次127这个数字，获得的对象都是同一个，那地址自然是相等的。而128、555超出了整型池范围，是通过new产生一个新的对象，地址不同，当然也就不相等了。</p>
<p>　　以上的理解也是整型池的原理，整型池的存在不仅仅提高了系统性能，同时也节约了内存空间，这也是我们使用整型池的原因，也就是在声明包装对象的时候使用valueOf生成，而不是通过构造函数来生成的原因。顺便提醒大家，在判断对象是否相等的时候，最好使用equals方法，避免使用”==”产生非预期效果。</p>
<p><strong><font color="red">注意：通过包装类型的valueOf生成的包装实例可以显著提高空间和时间性能。</font></strong></p>
<h3><span id="建议29优先选择基本类型">建议29：优先选择基本类型</span></h3><p>​    包装类型是一个类，它提供了诸如构造方法，类型转换，比较等非常实用的功能，而且在Java5之后又实现了与基本类型的转换，这使包装类型如虎添翼，更是应用广泛了，在开发中包装类型已经随处可见，但无论是从安全性、性能方面来说，还是从稳定性方面来说，基本类型都是首选方案。我们看一段代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client29</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Client29 c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Client29</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">140</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 分别传递int类型和Integer类型</span>
        c<span class="token punctuation">.</span><span class="token function">testMethod</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token punctuation">.</span><span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token keyword">long</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 基本类型的方法被调用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span>Long a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 包装类型的方法被调用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在上面的程序中首先声明了一个int变量i，然后加宽转变成long型，再调用testMethod()方法,分别传递int和long的基本类型和包装类型，诸位想想该程序是否能够编译？如果能编译，输出结果又是什么呢？</p>
<p>　　首先，这段程序绝对是能够编译的。不过，说不能编译的同学还是动了一番脑筋的，你可能猜测以下这些地方不能编译：</p>
<p>　　(1)、testMethod方法重载问题。定义的两个testMethod()方法实现了重载，一个形参是基本类型，一个形参是包装类型，这类重载很正常。虽然基本类型和包装类型有自动装箱、自动拆箱功能，但并不影响它们的重载，自动拆箱(装箱)只有在赋值时才会发生，和编译重载没有关系。</p>
<p>　　(2)、c.testMethod(i) 报错。i 是int类型，传递到testMethod(long a)是没有任何问题的，编译器会自动把 i 的类型加宽，并将其转变为long型，这是基本类型的转换法则，也没有任何问题。</p>
<p>　　(3)、c.testMethod(new Integer(i))报错。代码中没有testMethod(Integer i)方法，不可能接收一个Integer类型的参数，而且Integer和Long两个包装类型是兄弟关系，不是继承关系，那就是说肯定编译失败了？不，编译时成功的，稍后再解释为什么这里编译成功。</p>
<p>既然编译通过了，我们看一下输出：</p>
<p>　 <strong>基本类型的方法被调用</strong><br>    <strong>基本类型的方法被调用</strong></p>
<p>　　c.testMethod(i)的输出是正常的，我们已经解释过了，那第二个输出就让人困惑了，为什么会调用testMethod（long a）方法呢？这是因为自动装箱有一个重要原则：基本类型可以先加宽，再转变成宽类型的包装类型，但不能直接转变成宽类型的包装类型。这句话比较拗口，简单的说就是，int可以加宽转变成long，然后再转变成Long对象，但不能直接转变成包装类型，注意这里指的都是自动转换，不是通过构造函数生成，为了解释这个原则，我们再来看一个例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client29</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Client29 c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Client29</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">140</span><span class="token punctuation">;</span>
        c<span class="token punctuation">.</span><span class="token function">testMethod</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span>Long a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 包装类型的方法被调用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    这段程序的编译是不通过的，因为i是一个int类型，不能自动转变为Long型，但是修改成以下代码就可以通过了：</p>
<p>int i = 140; long a =（long）i； c.testMethod(a);<br>这就是int先加宽转变成为long型，然后自动转换成Long型，规则说明了，我们继续来看testMethod(Integer.valueOf(i))是如何调用的，Integer.valueOf(i)返回的是一个Integer对象，这没错，但是Integer和int是可以互相转换的。没有testMethod(Integer i)方法？没关系，编译器会尝试转换成int类型的实参调用，Ok，这次成功了，与testMethod（i）相同了，于是乎被加宽转变成long型—结果也很明显了。整个testMethod(Integer.valueOf(i))的执行过程是这样的：</p>
<p>　　(1)、i 通过valueOf方法包装成一个Integer对象</p>
<p>　　(2)、由于没有testMethod(Integer i)方法，编译器会”聪明”的把Integer对象转换成int。</p>
<p>　　(3)、int自动拓宽为long，编译结束</p>
<p>　　使用包装类型确实有方便的方法，但是也引起一些不必要的困惑，比如我们这个例子，如果testMethod()的两个重载方法使用的是基本类型，而且实参也是基本类型，就不会产生以上问题，而且程序的可读性更强。自动装箱(拆箱)虽然很方便，但引起的问题也非常严重，我们甚至都不知道执行的是哪个方法。</p>
<p><strong><font color="red">注意：重申，基本类型优先考虑。</font></strong></p>
<h3><span id="建议30不要随便设置随机种子">建议30：不要随便设置随机种子</span></h3><p>​    随机数用的地方比较多，比如加密，混淆计算，我们使用随机数期望获得一个唯一的、不可仿造的数字，以避免产生相同的业务数据造成混乱。在Java项目中通常是通过Math.random方法和Random类来获得随机数的，我们来看一段代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client30</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"次:"</span><span class="token operator">+</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    代码很简单，我们一般都是这样获得随机数的，运行此程序可知，三次打印，的随机数都不相同，即使多次运行结果也不同，这也正是我们想要随机数的原因，我们再来看看下面的程序：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client30</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"次:"</span><span class="token operator">+</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面使用了Random的有参构造，运行结果如下：</p>
<p><strong>第1次:-1244746321</strong><br><strong>第2次:1060493871</strong><br><strong>第3次:-1826063944</strong><br><strong>第4次:1976922248</strong>　　</p>
<p> 　计算机不同输出的随机数也不同，但是有一点是相同的：在同一台机器上，甭管运行多少次，所打印的随机数都是相同的，也就是说第一次运行，会打印出这几个随机数，第二次运行还是打印出这三个随机数，只要是在同一台机器上，就永远都会打印出相同的随机数，似乎随机数不随机了，问题何在？</p>
<p>　　那是因为<strong>产生的随机数的种子被固定了</strong>，在Java中，随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个原则：</p>
<ol>
<li>种子不同，产生不同的随机数</li>
<li>种子相同，即使实例不同也产生相同的随机数</li>
</ol>
<p>　　看完上面两个规则，我们再来看这个例子，会发现问题就出在有参构造上，Random类的默认种子(无参构造)是System.nonoTime()的返回值(JDK1.5版本以前默认种子是System.currentTimeMillis()的返回值)，注意这个值是距离某一个固定时间点的纳秒数，不同的操作系统和硬件有不同的固定时间点，也就是说不同的操作系统其纳秒值是不同的，而同一个操作系统纳秒值也会不同，随机数自然也就不同了.(顺便说下，System.nonoTime不能用于计算日期，那是因为”固定”的时间是不确定的，纳秒值甚至可能是负值，这点与System.currentTiemMillis不同)。</p>
<p>　　new Random(1000)显示的<strong>设置了随机种子</strong>为1000，运行多次，虽然实例不同，但都会获得相同的四个随机数，所以，除非必要，否则不要设置随机种子。</p>
<p>　　顺便提一下，在Java中有两种方法可以获得不同的随机数：通过，java.util.Random类获得随机数的原理和Math.random方法相同，Math.random方法也是通过生成一个Random类的实例，然后委托nextDouble()方法的，两者殊途同归，没有差别。</p>
<p><strong><font color="red">注意：若非必要，不要设置随机数种子</font></strong></p>
<h2><span id="第3章-类-对象及方法">第3章 类、对象及方法</span></h2><p>​    书读得多而不思考，你会觉得自己知道的很多。书读得多而思考，你会觉得自己不懂的越来越多。——伏尔泰</p>
<p>​    在面向对象编程（Object-Oriented Programming，OOP）的世界里，类和对象是真实世界的描述工具，方法是行为和动作的展示形式，封装、继承、多态则是其多姿多彩的主要实现方式，如此，OOP才会像现在这样繁荣昌盛、欣欣向荣。本章主要讲述关于Java类、对象、方法的种种规则、限制及建议，让读者在面向对象编程的世界中走得更远，飞得更高。</p>
<h3><span id="建议31在接口中不要存在实现代码">建议31：在接口中不要存在实现代码</span></h3><p>​    看到这样的标题，大家是否感到郁闷呢？接口中有实现代码吗？这怎么可能呢？确实，接口中可以声明常量，声明抽象方法，可以继承父接口，但就是不能有具体实现，因为接口是一种契约(Contract),是一种框架性协议，这表明它的实现类都是同一种类型，或者具备相似特征的一个集合体。对于一般程序，接口确实没有任何实现，但是在那些特殊的程序中就例外了，阅读如下代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client31</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//调用接口的实现</span>
        B<span class="token punctuation">.</span>s<span class="token punctuation">.</span><span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 在接口中存在实现代码</span>
<span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> S s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">S</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我在接口中实现了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 被实现的接口</span>
<span class="token keyword">interface</span> <span class="token class-name">S</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    仔细看main方法，注意那个B接口。它调用了接口常量，在没有实现任何显示实现类的情况下，它竟然打印出了结果，那B接口中的s常量(接口是S)是在什么地方被实现的呢？答案在B接口中。</p>
<p>　　在B接口中声明了一个静态常量s，其值是一个匿名内部类(Anonymous Inner Class)的实例对象，就是该匿名内部类（当然，也可以不用匿名，直接在接口中是实现内部类也是允许的）实现了S接口。你看，在接口中也存在着实现代码吧！</p>
<p>　　这确实很好，很强大，但是在一般的项目中，此类代码是严禁出现的，原因很简单：这是一种非常不好的编码习惯，接口是用来干什么的？接口是一个契约，不仅仅约束着实现，同时也是一个保证，保证提供的服务(常量和方法)是稳定的、可靠的，如果把实现代码写到接口中，那接口就绑定了可能变化的因素，这会导致实现不再稳定和可靠，是随时都可能被抛弃、被更改、被重构的。所以，接口中虽然可以有实现，但应避免使用。</p>
<p><strong><font color="red">注意：接口中不能出现实现代码。</font></strong></p>
<h3><span id="建议32静态变量一定要先声明后赋值">建议32：静态变量一定要先声明后赋值</span></h3><p>​    这个标题是否像上一个建议的标题一样让人郁闷呢？什么叫做变量一定要先声明后赋值？Java中的变量不都是先声明后使用的吗？难道还能先使用后声明?能不能暂且不说，我们看一个例子，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client32</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这段程序很简单，输出100嘛，对，确实是100，我们稍稍修改一下，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client32</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　注意变量 i 的声明和赋值调换了位置，现在的问题是：这段程序能否编译？如过可以编译，输出是多少？还要注意，这个变量i可是先使用(也就是赋值)后声明的。</p>
<p>　　答案是：可以编译，没有任何问题，输出结果为1。对，输出是 1 不是100.仅仅调换了位置，输出就变了，而且变量 i 还是先使用后声明的，难道颠倒了？</p>
<p>　　这要从静态变量的诞生说起，静态变量是类加载时被分配到数据区(Data Area)的，它在内存中只有一个拷贝，不会被分配多次，其后的所有赋值操作都是值改变，地址则保持不变。我们知道JVM初始化变量是先声明空间，然后再赋值，也就是说：在JVM中是分开执行的，等价于：</p>
<p>　　int i ; //分配空间</p>
<p>　　i = 100; //赋值</p>
<p>　　静态变量是在类初始化的时候首先被加载的，JVM会去查找类中所有的静态声明，然后分配空间，注意这时候只是完成了地址空间的分配，还没有赋值，之后JVM会根据类中静态赋值(包括静态类赋值和静态块赋值)的先后顺序来执行。对于程序来说，就是先声明了int类型的地址空间，并把地址传递给了i，然后按照类的先后顺序执行赋值操作，首先执行静态块中i = 100,接着执行 i = 1,那最后的结果就是 i =1了。</p>
<p>　　哦，如此而已，如果有多个静态块对 i 继续赋值呢？i 当然还是等于1了，谁的位置最靠后谁有最终的决定权。</p>
<p>　　有些程序员喜欢把变量定义放到类最底部，如果这是实例变量还好说，没有任何问题，但如果是静态变量，而且还在静态块中赋值了，那这结果就和期望的不一样了，所以遵循Java通用的开发规范”变量先声明后赋值使用”，是一个良好的编码风格。</p>
<p><strong><font color="red">注意：再次重申变量要先声明后使用，这不是一句废话。</font></strong></p>
<p>执行顺序：</p>
<p>1、父类静态变量和静态代码块（先声明的先执行）；</p>
<p>2、子类静态变量和静态代码块（先声明的先执行）；</p>
<p>3、父类的变量和代码块（先声明的先执行）；</p>
<p>4、父类的构造函数；</p>
<p>5、子类的变量和代码块（先声明的先执行）；</p>
<p>6、子类的构造函数。</p>
<h3><span id="建议33不要覆写静态方法">建议33：不要覆写静态方法</span></h3><p>​    我们知到在Java中可以通过覆写(Override)来增强或减弱父类的方法和行为，但覆写是针对非静态方法(也叫做实例方法，只有生成实例才能调用的方法)的，不能针对静态方法(static修饰的方法，也叫做类方法)，为什么呢？我们看一个例子，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client33</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Base base <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//调用非静态方法</span>
        base<span class="token punctuation">.</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//调用静态方法</span>
        base<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 我是父类静态方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是父类静态方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 父类非静态方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是父类非静态方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 子类同名、同参数的静态方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是子类静态方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 覆写父类非静态方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是子类非静态方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    注意看程序，子类的doAnything方法覆写了父类方法，真没有问题，那么doSomething方法呢？它与父类的方法名相同，输入、输出也相同，按道理来说应该是覆写，不过到底是不是覆写呢？我们看看输出结果：  <strong>我是子类非静态方法   我是父类静态方法</strong></p>
<p>　　这个结果很让人困惑，同样是调用子类方法，一个执行了父类方法，两者的差别仅仅是有无static修饰，却得到不同的结果，原因何在呢？</p>
<p>　　我们知道一个实例对象有两个类型：表面类型(Apparent Type)和实际类型(Actual Type)，表面类型是声明的类型，实际类型是对象产生时的类型，比如我们例子，变量base的表面类型是Base，实际类型是Sub。<strong>对于非静态方法，它是根据对象的实际类型来执行的</strong>，也就是执行了Sub类中的doAnything方法。而对于静态方法来说就比较特殊了，<strong>首先静态方法不依赖实例对象，它是通过类名来访问的</strong>；其次，可以通过对象访问静态方法，如果是通过对象访问静态方法，JVM则会通过对象的表面类型查找静态方法的入口，继而执行之。因此上面的程序打印出”我是父类非静态方法”，也就不足为奇了。</p>
<p>　　在子类中构建与父类方法相同的方法名、输入参数、输出参数、访问权限(权限可以扩大)，并且父类，子类都是静态方法，此种行为叫做隐藏(Hide),它与覆写有两点不同：</p>
<p>　　(1)、表现形式不同：隐藏用于静态方法，覆写用于非静态方法，在代码上的表现是@Override注解可用于覆写，不可用于隐藏。</p>
<p>　　(2)、职责不同：隐藏的目的是为了抛弃父类的静态方法，重现子类方法，例如我们的例子，Sub.doSomething的出现是为了遮盖父类的Base.doSomething方法，也就是i期望父类的静态方法不要做破坏子类的业务行为，而覆写是将父类的的行为增强或减弱，延续父类的职责。</p>
<p>　　解释了这么多，我们回头看看本建议的标题，静态方法不能覆写，可以再续上一句话，虽然不能覆写，但可以隐藏。顺便说一下，通过实例对象访问静态方法或静态属性不是好习惯，它给代码带来了”坏味道”，建议大家阅之戒之。</p>
<h3><span id="建议34构造函数尽量简化">建议34：构造函数尽量简化</span></h3><p>​    我们知道通过new关键字生成的对象必然会调用构造函数，构造函数的简繁情况会直接影响实例对象的创建是否繁琐，在项目开发中，我们一般都会制定构造函数尽量简单，尽可能不抛异常，尽量不做复杂运算等规范，那如果一个构造函数确实复杂了会怎么样？我们开看一段代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client34</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Server s<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleServer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Server</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> DEFAULT_PORT <span class="token operator">=</span> <span class="token number">40000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Server</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 获得子类提供的端口号</span>
        <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"端口号："</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/* 进行监听动作 */</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 由子类提供端口号，并作可用性检查</span>
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SimpleServer</span> <span class="token keyword">extends</span> <span class="token class-name">Server</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 初始化传递一个端口号</span>
    <span class="token keyword">public</span> <span class="token function">SimpleServer</span><span class="token punctuation">(</span><span class="token keyword">int</span> _port<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        port <span class="token operator">=</span> _port<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 检查端口是否有效，无效则使用默认端口，这里使用随机数模拟</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0.5</span> <span class="token operator">?</span> port <span class="token operator">:</span> DEFAULT_PORT<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>​    该代码是一个服务类的简单模拟程序，Server类实现了服务器的创建逻辑，子类要在生成实例对象时传递一个端口号即可创建一个监听端口的服务，该代码的意图如下：</p>
<ol>
<li>通过SimpleServer的构造函数接收端口参数；</li>
<li>子类的构造函数默认调用父类的构造函数；</li>
<li>父类构造函数调用子类的getPort方法获得端口号；</li>
<li>父类的构造函数建立端口监听机制；</li>
<li>对象创建完毕，服务监听启动，正常运行。</li>
</ol>
<p>　　貌似很合理，再仔细看看代码，确实与我们的意图相吻合，那我们尝试多次运行看看，输出结果要么是”端口号：40000”，要么是”端口号：0”,永远不会出现”端口号：100”或是”端口号：1000”,这就奇怪了，40000还好说，那个0是怎么冒出来的呢？怠慢什么地方出现了问题呢？</p>
<p>　　要解释这个问题，我们首先要说说子类是如何实例化的。子类实例化时，会首先初始化父类(注意这里是初始化，不是生成父类对象)，也就是初始化父类的变量，调用父类的构造函数，然后才会初始化子类的变量，调用子类的构造函数，最后生成一个实例对象。了解了相关知识，我们再来看看上面的程序，其执行过程如下：</p>
<ol>
<li>子类SimpleServer的构造函数接收int类型的参数1000；</li>
<li>父类初始化常量，也就是DEFAULT_PORT初始化，并设置值为40000;</li>
<li>执行父类无参构造函数，也就是子类有参构造函数默认包含了super()方法；</li>
<li>父类无参构造函数执行到“int port = getPort() ”方法，调用子类的getPort方法实现；</li>
<li>子类的getPort方法返回port值(注意，此时port变量还没有赋值，是0)或DEFAULT_PORT(此时已经是40000)了；</li>
<li>父类初始化完毕，开始初始化子类的实例变量，port值赋值100；</li>
<li>执行子类构造函数，port值被重新赋值为1000；</li>
<li>子类SimpleServer实例化结束，对象创建完毕。</li>
</ol>
<p>　　终于清楚了，在类初始化时getPort方法返回值还没有赋值，port只是获得了默认初始值(int类型的实例变量默认初始值是0)，因此Server永远监听的是40000端口(0端口是没有意义的)。这个问题的产生从浅处说是类元素初始顺序导致的，从深处说是因为构造函数太复杂引起的。构造函数用作初始化变量，声明实例的上下文，这都是简单实现的，没有任何问题，但我们的例子却实现了一个复杂的逻辑，而这放在构造函数里就不合适了。</p>
<p>　　问题知道了，修改也很简单，把父类的无参构造函数中的所有实现都移动到一个叫做start的方法中，将SimpleServer类初始化完毕，再调用其start方法即可实现服务器的启动工作，简洁而又直观，这也是大部分JEE服务器的实现方式。</p>
<p>**<font color="red">注意：构造函数简化，再简化，应该达到”一眼洞穿”的境界</font>**。</p>
<h3><span id="建议35避免在构造函数中初始化其它类">建议35：避免在构造函数中初始化其它类</span></h3><p>​    构造函数是一个类初始化必须执行的代码，它决定着类初始化的效率，如果构造函数比较复杂，而且还关联了其它类，则可能产生想不到的问题，我们来看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client35</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Son son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        son<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 父类</span>
<span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 相关类</span>
<span class="token keyword">class</span> <span class="token class-name">Other</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Other</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 子类</span>
<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hi, show me Something!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    这段代码并不复杂，只是在构造函数中初始化了其它类，想想看这段代码的运行结果是什么？会打印出”Hi ，show me Something!”吗？</p>
<p>　　答案是这段代码不能运行，报StatckOverflowError异常，栈(Stack)内存溢出，这是因为声明变量son时，调用了Son的无参构造函数，JVM又默认调用了父类的构造函数，接着Father又初始化了Other类，而Other类又调用了Son类，于是一个死循环就诞生了，知道内存被消耗完停止。</p>
<p>　　大家可能觉得这样的场景不会出现在开发中，我们来思考这样的场景，Father是由框架提供的，Son类是我们自己编写的扩展代码，而Other类则是框架要求的拦截类(Interceptor类或者Handle类或者Hook方法)，再来看看问题，这种场景不可能出现吗?　　</p>
<p>　　可能大家会觉得这样的场景不会出现，这种问题只要系统一运行就会发现，不可能对项目产生影响。</p>
<p>　　那是因为我们这里展示的代码比较简单，很容易一眼洞穿，一个项目中的构造函数可不止一两个，类之间的关系也不会这么简单，要想瞥一眼就能明白是否有缺陷这对所有人员来说都是不可能完成的任务，解决此类问题最好的办法就是：不要在构造函数中声明初始化其他类，养成良好习惯。</p>
<h3><span id="建议36使用构造代码块精简程序">建议36：使用构造代码块精简程序</span></h3><p>什么叫做代码块(Code Block)？用大括号把多行代码封装在一起，形成一个独立的数据体，实现特定算法的代码集合即为代码块，一般来说代码快不能单独运行的，必须要有运行主体。在Java中一共有四种类型的代码块：</p>
<ol>
<li>普通代码块：就是在方法后面使用”{}”括起来的代码片段，它不能单独运行，必须通过方法名调用执行；</li>
<li>静态代码块：在类中使用static修饰，并用”{}”括起来的代码片段，用于静态变量初始化或对象创建前的环境初始化。</li>
<li>同步代码块：使用synchronized关键字修饰，并使用”{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。</li>
<li>构造代码块：在类中没有任何前缀和后缀,并使用”{}”括起来的代码片段；</li>
</ol>
<p>　　我么知道一个类中至少有一个构造函数(如果没有，编译器会无私的为其创建一个无参构造函数)，构造函数是在对象生成时调用的，那现在为你来了：构造函数和代码块是什么关系，构造代码块是在什么时候执行的？在回答这个问题之前，我们先看看编译器是如何处理构造代码块的，看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client36</span> <span class="token punctuation">{</span>

    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 构造代码块</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行构造代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Client36</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行无参构造"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Client36</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行有参构造"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　这是一段非常简单的代码，它包含了构造代码块、无参构造、有参构造，我们知道代码块不具有独立执行能力，那么编译器是如何处理构造代码块的呢？很简单，编译器会把构造代码块插入到每个构造函数的最前端，上面的代码等价于：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client36</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token function">Client36</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行构造代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行无参构造"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Client36</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行构造代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行有参构造"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    每个构造函数的最前端都被插入了构造代码块，很显然，在通过new关键字生成一个实例时会先执行构造代码块，然后再执行其他代码，也就是说：构造代码块会在每个构造函数内首先执行（需要注意的是：构造代码块不是在构造函数之前运行的，它依托于构造函数的执行），明白了这一点，我们就可以把构造代码块应用到如下场景中：</p>
<ol>
<li>初始化实例变量(Instance Variable):<strong>如果每个构造函数都要初始化变量，可以通过构造代码块来实现。</strong>当然也可以通过定义一个方法，然后在每个构造函数中调用该方法来实现，没错，可以解决，但是要在每个构造函数中都调用该方法，而这就是其缺点，若采用构造代码块的方式则不用定义和调用，会直接由编译器写入到每个构造函数中，这才是解决此问题的绝佳方式。</li>
<li>初始化实例环境：一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建该对象的时候创建次场景，例如在JEE开发中，要产生HTTP Request必须首先建立HTTP Session，在创建HTTP Request时就可以通过构造代码块来检查HTTP Session是否已经存在，不存在则创建之。</li>
</ol>
<p>　　以上两个场景利用了构造代码块的两个特性：在每个构造函数中都运行和在构造函数中它会首先运行。很好的利用构造代码块的这连个特性不仅可以减少代码量，还可以让程序更容易阅读，特别是当所有的构造函数都要实现逻辑，而且这部分逻辑有很复杂时，这时就可以通过编写多个构造代码块来实现。每个代码块完成不同的业务逻辑（当然了构造函数尽量简单，这是基本原则），按照业务顺序一次存放，这样在创建实例对象时JVM就会按照顺序依次执行，实现复杂对象的模块化创建。</p>
<h3><span id="建议37构造代码块会想你所想">建议37：构造代码块会想你所想</span></h3><p>​    上一建议中我们提议使用构造代码块来简化代码，并且也了解到编译器会自动把构造代码块插入到各个构造函数中，那我们接下来看看，编译器是不是足够聪明，能为我们解决真实的开发问题，有这样一个案例，统计一个类的实例变量数。你可要说了，这很简单，在每个构造函数中加入一个对象计数器补救解决了嘛？或者我们使用上一建议介绍的，使用构造代码块也可以，确实如此，我们来看如下代码是否可行：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client37</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"实例对象数量："</span><span class="token operator">+</span>Student<span class="token punctuation">.</span><span class="token function">getNumOfObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 对象计数器</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> numOfObjects <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 构造代码块，计算产生的对象数量</span>
        numOfObjects<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 有参构造调用无参构造</span>
    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span>String stuName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 有参构造不调用无参构造</span>
    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> stuAge<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//返回在一个JVM中，创建了多少实例对象</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getNumOfObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> numOfObjects<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    这段代码可行吗？能计算出实例对象的数量吗？如果编译器把构造代码块插入到各个构造函数中，那带有String形参的构造函数就可能有问题，它会调用无参构造，那通过它生成的Student对象就会执行两次构造代码块：一次是无参构造函数调用构造代码块，一次是执行自身的构造代码块，这样的话计算就不准确了，main函数实际在内存中产生了3个对象，但结果确是4。不过真的是这样吗？我们运行之后，结果是：</p>
<p>　　实例对象数量：3；</p>
<p>　　实例对象的数量还是3，程序没有问题，奇怪吗？不奇怪，上一建议是说编译器会把构造代码块插入到每一个构造函数中，但是有一个例外的情况没有说明：如果遇到this关键字(也就是构造函数调用自身的其它构造函数时)，则不插入构造代码块，对于我们的例子来说，编译器在编译时发现String形参的构造函数调用了无参构造，于是放弃插入构造代码块，所以只执行了一次构造代码块。</p>
<p>　　那Java编译器为何如此聪明？这还要从构造代码块的诞生说起，构造代码块是为了提取构造函数的共同量，减少各个构造函数的代码产生的，因此，Java就很聪明的认为把代码插入到this方法的构造函数中即可，而调用其它的构造函数则不插入，确保每个构造函数只执行一次构造代码块。</p>
<p>　　还有一点需要说明，大家千万不要以为this是特殊情况，那super也会类似处理了，其实不会，在构造块的处理上，super方法没有任何特殊的地方，编译器只把构造代码块插入到super方法之后执行而已。仅此不同。</p>
<p>　　注意：放心的使用构造代码块吧，Java已经想你所想了。</p>
<h3><span id="建议38使用静态内部类提高封装性">建议38：使用静态内部类提高封装性</span></h3><p>​        Java中的嵌套类(Nested Class)分为两种：静态内部类(也叫静态嵌套类，Static Nested Class)和内部类(Inner Class)。本次主要看看静态内部类。什么是静态内部类呢？是内部类，并且是静态(static修饰)的即为静态内部类，只有在是静态内部类的情况下才能把static修饰符放在类前，其它任何时候static都是不能修饰类的。</p>
<p>　　静态内部类的形式很好理解，但是为什么需要静态内部类呢？那是因为静态内部类有两个优点：<strong>加强了类的封装和提高了代码的可读性</strong>，我们通过下面代码来解释这两个优点。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 姓名</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 家庭</span>
    <span class="token keyword">private</span> Home home<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String _name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/* home、name的setter和getter方法略 */</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Home</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 家庭地址</span>
        <span class="token keyword">private</span> String address<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 家庭电话</span>
        <span class="token keyword">private</span> String tel<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Home</span><span class="token punctuation">(</span>String _address<span class="token punctuation">,</span> String _tel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            address <span class="token operator">=</span> _address<span class="token punctuation">;</span>
            tel <span class="token operator">=</span> _tel<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">/* address、tel的setter和getter方法略 */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    其中，Person类中定义了一个静态内部类Home,它表示的意思是”人的家庭信息”，由于Home类封装了家庭信息，不用再Person中再定义homeAddr,homeTel等属性，这就使封装性提高了。同时我们仅仅通过代码就可以分析出Person和Home之间的强关联关系，也就是说语义增强了，可读性提高了。所以在使用时就会非常清楚它表达的含义。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 定义张三这个人</span>
    Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 设置张三的家庭信息</span>
    p<span class="token punctuation">.</span><span class="token function">setHome</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Home</span><span class="token punctuation">(</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"010"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre>
<p>​        定义张三这个人，然后通过Person.Home类设置张三的家庭信息，这是不是就和我们真是世界的情形相同了？先登记人的主要信息，然后登记人员的分类信息。可能你由要问了，这和我们一般定义的类有神么区别呢？又有什么吸引人的地方呢？如下所示：</p>
<ol>
<li>提高封装性：从代码的位置上来讲，静态内部类放置在外部类内，其代码层意义就是，静态内部类是外部类的子行为或子属性，两者之间保持着一定的关系，比如在我们的例子中，看到Home类就知道它是Person的home信息。</li>
<li>提高代码的可读性：相关联的代码放在一起，可读性肯定提高了。</li>
<li>形似内部，神似外部：静态内部类虽然存在于外部类内，而且编译后的类文件也包含外部类(格式是：外部类+$+内部类)，但是它可以脱离外部类存在，也就说我们仍然可以通过new Home()声明一个home对象，只是需要导入”Person.Home”而已。　　</li>
</ol>
<p>　　解释了这么多，大家可能会觉得外部类和静态内部类之间是组合关系(Composition)了，这是错误的，外部类和静态内部类之间有强关联关系，这仅仅表现在”字面上”，而深层次的抽象意义则依类的设计.</p>
<p>　　那静态类内部类和普通内部类有什么区别呢？下面就来说明一下：</p>
<ol>
<li><strong>静态内部类不持有外部类的引用</strong>：在普通内部类中，我们可以直接访问外部类的属性、方法，即使是private类型也可以访问，这是因为内部类持有一个外部类的引用，可以自由访问。而静态内部类，则只可以访问外部类的静态方法和静态属性(如果是private权限也能访问，这是由其代码位置决定的)，其它的则不能访问。</li>
<li><strong>静态内部类不依赖外部类</strong>：普通内部类与外部类之间是相互依赖关系，内部类实例不能脱离外部类实例，也就是说它们会同生共死，一起声明，一起被垃圾回收，而静态内部类是可以独立存在的，即使外部类消亡了，静态内部类也是可以存在的。</li>
<li><strong>普通内部类不能声明static的方法和变量</strong>：普通内部类不能声明static的方法和变量，注意这里说的是变量，常量(也就是final static 修饰的属性)还是可以的，而静态内部类形似外部类，没有任何限制。</li>
</ol>
<h3><span id="建议39使用匿名类的构造函数">建议39：使用匿名类的构造函数</span></h3><p>阅读如下代码，看上是否可以编译：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List list1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List list2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    List list3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> list2<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list2<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> list3<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> list3<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
```

注意ArrayList后面的不通点：list1变量后面什么都没有，list2后面有一对<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>list3后面有两个嵌套的<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>这段程序能否编译呢？若能编译，那输结果是什么呢？

　　答案是能编译，输出的是<span class="token number">3</span>个<span class="token boolean">false</span>。list1很容易理解，就是生命了ArrayList的实例对象，那list2和list3代表的是什么呢？

　　<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>、list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>：list2代表的是一个匿名类的声明和赋值，它定义了一个继承于ArrayList的匿名类，只是没有任何覆写的方法而已，其代码类似于：　

```java
<span class="token comment" spellcheck="true">// 定义一个继承ArrayList的内部类</span>
<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">ArrayList</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 声明和赋值</span>
List list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
```

　<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>、list3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>：这个语句就有点奇怪了，带了两对<span class="token punctuation">{</span><span class="token punctuation">}</span>，我们分开解释就明白了，这也是一个匿名类的定义，它的代码类似于

```java
<span class="token comment" spellcheck="true">// 定义一个继承ArrayList的内部类</span>
<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">ArrayList</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//初始化代码块</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 声明和赋值</span>
List list3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>​    看到了吧，就是多了一个初始化块而已，起到构造函数的功能，我们知道一个类肯定有一个构造函数，而且构造函数的名称和类名相同，那问题来了：匿名类的构造函数是什么呢？它没有名字呀！很显然，初始化块就是它的构造函数。当然，一个类中的构造函数块可以是多个，也就是说会出现如下代码：</p>
<pre><code>List list4 = new ArrayList()&#123;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&#125;;
</code></pre>
<p>上面的代码是正确无误，没有任何问题的，现在清楚了，<strong>匿名类虽然没有名字，但也是可以有构造函数的</strong>，它用构造函数块来代替构造函数，那上面的3个输出就很明显了：虽然父类相同，但是类还是不同的。　　</p>
<h3><span id="建议40匿名类的构造函数很特殊">建议40：匿名类的构造函数很特殊</span></h3><p>​    在上一建议中我们讲到匿名类虽然没有名字，但可以有一个初始化块来充当构造函数，那这个构造函数是否就和普通的构造函数完全不一样呢？我们来看一个例子，设计一个计算器，进行加减运算，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Calculator</span> <span class="token punctuation">{</span>
    <span class="token keyword">enum</span> Ops <span class="token punctuation">{</span>
        ADD<span class="token punctuation">,</span> SUB
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> result<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 无参构造</span>
    <span class="token keyword">public</span> <span class="token function">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 有参构造</span>
    <span class="token keyword">public</span> <span class="token function">Calculator</span><span class="token punctuation">(</span><span class="token keyword">int</span> _i<span class="token punctuation">,</span> <span class="token keyword">int</span> _j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i <span class="token operator">=</span> _i<span class="token punctuation">;</span>
        j <span class="token operator">=</span> _j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 设置符号，是加法运算还是减法运算</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">setOperator</span><span class="token punctuation">(</span>Ops _ops<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">=</span> _ops<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>Ops<span class="token punctuation">.</span>ADD<span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">+</span> j <span class="token operator">:</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 取得运算结果</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>　代码的意图是，通过构造函数传递两个int类型的数字，然后根据设置的操作符(加法还是减法)进行运算，编写一个客户端调用：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Calculator c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Calculator</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">{</span>
            <span class="token function">setOperator</span><span class="token punctuation">(</span>Ops<span class="token punctuation">.</span>ADD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    这段匿名类的代码非常清晰：接收两个参数1和2，然后设置一个操作符号，计算其值，结果是3，这毫无疑问，但是这中间隐藏着一个问题：带有参数的匿名类声明时到底调用的是哪一个构造函数呢？我们把这段程序模拟一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//加法计算</span>
<span class="token keyword">class</span> <span class="token class-name">Add</span> <span class="token keyword">extends</span> <span class="token class-name">Calculator</span><span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token function">setOperator</span><span class="token punctuation">(</span>Ops<span class="token punctuation">.</span>ADD<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//覆写父类的构造方法</span>
    <span class="token keyword">public</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> _i<span class="token punctuation">,</span> <span class="token keyword">int</span> _j<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　匿名类和这个Add类等价吗？可能有人会说：上面只是把匿名类增加了一个名字，其它的都没有改动，那肯定是等价了，毫无疑问 ，那好，编写一个客户端调用Add类的方法看看。代码就略了，因为很简单new Add，然后调用父类的getResult方法就可以了，经过测试，输出结果为0（为什么而是0？这很容易，有参构造没有赋值）。这说明两者不等价，不过，原因何在呢？</p>
<p>　　因为匿名类的构造函数特殊处理机制，一般类(也就是没有显示名字的类)的所有构造函数默认都是调用父类的无参构造函数的，而匿名类因为没有名字，只能由构造代码块代替，也就无所谓有参和无参的构造函数了，它在初始化时直接调用了父类的同参数构造函数，然后再调用了自己的构造代码块，也就是说上面的匿名类和下面的代码是等价的：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//加法计算</span>
<span class="token keyword">class</span> <span class="token class-name">Add</span> <span class="token keyword">extends</span> <span class="token class-name">Calculator</span><span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token function">setOperator</span><span class="token punctuation">(</span>Ops<span class="token punctuation">.</span>ADD<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//覆写父类的构造方法</span>
    <span class="token keyword">public</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> _i<span class="token punctuation">,</span> <span class="token keyword">int</span> _j<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>_i<span class="token punctuation">,</span>_j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    它会首先调用父类有两个参数的构造函数，而不是无参构造，这是匿名类的构造函数与普通类的差别，但是这一点也确实鲜有人仔细琢磨，因为它的处理机制符合习惯呀，我传递两个参数，就是希望先调用父类有两个参数的构造，然后再执行我自己的构造函数，而Java的处理机制也正是如此处理的。</p>
<h3><span id="建议41让多重继承成为现实">建议41：让多重继承成为现实</span></h3><p>​    在Java中一个类可以多重实现，但不能多重继承，也就是说一个类能够同时实现多个接口，但不 能同时继承多个类。但有时候我们确实需要继承多个类，比如希望拥有多个类的行为功能，就很难使用单继承来解决问题了(当然，使用多继承是可以解决的)。幸 运的是Java中提供的内部类可以曲折的解决此问题，我们来看一个案例，定义一个父亲、母亲接口，描述父亲强壮、母亲温柔的理想情形，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">strong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Mother</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    其中strong和kind的返回值表示强壮和温柔的指数，指数越高强壮和温柔也就越高，这与游戏中设置人物的属性是一样的，我们继续开看父亲、母亲这两个实现：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FatherImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 父亲的强壮指数为8</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">strong</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MotherImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Mother</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 母亲的温柔指数为8</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>父亲的强壮指数为8，母亲的温柔指数也为8，门当户对，那他们生的儿子和女儿一定更优秀了，我们看看儿子类，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">FatherImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Mother</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">strong</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 儿子比父亲强壮</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">strong</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MotherSpecial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">MotherSpecial</span> <span class="token keyword">extends</span> <span class="token class-name">MotherImpl</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 儿子的温柔指数降低了</span>
            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    儿子继承自父亲，变得比父亲更强壮了(覆写父类strong方法)，同时儿子也具有母亲的优点，只是 温柔指数降低了。注意看，这里构造了MotherSpecial类继承母亲类，也就是获得了母亲类的行为和方法，这也是内部类的一个重要特性：内部类可以 继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。MotherSpecial的这种内部类叫做成员内部类(也叫 作实例内部类，Instance Inner Class)，我们再来看看女儿类，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Daughter</span> <span class="token keyword">extends</span> <span class="token class-name">MotherImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">strong</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FatherImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">strong</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//女儿的强壮指数降低了</span>
                <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">strong</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">strong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>​    女儿继承了目前的温柔指数，同时又覆写了父亲的强壮指数，不多解释。注意看覆写的strong方法，这里是创建了一个匿名内部类(Anonymous Inner Class)来覆写父类的方法，以完成继承父亲行为的功能。</p>
<p>　　多重继承指的是一个类可以同时从多与一个的父亲那里继承行为与特征，按照这个定义，我们的儿子类、女儿类都实现了从父亲和母亲那里继承所有的功能，应该属于多重继承，这完全归功于内部类，大家在需要用到多重继承的时候，可以思考一下内部类。</p>
<p>　 　在现实生活中，也确实存在多重继承的问题，上面的例子说后人继承了父亲也继承了母亲的行为和特征，再比如我国的特产动物”四不像”（学名麋鹿），其外 形” 似鹿非鹿，似马非马，似牛非牛，似驴非驴 “，这你想要用单继承实现就比较麻烦了，如果用多继承则可以很好地解决此问题：定义鹿、马、牛、驴　四个类，然后建立麋鹿类的多个内部类，继承他们即可。 　　</p>
<h3><span id="建议42让工具类不可实例化">建议42：让工具类不可实例化</span></h3><p>​    Java项目中使用的工具类非常多，比如JDK自己的工具类 java.lang.Math、java.util.Collections等都是我们经常用到的。工具类的方法和属性都是静态的，不需要生成实例即可访 问，而且JDK也做了很好的处理，由于不希望被初始化，于是就设置了构造函数private的访问权限，表示出了类本身之外，谁都不能产生一个实例，我们 来看一下java.lang.Math代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Math</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/**
     * Don't let anyone instantiate this class.
     */</span>
    <span class="token keyword">private</span> <span class="token function">Math</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    之所以要将”Don’t let anyone instantiate this class.” 留下来，是因为Math的构造函数设置为了private：我就是一个工具类，我只想要其它类通过类名来访问，我不想你通过实例对象来访问。这在平台型或 框架项目中已经足够了。但是如果已经告诉你不要这么做了，你还要生成一个Math对象实例来访问静态方法和属性(Java的反射是如此的发达，修改个构造 函数的访问权限易如反掌)，那我就不保证正确性了，隐藏问题随时都有可能爆发！那我们在项目中有没有更好地限制办法呢？有，即不仅仅设置成private 权限，还抛出异常，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">UtilsClazz</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">UtilsClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Don't instantiate "</span><span class="token operator">+</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    如此，才能保证一个工具类不会实例化，并且保证了所有的访问都是通过类名来进行的。需要注意的一点是，此工具类最好不要做集成的打算，因为如果子类可以实例化的话，就要调用父类的构造函数，可是父类没有可以被访问的构造函数，于是问题就会出现。　</p>
<p><strong><font color="red">注意：如果一个类不允许实例化，就要保证”平常” 渠道都不能实例它。</font></strong>　</p>
<h3><span id="建议43避免对象的浅拷贝">建议43：避免对象的浅拷贝</span></h3><p>​    我们知道一个类实现了Cloneable接口就表示它具备了被拷贝的能力。如果在覆写clone()方法就会完全具备拷贝能力。拷贝是在内存中运行的， 所以在性能方面比直接通过new生成的对象要快很多，特别是在大对象的生成上，这会使得性能的提升非常显著。但是对象拷贝也有一个比较容易忽略的问题：<strong>浅拷贝(Shadow Clone,也叫作影子拷贝)存在对象属性拷贝不彻底的问题</strong>。我们来看这样一段代码：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 定义父亲</span>
        Person f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"父亲"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 定义大儿子</span>
        Person s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"大儿子"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 小儿子的信息时通过大儿子拷贝过来的</span>
        Person s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"小儿子"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 的父亲是 "</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getFather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 的父亲是 "</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getFather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 姓名</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 父亲</span>
    <span class="token keyword">private</span> Person father<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String _name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String _name<span class="token punctuation">,</span> Person _parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
        father <span class="token operator">=</span> _parent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Person <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Person p <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">/*setter和getter方法略*/</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    程序中我们描述了这样一个场景：一个父亲，有两个儿子，大小儿子同根同种，所以小儿子的对象就通过拷贝大儿子的对象来生成，运行输出结果如下：</p>
<p>  　<strong>大儿子 的父亲是 父亲</strong><br>      <strong>小儿子 的父亲是 父亲</strong></p>
<p>　　这很正确，没有问题。突然有一天，父亲心血来潮想让大儿子去认个干爹，也就是大儿子的父亲名称需要重新设置一下，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 定义父亲</span>
    Person f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"父亲"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 定义大儿子</span>
    Person s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"大儿子"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 小儿子的信息时通过大儿子拷贝过来的</span>
    Person s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"小儿子"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//认干爹</span>
    s1<span class="token punctuation">.</span><span class="token function">getFather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"干爹"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 的父亲是 "</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getFather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 的父亲是 "</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getFather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    大儿子重新设置了父亲名称，我们期望的输出结果是：将大儿子的父亲名称修改为干爹，小儿子的父亲名称保持不变。运行一下结果如下：</p>
<p>　  <strong>大儿子 的父亲是 干爹</strong><br>      <strong>小儿子 的父亲是 干爹</strong></p>
<p>　　怎么回事，小儿子的父亲也成了”干爹”？两个儿子都木有了，这老子估计被要被气死了！出现这个问题的原因就在于clone方法，我们知道所有类都继承自 Object，Object提供了一个对象拷贝的默认方法，即页面代码中 的super.clone()方法，但是该方法是有缺陷的，他提供的是一种浅拷贝，也就是说它并不会把对象的所有属性全部拷贝一份，而是有选择的拷贝，它 的<strong>拷贝规则</strong>如下：</p>
<ol>
<li><strong><font color="red">基本类型：如果变量是基本类型，则拷贝其值。比如int、float等</font></strong></li>
<li><strong><font color="red">对 象：如果变量是一个实例对象，则拷贝其地址引用，也就是说此时拷贝出的对象与原有对象共享该实例变量，不受访问权限的控制，这在Java中是很疯狂的，因 为它突破了访问权限的定义：一个private修饰的变量，竟然可以被两个不同的实例对象访问，这让java的访问权限体系情何以堪。</font></strong></li>
<li><strong><font color="red">String字符串：这个比较特殊，拷贝的也是一个地址，是个引用，但是在修改时，它会从字符串池(String pool)中重新生成新的字符串，原有的字符串对象保持不变，在此处我们可以认为String是一个基本类型。</font></strong></li>
</ol>
<p>　　明白了这三个原则，上面的例子就很清晰了。小儿子的对象是通过大儿子拷贝而来的，其父亲是同一个人，也就是同一个对象，大儿子修改了父亲的名称后，小儿子也很跟着修改了——于是，父亲的两个儿子都没了。其实要更正也很简单，clone方法的代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Person <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Person p <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">setFather</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getFather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　然后再运行，小儿子的父亲就不会是干爹了，如此就实现了对象的深拷贝(Deep Clone)，保证拷贝出来的对象自成一体，不受”母体”影响，和new生成的对象没有什么区别。</p>
<p>　　<strong><font color="red">注意：浅拷贝只是Java提供的一种简单拷贝机制，不便于直接使用。</font></strong></p>
<h3><span id="建议44推荐使用序列化对象的拷贝">建议44：推荐使用序列化对象的拷贝</span></h3><p>　上一建议说了对象的浅拷贝问题，试下Cloneable接口就具备了拷贝能力，那我们开思考这样一个问题：如果一个项目中有大量的对象是通过拷贝生成 的，那我们该如何处理呢？每个类都系而一个clone方法，并且还有深拷贝？想想这是何等巨大的工作量呀！是否有更好的方法呢？</p>
<p>　　其实，可以通过序列化方式来处理，在内存中通过字节流的拷贝来实现，也就是把母对象写到一个字节流中，再从字节流中将其读出来，这样就可以重建一个对象了，该新对象与母对象之间不存在引用共享的问题，也就相当于深拷贝了一个对象，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ByteArrayInputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ByteArrayOutputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectOutputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">CloneUtils</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token function">CloneUtils</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>CloneUtils<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">+</span> <span class="token string">" cannot instance "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 拷贝一个对象</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token operator">></span> T <span class="token function">clone</span><span class="token punctuation">(</span>T obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 拷贝产生的对象</span>
        T cloneObj <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 读取对象字节数据</span>
            ByteArrayOutputStream baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">)</span><span class="token punctuation">;</span>
            oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>cloneObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            oos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 分配内存空间，写入原始对象，生成新对象</span>
            ByteArrayInputStream bais <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bais<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 返回新对象， 并做类型转换</span>
            cloneObj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ois<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> cloneObj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    此工具类要求被拷贝的对象实现了Serializable　接口，否则是没办法拷贝的（当然，使用反射是另一种技巧），上一建议中的例子只是稍微修改一下即可实现深拷贝，代码如下</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 4989174799049521302L<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/*删除掉clone方法，其它代码保持不变*/</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    被拷贝的类只要实现Serializable这个标志性接口即可，不需要任何实现，当然serialVersionUID常量还是要加上去的，然后我们就可以通过CloneUtils工具进行对象的深拷贝了，用词方法进行对象拷贝时需要注意两点：</p>
<ol>
<li>对象的内部属性都是可序列化的：如果有内部属性不可序列化，则会抛出序列化异常，这会让调试者很纳闷，生成一个对象怎么回出现序列化异常呢？从这一点考虑，也需要把CloneUtils工具的异常进行细化处理。</li>
<li>注 意方法和属性的特殊修饰符：比如final，static变量的序列化问题会被引入对象的拷贝中，这点需要特别注意，同时 transient变量（瞬态变量，不进行序列化的变量）也会影响到拷贝的效果。当然，采用序列化拷贝时还有一个更简单的方法，即使用Apache下的 commons工具包中SerializationUtils类，直接使用更加简洁.</li>
</ol>
<h3><span id="建议45覆写equals方法时不要识别不出自己">建议45：覆写equals方法时不要识别不出自己</span></h3><p>​    我们在写一个JavaBean时，经常会覆写equals方 法，其目的是根据业务规则判断两个对象是否相等，比如我们写一个Person类，然后根据姓名判断两个实例对象是否相同时，这在DAO（Data Access Objects）层是经常用到的。具体操作时先从数据库中获得两个DTO(Data Transfer Object,数据传输对象)，然后判断他们是否相等的，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String _name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            Person p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
            <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>​    覆写的equals方法做了多个校验，考虑到Web上传递过来的对象有可能输入了前后空格，所以用trim方法剪切了一下，看看代码有没有问题，我们写一个main：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Person p1<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Person p2<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>Person<span class="token operator">></span> list<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中是否包含张三："</span><span class="token operator">+</span>list<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中是否包含张三："</span><span class="token operator">+</span>list<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    上面的代码产生了两个Person对象(注意p2变量中的那个张三后面有一个空格)，然后放到list中，最后判断list是否包含了这两个对象。看上去没有问题，应该打印出两个true才对，但是结果却是：</p>
<p>　   <strong>列表中是否包含张三：true</strong><br>      <strong>列表中是否包含张三：false</strong>　　</p>
<p>　 　刚刚放到list中的对象竟然说没有，这太让人失望了，原因何在呢？list类检查是否包含元素时时通过调用对象的equals方法来判断的，也就是说 contains(p2)传递进去，会依次执行p2.equals(p1),p2.equals(p2),只有一个返回true，结果都是true，可惜 的是比较结果都是false，那问题出来了：难道</p>
<p>p2.equals(p2)因为false不成？</p>
<p>　　还真说对了，p2.equals(p2)确实是false，看看我们的equals方法，它把第二个参数进行了剪切！也就是说比较的如下等式：</p>
<pre class=" language-java"><code class="language-java"><span class="token string">"张三  "</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>​    注意前面的那个张三，是有空格的，那结果肯定是false了，错误也就此产生了，这是一个想做好事却办成了 “坏事” 的典型案例，它违背了equlas方法的**<font color="red">自反性原则：对于任何非空引用x，x.equals(x)应该返回true</font>**，问题直到了，解决非常简单，只要把trim()去掉即可。注意解决的只是当前问题，该equals方法还存在其它问题。</p>
<h3><span id="建议46equals应该考虑null值情景">建议46：equals应该考虑null值情景</span></h3><p>继续45建议的问题，我们解决了覆写equals的自反性问题，是不是就完美了呢？在把main方法重构一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Person p1<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Person p2<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token comment" spellcheck="true">/*其它部分没有任何修改，不再赘述*/</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　    很小的改动，大家肯定晓得了运行结果是包”空指针”异常。原因也很简单：null.equalsIgnoreCase方法自然报错，此处就是为了说明覆写equals方法遵循的一个原则—</p>
<p>　　<strong><font color="red">对称性原则：对于任何引用x和y的情形，如果x.equals(y),把么y.equals(x)也应该返回true。</font></strong></p>
<p>　　解决也很简单，前面加上非空判断即可，很简单，就不贴代码了。</p>
<h3><span id="建议47在equals中使用getclass进行类型判断">建议47：在equals中使用getClass进行类型判断</span></h3><p>​    本节我们继续讨论覆写equals的问题，这次我们编写一个员工Employee类继承Person类，这很正常，员工也是人嘛，而且在JavaBean中继承也很多见，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Employee</span><span class="token punctuation">(</span>String _name<span class="token punctuation">,</span> <span class="token keyword">int</span> _id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        id <span class="token operator">=</span> _id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Employee</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Employee e <span class="token operator">=</span> <span class="token punctuation">(</span>Employee<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String _name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Person p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> null <span class="token operator">==</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    员工类增加了工号ID属性，同时也覆写了equals方法，只有在姓名和ID都相同的情况下才表示同一个员工，这是为了避免一个公司中出现同名同姓员工的情况。看看上面的代码，这里的条件已经相当完善了，应该不会出错了，那我们测试一下，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Employee e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Employee e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Person p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    上面定义了两个员工和一个社会闲杂人员，虽然他们同名同姓，但肯定不是同一个，输出都应该是false，但运行之后结果为： true true false</p>
<p>　　很不给力呀，p1竟然等于e1，也等于e2,为什么不是同一个类的两个实例竟然也会相等呢？这很简单，因为p1.equals(e1)是调用父类Person的equals方法进行判断的，它使用的是instanceof关键字检查e1是否是Person的实例，由于两者村子继承关系，那结果当然是true了，相等也就没有任何问题了，但是反过来就不成立了，e1和e2是不可能等于p1，这也是<strong>违反对称性原则</strong>的一个典型案例。</p>
<p>　　更玄的是p1与e1、e2相等，但e1和e2却不相等，似乎一个简单的符号传递都不能实现，这才是我们分析的重点：e1.equals(e2)调用的是子类Employee的equals方法，不仅仅要判断姓名相同，还要判断Id相同，两者工号是不同的，不相等也是自然的了。等式不传递是因为违反了equals的传递性原则，<strong>传递性原则指的是对于实例对象x、y、z来说，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。</strong></p>
<p>　　这种情况发生的关键是父类引用了instanceof关键字，它是用来判断一个类的实例对象的，这很容易让子类钻空子。想要解决也很简单，使用getClass来代替instanceof进行类型判断，Person的equals方法修改后如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Person p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> null <span class="token operator">==</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    当然，考虑到Employee也有可能被继承，也需要把它的instanceof修改为getClass。总之，在覆写equals时建议使用getClass进行类型判断，而不要使用instanceof。</p>
<h3><span id="建议48覆写equals方法必须覆写hashcode方法">建议48：覆写equals方法必须覆写hashCode方法</span></h3><p>​    覆写equals方法必须覆写hasCode方法，这条规则基本上每个Javaer都知道，这也是JDK的API上反复说明的，不过为什么要则这么做呢？这两个方法之间什么关系呢？本建议就来解释该问题，我们先看看代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client48</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Person类的实例作为map的key</span>
        Map<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token punctuation">{</span>
                <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Person类的实例作为List的元素</span>
        List<span class="token operator">&lt;</span>Person<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">{</span>
                <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> b1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> b2 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>代码中的Person类与上一建议的Person相同，equals方法完美无缺。在这段代码中，我们在声明时直接调用方法赋值，这其实也是一个内部匿名类，现在的问题是b1和b2值是否都为true?</p>
<p>　　我们先来看b1，Person类的equals覆写了，不再判断两个地址相等，而是根据人员的姓名来判断两个对象是否相等，所以不管我们的new Person(“张三”)产生了多少个对象，它们都是相等的。把张三放入List中，再检查List中是否包含，那结果肯定是true了。</p>
<p>　　接下来看b2，我们把张三这个对象作为了Map的键（Key），放进去的是张三，检查的对象还是张三，那应该和List的结果相同了，但是很遗憾，结果为false。原因何在呢？</p>
<p>　　<strong><font color="red">原因就是HashMap的底层处理机制是以数组的方式保存Map条目的(Map Entry)的，这其中的关键是这个数组的下标处理机制：依据传入元素hashCode方法的返回值决定其数组的下标，如果该数组位置上已经有Map条目，并且与传入的值相等则不处理，若不相等则覆盖；如果数组位置没有条目，则插入，并加入到Map条目的链表中。同理，检查键是否存在也是根据哈希码确定位置，然后遍历查找键值的。</font></strong></p>
<p>　　接着深入探讨，那对象元素的hashCode方法返回的是什么值呢？它是一个对象的哈希码，是由Object类的本地方法生成的，确保每个对象有一个哈希码（也是**<font color="red">哈希算法的基本要求：任意输入k，通过一定算法f(k)，将其转换为非可逆的输出，对于两个输入k1和k2，要求若k1=k2，则必须f(k1)=f(k2)，但也允许k1 != k2 , f(k1)=f(k2)的情况存在</font>**）。</p>
<p>　　那回到我们的例子上，由于我们没有覆写hashCode方法，两个张三对象的hashCode方法返回值(也就是哈希码)肯定是不相同的了，在HashMap的数组中也找不到对应的Map条目了，于是就返回了false。</p>
<p>　　问题清楚了，修改也很简单，在Person类中重写一下hashCode方法即可，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HashCodeBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>
</code></pre>
<p>​    其中<strong>HashCodeBuilder是org.apache.commons.lang.builder包下的一个哈希码生成工具</strong>，使用起来非常方便，大家可以直接项目中集成(为何不直接写hashCode方法？因为哈希码的生成有很多种算法，自己写麻烦，事儿又多，所以必要的时候才取”拿来主义”，不重复造轮子是最好的办法。)</p>
<h3><span id="建议49推荐覆写tostring方法">建议49：推荐覆写toString方法</span></h3><p>​    为什么要覆写toString方法，这个问题很简单，因为Java提供的默认toString方法不友好，打印出来看不懂，不覆写不行，看这样一段代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client49</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String _name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>​    输出结果是：Perso@188edd79.如果机器不同，@后面的内容也会不同，但格式都是相同的：类名+@+hashCode,这玩意是给机器看的，人哪能看懂呀！这就是因为我们没有覆写Object类的toString方法的缘故，修改一下，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s.name=%s"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        如此即就可以在需要的时候输出调试信息了，而且非常友好，特别是在bean流行的项目中(一般的Web项目就是这样)，有了这样的输出才能更好地debug，否则查找错误就有点麻烦！当然，当bean的属性较多时，自己实现就不可取了，不过可以直接使用apache的commons工具包中的ToStringBuilder类，简洁，实用又方便。可能有人会说，为什么通过println方法打印一个对象会调用toString方法？那是源于println的打印机制：如果是一个原始类型就直接打印，如果是一个类类型，则打印出其toString方法的返回值，如此而已。同时现在IDE也很先进，大家debug时也可查看对象的变量，但还是建议大家覆写toString方法，这样调试会更方便哦。</p>
<h3><span id="建议50使用package-info类为包服务">建议50：使用package-info类为包服务</span></h3><p>​    Java中有一个特殊的类：package-info类，它是专门为本包服务的，为什么说它特殊，主要体现在三个方面：</p>
<ol>
<li><p>它不能随便创建：在一般的IDE中，Eclipse、package-info等文件是不能随便被创建的，会报”Type name is notvalid”错误，类名无效。在Java中变量定义规范中规定如下字符是允许的：字母、数字、下划线，以及那个不怎么写的$符号，不过中划线可不在之列，那么怎么创建这个文件呢？很简单，用记事本创建一个，然后拷贝进去再改一下就成了，更直接的办法就是从别的项目中拷贝过来。</p>
</li>
<li><p>它服务的对象很特殊：一个类是一类或一组事物的描述，比如Dog这个类，就是描述”阿黄”的，那package-info这个类描述的是什么呢？它总是要有一个被描述或陈述的对象吧，它是描述和记录本包信息的。</p>
</li>
<li><p>package-info类不能有实现代码：package-info类再怎么特殊也是 一个类，也会被编译成 package-info.class,但是在package-info.java文件不能声明package-info类。　　　</p>
<p>　package-info类还有几个特殊的地方，比如不可以继承，没有接口，没有类间关系(关联、组合、聚合等)等，Java中既然有这么特殊的一个类，那肯定有其特殊的作用了，我们来看看它的特殊作用，主要表现在以下三个方面：</p>
</li>
</ol>
<ul>
<li>声明友好类和包内访问常量：这个比较简单，而且很实用，比如一个包中有很多内部访问的类或常量，就可以统一放到package-info类中，这样很方便，便于集中管理，可以减少友好类到处游走的情况，代码如下：</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">PkgClazz</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">PkgConstant</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> String PACKAGE_CONST <span class="token operator">=</span> <span class="token string">"ABC"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>注意以上代码是放在package-info.java中的，虽然它没有编写package-info的实现，但是package-info.class类文件还是会生成。通过这样的定义，我们把一个包需要的常量和类都放置在本包下，在语义上和习惯上都能让程序员更适应。</p>
<ul>
<li>为在包上提供注解提供便利：比如我们要写一个注解(Annotation)，查看一下包下的对象，只要把注解标注到package-info文件中即可，而且在很多开源项目中也采用了此方法，比如struts2的@namespace、hibernate的@FilterDef等.</li>
<li>提供包的整体注释说明：如果是分包开发，也就是说一个包实现了一个业务逻辑或功能点或模块或组件，则该包需要一个很好的说明文档，说明这个包是做什么用的，版本变迁历史，与其他包的逻辑关系等，package-info文件的作用在此就发挥出来了，这些都可以直接定义到此文件中，通过javadoc生成文档时，会吧这些说明作为包文档的首页，让读者更容易对该包有一个整体的认识。当然在这点上它与package.html的作用是相同的，不过package-info可以在代码中维护文档的完整性，并且可以实现代码与文档的同步更新。　　</li>
</ul>
<p>　　创建package-info,也可以利用IDE工具如下图：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160913122230102-806179627.png" alt="img"></p>
<p>解释了这么多，总结成一句话：在需要用到包的地方，就可以考虑一下package-info这个特殊类，也许能起到事半功倍的作用。</p>
<h3><span id="建议51不要主动进行垃圾回收">建议51：不要主动进行垃圾回收</span></h3><p>​    很久很久以前，在java1.1的年代里，我们经常会看到System.gc这样的调用—主动对垃圾进行回收，不过，在Java知识深入人心后，这样的代码就逐渐销声匿迹了—这是好现象，因为主动进行垃圾回收是一个非常危险的动作。</p>
<p>　　之所以危险，是因为System.gc要停止所有的响应，才能检查内存中是否存在可以回收的对象，这对一个应用系统来说风险极大，如果是一个Web应用，所有的请求都会暂停，等待垃圾回收器执行完毕，若此时堆内存(heap)中的对象少的话还可以接受，一但对象较多（现在的web项目是越做越大，框架、工具也越来越多，加载到内存中的对象当然也就更多了），这个过程非常耗时，可能是0.01秒，也可能是1秒，甚至20秒，这就严重影响到业务的运行了。</p>
<p>　　例如：我们写这样一段代码：new String(“abc”)，该对象没有任何引用，对JVM来说就是个垃圾对象。JVM的垃圾回收器线程第一次扫描（扫描时间不确定，在系统不繁忙的时候执行）时给它贴上一个标签，说”你是可以回收的”，第二次扫描时才真正的回收该对象，并释放内存空间，如果我们直接调用System.gc，则是说“嗨，你，那个垃圾回收器过来检查一下有没有垃圾对象，回收一下”。瞧瞧看，程序主动找来垃圾回收器，这意味着正在运行的系统要让出资源，以供垃圾回收器执行，想想看吧，它会把所有的对象都检查一遍，然后处理掉那些垃圾对象。注意哦，是检查每个对象。</p>
<p>　　不要调用System.gc，即使<strong>经常出现内存溢出也不要调用</strong>，内存溢出是可分析的，是可以查找原因的，GC可不是一个好招数。</p>
<h2><span id="第4章-字符串">第4章 字符串</span></h2><p>Although the world is full of suffering, it is full also of the overcoming of it.</p>
<p>虽然世界充满了苦难，但总是能战胜的。——Hellen Keller（海伦·凯勒，美国作家）</p>
<p>​    在Class的班级里，Object班主任问道，“大家知道谁是我们班最受欢迎的同学吗？”大家面面相觑，不解其意，既而交头接耳，窃窃私语，猛然间，所有的目光都投向了String同学，时光仿佛戛然而止，String诧异地左顾右盼，然后羞红了脸，慢慢地低下了头，同时右手缓缓地举起来，直至胳膊完全伸直，形成一个大大“1”字。</p>
<h3><span id="建议52推荐使用string直接量赋值">建议52：推荐使用String直接量赋值</span></h3><p>​    一般对象都是通过new关键字生成的，但是String还有第二种生成方式，也就是我们经常使用的直接声明方式，这种方式是极力推荐的，但不建议使用new String（”A”）的方式赋值。为什么呢？我们看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client52</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String str1 <span class="token operator">=</span> <span class="token string">"詹姆斯"</span><span class="token punctuation">;</span>
        String str2 <span class="token operator">=</span> <span class="token string">"詹姆斯"</span><span class="token punctuation">;</span>
        String str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"詹姆斯"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String str4 <span class="token operator">=</span> str3<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 两个直接量是否相等</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 直接量和对象是否相等</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 经过intern处理后的对象与直接量是否相等</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>注意看上面的程序，我们使用”==”判断的是两个对象的引用地址是否相同，也就是判断是否为同一个对象，打印的结果是true,false,true。即有两个直接量是同一个对象(进过intern处理后的String与直接量是同一个对象)，但直接通过new生成的对象却与之不等，原因何在？</p>
<p>　　原因是Java为了避免在一个系统中大量产生String对象(为什么会大量产生，因为String字符串是程序中最经常使用的类型)，于是就设计了一个字符串池(也叫作字符串常量池，String pool或String Constant Pool或String Literal Pool),在字符串池中容纳的都是String字符串对象，它的创建机制是这样的：创建一个字符串时，首先检查池中是否有字面值相等的字符串，如果有，则不再创建，直接返回池中该对象的引用，若没有则创建之，然后放到池中，并返回新建对象的引用，这个池和我们平常说的池非常接近。对于此例子来说，就是创建第一个”詹姆斯”字符串时，先检查字符串池中有没有该对象，发现没有，于是就创建了”詹姆斯”这个字符串并放到池中，待创建str2字符串时，由于池中已经有了该字符串，于是就直接返回了该对象的引用，此时，str1和str2指向的是同一个地址，所以使用”==”来判断那当然是相等的了。</p>
<p>　　那为什么使用new String(“詹姆斯”)就不相等了呢？因为直接声明一个String对象是不检查字符串池的，也不会把对象放到字符串池中，那当然”==”为false了。</p>
<p>　　那为什么intern方法处理后即又相等了呢？因为intern会检查当前对象在对象池中是否存在字面值相同的引用对象，如果有则返回池中的对象，如果没有则放置到对象池中，并返回当前对象。</p>
<p>　　可能有人要问了，放到池中，是不是要考虑垃圾回收问题呀？不用考虑了，虽然Java的每个对象都保存在堆内存中但是字符串非常特殊，它在编译期已经决定了其存在JVM的常量池(Constant Pool),垃圾回收不会对它进行回收的。</p>
<p>　　通过上面的介绍，我们发现Java在字符串的创建方面确实提供了非常好的机制，利用对象池不仅可以提高效率，同时减少了内存空间的占用，<strong>建议大家在开发中使用直接量赋值方式</strong>，除非必要才建立一个String对象。</p>
<h3><span id="建议53注意方法中传递的参数要求">建议53：注意方法中传递的参数要求</span></h3><p>​    有这样的一个简单需求，写一个方法，实现从原始字符串中删除与之匹配的所有字符串，比如在”好是好”中，删除”好”，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringUtils</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//删除字符串</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">remove</span><span class="token punctuation">(</span>String source<span class="token punctuation">,</span> String sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> source<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>sub<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    StringUtils工具类很简单，它采用了String的replaceAll方法，该方法是做字符串替换的，我们编写一个测试用例，检查remove方法是否正确，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Assert<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestStringUtils</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">assertTrue</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"好是好"</span><span class="token punctuation">,</span><span class="token string">"好"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"是"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assertTrue</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"$是$"</span><span class="token punctuation">,</span><span class="token string">"$"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"是"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    单独运行第一个是绿条，单独运行第二个是红条，为什么第二个（assertTrue(StringUtils.remove(“是是”,”$”).equals(“是”))）不通过呢？</p>
<p>　　问题就出在replaceAll方法上，该方法确实需要传递两个String类型的参数，也确实进行了字符串替换，但是它要求第一个参数是正则表达式，符合正则表达式的字符串才会被替换。对上面的例子来说，第一个测试案例传递进来的是一个字符串”好”，这是一个全匹配查找替换，处理的非常正确，第二个测试案例传递进来的是一个””符号，””符号，””符号在正则表达式中表示的是字符串的结束位置，也就是执行完replaceAll后在字符串结尾的地方加上了空字符串，其结果还是””是””是””，所以测试失败也就再所难免了。问题清楚了，解决方案也就出来了：使用replace方法替换即可，它是replaceAll的方法的简化版，可传递两个String参数，与我们的编码意图是吻合的。</p>
<p>　　大家如果注意看JDK文档，会发现replace(CharSequence target,CharSequence replacement)方法是1.5版本以后才开始提供的， 在此之前如果要对一个字符串进行全体换，只能使用replaceAll方法，不过由于replaceAll方法的第二个参数使用了正则表达式，而且参数类型只要是CharSequence就可以(String的父类)，所以很容易使使用者误解，稍有不慎就会导致严重的替换错误。</p>
<p><strong><font color="red">注意：replaceAll传递的第一个参数是正则表达式</font></strong></p>
<h3><span id="建议54正确使用string-stringbuffer-stringbuilder">建议54：正确使用String、StringBuffer、StringBuilder</span></h3><p>​    CharSequence接口有三个实现类与字符串有关，String、StringBuffer、StringBuilder，虽然它们都与字符串有关，但其处理机制是不同的。</p>
<p>　　String类是不可变的量，也就是创建后就不能再修改了，比如创建了一个”abc”这样的字符串对象，那么它在内存中永远都会是”abc”这样具有固定表面值的一个对象，不能被修改，即使想通过String提供的方法来尝试修改，也是要么创建一个新的字符串对象，要么返回自己，比如：</p>
<pre class=" language-java"><code class="language-java">String  str <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
String str1 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>​    其中str是一个字符串对象，其值是”abc”,通过substring方法又重新生成了一个字符串str1，它的值是”bc”,也就是说str引用的对象一但产生就永远不会变。为什么上面还说有可能不创建对象而返回自己呢？那是因为采用substring(0)就不会创建对象。JVM从字符串池中返回str的引用，也就是自身的引用。</p>
<p>　　StringBuffer是一个可变字符串，它与String一样，在内存中保存的都是一个有序的字符序列(char 类型的数组)，不同点是StringBuffer对象的值是可改变的，例如：</p>
<pre class=" language-java"><code class="language-java">StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>​        有区别，字符串变量s初始化时是 “a” 对象的引用，经过加号计算后，s变量就修改为了 “ab” 的引用，但是初始化的 “a” 对象还没有改变，只是变量s指向了新的引用地址，再看看StringBuffer的对象，它的引用地址虽不变，但值在改变。</p>
<p>　　StringBuffer和StringBuilder基本相同，都是可变字符序列，不同点是：StringBuffer是线程安全的，StringBuilder是线程不安全的，翻翻两者的源代码，就会发现在StringBuffer的方法前都有关键字syschronized,这也是StringBuffer在性能上远远低于StringBuffer的原因。</p>
<p>　　在性能方面，由于String类的操作都是产生String的对象，而StringBuilder和StringBuffer只是一个字符数组的再扩容而已，所以String类的操作要远慢于StringBuffer 和 StringBuilder。</p>
<p>　　弄清楚了三者之间的原理，我们就可以在不同的场景下使用不同的字符序列了：</p>
<ol>
<li>使用String类的场景：在字符串不经常变化的场景中可以使用String类，例如常量的声明、少量的变量运算等；</li>
<li>使用StringBuffer的场景：在频繁进行字符串的运算(如拼接、替换、删除等)，并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等；</li>
<li>使用StringBuilder的场景：在频繁进行字符串的运算(如拼接、替换、删除等)，并且运行在单线程的环境中，则可以考虑使用StringBuilder，如SQL语句的拼接，JSON封装等。</li>
</ol>
<p><strong><font color="red">注意：在适当的场景选用字符串类型</font></strong> </p>
<h3><span id="建议55注意字符串的位置">建议55：注意字符串的位置</span></h3><p>看下面一段程序：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client55</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String str1 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token string">"apples"</span><span class="token punctuation">;</span>
        String str2 <span class="token operator">=</span> <span class="token string">"apples"</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    想想两个字符串输出的结果的苹果数量是否一致，如果一致，会是几呢？</p>
<p>　　答案是不一致，str1的值是”3apples” ,str2的值是“apples12”，这中间悬殊很大，只是把“apples” 调换了一下位置，为何会发生如此大的变化呢？</p>
<p>　　这都源于java对于加号的处理机制：在使用加号进行计算的表达式中，只要遇到String字符串，则所有的数据都会转换为String类型进行拼接，如果是原始数据，则直接拼接，如是是对象，则调用toString方法的返回值然后拼接，如：</p>
<p>　　str = str + new ArrayList();</p>
<p>　　上面就是调用ArrayList对象的toString方法返回值进行拼接的。再回到前面的问题上，对与str1 字符串，Java的执行顺序是从左到右，先执行1+2，也就是算术加法运算，结果等于3，然后再与字符串进行拼接，结果就是 “3 apples”,其它形式类似于如下计算：</p>
<p>　　String str1 = (1 + 2 ) + “apples” ;</p>
<p>　　而对于str2字符串，由于第一个参与运算的是String类型，加1后的结果是“apples 1” ，这仍然是一个字符串，然后再与2相加，结果还是一个字符串，也就是“apples12”。这说明如果第一个参数是String，则后续的所有计算都会转变为String类型，谁让字符串是老大呢！</p>
<p><strong><font color="red">注意： 在“+” 表达式中，String字符串具有最高优先级。</font></strong></p>
<h3><span id="建议56自由选择字符串拼接方法">建议56：自由选择字符串拼接方法</span></h3><p>​    对一个字符串拼接有三种方法：加号、concat方法及StringBuilder（或StringBuffer ,由于StringBuffer的方法与StringBuilder相同，不在赘述）的append方法，其中加号是最常用的，其它两种方式偶尔会出现在一些开源项目中，那这三者之间有什么区别吗？我们看看下面的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client56</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 加号拼接</span>
        String str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> start1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            str <span class="token operator">+=</span> <span class="token string">"c"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> end1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"加号拼接耗时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end1 <span class="token operator">-</span> start1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// concat拼接</span>
        str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> start2 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> end2 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"concat拼接耗时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end2 <span class="token operator">-</span> start2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// StringBuilder拼接</span>
        str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
        StringBuilder buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> start3 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            buffer<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> end3 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"StringBuilder拼接耗时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end3 <span class="token operator">-</span> start3<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// StringBuffer拼接</span>
        str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
        StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> start4 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> end4 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"StringBuffer拼接耗时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end4 <span class="token operator">-</span> start4<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　上面是4种不同方式的字符串拼接方式，循环10万次后检查其执行时间，执行结果如下：</p>
<p>　　<img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160918102703382-1169380682.png" alt="img"></p>
<p>​    从上面的执行结果来看，在字符串拼接方式中,StringBuilder的append方法最快，StringBuffer的append方法次之（因为StringBuffer的append方法是线程安全的，同步方法自然慢一点），其次是concat方法，加号最慢，这是为何呢？</p>
<p>　　(1)、”+” 方法拼接字符串：虽然编辑器对字符串的加号做了优化，它会使用StringBuilder的append方法进行追加，按道理来说，其执行时间也应该是1ms，不过最终是通过toString方法转换为String字符串的，例子中的”+” 拼接的代码如下代码相同　　</p>
<pre class=" language-java"><code class="language-java">str<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　    注意看，它与纯粹使用StringBuilder的append方法是不同的：一是每次循环都会创建一个StringBuilder对象，二是每次执行完毕都要调用toString方法将其转换为字符串——它的执行时间就耗费在这里了！</p>
<p>　　(2)、concat方法拼接字符串：我们从源码上看一下concat方法的实现，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">concat</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> otherLen <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//如果追加字符长度为0，则返回字符串本身</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>otherLen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> len <span class="token operator">+</span> otherLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    str<span class="token punctuation">.</span><span class="token function">getChars</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//产生一个新的字符串</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    其整体看上去就是一个数组拷贝，虽然在内存中处理都是原子性操作，速度非常快，不过，注意看最后的return语句，每次concat操作都会创建一个String对象，这就是concat速度慢下来的真正原因，它创建了10万个String对象呀。</p>
<p>　　(3)、append方法拼接字符串：StringBuilder的append方法直接由父类AbstractStringBuilder实现，其代码如下：</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> StringBuilder <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> AbstractStringBuilder <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//如果是null值，则把null作为字符串处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> null<span class="token punctuation">)</span> str <span class="token operator">=</span> <span class="token string">"null"</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//字符串复制到目标数组</span>
    str<span class="token punctuation">.</span><span class="token function">getChars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> value<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count <span class="token operator">+=</span> len<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    看到没，整个append方法都在做字符数组处理，加长，然后拷贝数组，这些都是基本的数据处理，没有创建任何对象，所以速度也就最快了！注意：例子中是在随后通过StringBuilder的toString方法返回了一个字符串，也就是说在10万次循环结束后才生成了一个String对象。StringBuffer的处理和此类似，只是方法是同步的而已。</p>
<p>　　四者的实现方法不同，性能也就不同，但并不表示我们一定要使用StringBuilder，这是因为”+”非常符合我们的编码习惯，适合阅读，两个字符串拼接，就用加号连一下，这很正常，也很友好，在大多数情况下我们都可以使用加号操作，只有在系统性能临界(如在性能 “ 增长一分则太长” 的情况下)的时候才可以考虑使用concat或append方法。而且，很多时候系统80% 的性能是消耗在20%的代码上的，我们的精力应该更多的投入到算法和结构上。</p>
<p><strong><font color="red">注意：适当的场景使用适当的字符串拼接方式。</font></strong>　</p>
<h3><span id="建议57推荐在复杂字符串操作中使用正则表达式">建议57：推荐在复杂字符串操作中使用正则表达式</span></h3><p>​    字符串的操作，诸如追加、合并、替换、倒叙、分割等，都是在编码过程中经常用到的，而且Java也提供了append、replace、reverse、spit等方法来完成这些操作，它们使用起来确实方便，但是更多时候，需要使用正则表达式来完成复杂的处理，我们来看一个例子：统计一篇文章中英文单词的数量，很简单吧，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client57</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Scanner input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            String str <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 使用split方法分割后统计</span>
            <span class="token keyword">int</span> wordsCount <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">"单词数："</span> <span class="token operator">+</span> wordsCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>使用spit方法根据空格来分割单词，然后计算分割后的数组长度，这种方法可靠吗？我们看看输出结果：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160918111828912-1837316031.png" alt="img"></p>
<p>​    注意看输出，除了第一个输入”Today is Monday”正确外，其它的都是错误的！第二条输入中的单词”Monday”前有2个连续的空格，第三条输入中”No”单词前后都没有空格，最后一个输入则没有把连写符号” ‘ “考虑进去，这样统计出来的单词数量肯定是错误一堆，那怎么做才合理呢？</p>
<p>　　如果考虑使用一个循环来处理这样的”异常”情况，会使程序的稳定性变差，而且要考虑太多太多的因素，这让程序的复杂性也大大提高了。那如何处理呢？可以考虑使用正则表达式，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client57</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Scanner input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            String str <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//正则表达式对象</span>
            Pattern p <span class="token operator">=</span>  Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"\\b\\w+\\b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//生成匹配器</span>
            Matcher matcher <span class="token operator">=</span>p<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> wordsCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                wordsCount<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">"单词数："</span> <span class="token operator">+</span> wordsCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　准不准确，我们看看相同的输入，输出结果如下：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160918123203832-194778012.png" alt="img"></p>
<p>​    每项的输出都是准确的，而且程序也不复杂，先生成一个正则表达式对象，然后使用匹配器进行匹配，之后通过一个while循环统计匹配的数量。需要说明的是，在Java的正则表达式中”\b” 表示的是一个单词的边界，它是一个位置界定符，一边为字符或数字，另外一边为非字符或数字，例如”A”这样一个输入就有两个边界，即单词”A”的左右位置，这也就说明了为什么要加上”\w”（它表示的是字符或数字）。</p>
<p>　　正则表达式在字符串的查找，替换，剪切，复制，删除等方面有着非凡的作用，特别是面对大量的文本字符需要处理（如需要读取大量的LOG日志）时，使用正则表达式可以大幅地提高开发效率和系统性能，但是正则表达式是一个恶魔，它会使程序难以读懂，想想看，写一个包含^、$、\A、\s、\Q、+、？、()、{}、[]等符号的正则表达式，然后再告诉你这是一个” 这样，这样……”字符串查找，你是不是要崩溃了？这个代码确实不好阅读，你就要在正则上多下点功夫了。</p>
<p><strong><font color="red">注意：正则表达式是恶魔，威力巨大，但难以控制。</font></strong></p>
<h3><span id="建议58强烈建议使用utf编码">建议58：强烈建议使用UTF编码</span></h3><p>​    Java的乱码问题由来已久，有经验的开发人员肯定遇到过乱码，有时从Web接收的乱码，有时从数据库中读取的乱码，有时是在外部接口中接收的乱码文件，这些都让我们困惑不已，甚至是痛苦不堪，看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client58</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> UnsupportedEncodingException <span class="token punctuation">{</span>
        String str <span class="token operator">=</span> <span class="token string">"汉字"</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 读取字节</span>
        <span class="token keyword">byte</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 重新生成一个新的字符串</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Java文件是通过IDE工具默认创建的，编码格式是GBK，大家想想看上面的输出结果会是什么？可能是乱码吧？两个编码格式不同。我们暂时不说结果，先解释一下Java中的编码规则。Java程序涉及的编码包括两部分：</p>
<p>　　(1)、<strong>Java文件编码</strong>：如果我们使用记事本创建一个.java后缀的文件，则文件的编码格式就是操作系统默认的格式。如果是使用IDE工具创建的，如Eclipse，则依赖于IDE的设置，Eclipse默认是操作系统编码（Windows一般为GBK）；</p>
<p>　　(2)、<strong>Class文件编码</strong>：通过javac命令生成的后缀名为.class的文件是UTF-8编码的UNICODE文件，这在任何操作系统上都是一样的，只要是.class文件就会使UNICODE格式。需要说明的是，UTF是UNICODE的存储和传输格式，它是为了解决UNICODE的高位占用冗余空间而产生的，使用UTF编码就意味着字符集使用的是UNICODE.</p>
<p>　　再回到我们的例子上，getBytes方法会根据指定的字符集取出字节数组(这里按照UNICODE格式来提取)，然后程序又通过new String(byte [] bytes)重新生成一个字符串，来看看String的这个构造函数：通过操作系统默认的字符集解码指定的byte数组，构造一个新的String，结果已经很清楚了，如果操作系统是UTF-8的话，输出就是正确的，如果不是，则会是乱码。由于这里使用的是默认编码GBK，那么输出的结果也就是乱码了。我们再详细分解一下运行步骤：</p>
<p>　　步骤1：<strong>创建Client58.java文件</strong>：该文件的默认编码格式GBK（如果是Eclipse，则可以在属性中查看到）。</p>
<p>　　步骤2：<strong>编写代码</strong>(如上)；</p>
<p>　　步骤3：<strong>保存，使用javac编译</strong>，注意我们没有使用”javac -encoding GBK Client58.java” 显示声明Java的编码方式，javac会自动按照操作系统的编码(GBK)读取Client58.java文件，然后将其编译成.class文件。</p>
<p>　　步骤4：<strong>生成.class文件</strong>。编译结束，生成.class文件，并保存到硬盘上，此时 .class文件使用的UTF-8格式编码的UNICODE字符集，可以通过javap 命令阅读class文件，其中” 汉字”变量也已经由GBK转变成UNICODE格式了。</p>
<p>　　步骤5：<strong>运行main方法，提取”汉字”的字节数组</strong>。”汉字” 原本是按照UTF-8格式保存的，要再提取出来当然没有任何问题了。</p>
<p>　　步骤6：<strong>重组字符串</strong>，读取操作系统默认的编码GBK，然后重新编码变量b的所有字节。问题就在这里产生了：因为UNICODE的存储格式是两个字节表示一个字符(注意：这里是指UCS-2标准)，虽然GBK也是两个字节表示一个字符，但两者之间没有映射关系，只要做转换只能读取映射表，不能实现自动转换—-于是JVM就按照默认的编码方式(GBK)读取了UNICODE的两个字节。</p>
<p>　　步骤7：<strong>输出乱码，程序运行结束</strong>，问题清楚了，解决方案也随之产生，方案有两个。</p>
<p>　　步骤8：修改代码，明确指定编码即可，代码如下：</p>
<p>　　　　　　System.out.println(new String(b,”UTF-8”));</p>
<p>　　步骤9：修改操作系统的编码方式，各个操作系统的修改方式不同，不再赘述。</p>
<p>　　我们可以把字符串读取字节的过程看做是数据传输的需要(比如网络、存储)，而重组字符串则是业务逻辑的需求，这样就可以是乱码重现：通过JDBC读取的字节数组是GBK的，而业务逻辑编码时采用的是UTF-8，于是乱码就产生了。对于此类问题，最好的解决办法就是使用统一的编码格式，要么都用GBK，要么都用UTF-8，各个组件、接口、逻辑层、都用UTF-8，拒绝独树一帜的情况。</p>
<p>　　　问题清楚了，我么看看以下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client58</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> UnsupportedEncodingException <span class="token punctuation">{</span>
        String str <span class="token operator">=</span> <span class="token string">"汉字"</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 读取字节</span>
        <span class="token keyword">byte</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"GB2312"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 重新生成一个新的字符串</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    仅仅修改了读取字节的编码方式(修改成了GB2312)，结果会怎样呢？又或者将其修改成GB18030，结果又是怎样的呢？结果都是”汉字”，不是乱码。这是因为GB2312是中文字符集的V1.0版本，GBK是V2.0版本，GB18030是V3.0版本，版本是向下兼容的，只是它们包含的汉字数量不同而已，注意UNICODE可不在这个序列之内。</p>
<p><strong><font color="red">注意：一个系统使用统一的编码。</font></strong></p>
<h3><span id="建议59对字符串持有一种宽容的心态">建议59：对字符串持有一种宽容的心态</span></h3><p>在Java 中一涉及中文处理就会冒出很多问题来，其中排序也是一个让人头疼的课题，我们看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client59</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"张三(Z)"</span><span class="token punctuation">,</span> <span class="token string">"李四(L)"</span><span class="token punctuation">,</span> <span class="token string">"王五(W)"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"、"</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    上面的代码定义了一个数组，然后进行升序排序，我们期望的结果是按照拼音升序排列，即为李四、王五、张三，但是结果却不是这样的：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160918133303090-1239977501.png" alt="img"></p>
<p>　这是按照什么排的序呀，非常混乱!我们知道Arrays工具类的默认排序是通过数组元素的compareTo方法进行比较的，那我们来看String类的compareTo的主要实现：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>String anotherString<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> len1 <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len2 <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> lim <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>

    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> lim<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span> c1 <span class="token operator">=</span> v1<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span> c2 <span class="token operator">=</span> v2<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c1 <span class="token operator">!=</span> c2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> c1 <span class="token operator">-</span> c2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> len1 <span class="token operator">-</span> len2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    上面的代码先取得字符串的字符数组，然后一个一个地比较大小，注意这里是字符比较(减号操作符)，也就是UNICODE码值比较，查一下UNICODE代码表，”张” 的码值是5F20，”李”是674E,这样一看，”张” 排在 “李” 前面也就很正确了—但这明显与我们的意图冲突了。这一点在JDK的文档中也有说明：对于非英文的String排序可能会出现不准确的情况，那该如何解决这个问题呢？Java推荐使用collator类进行排序，那好，我们把代码修改一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client59</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"张三(Z)"</span><span class="token punctuation">,</span> <span class="token string">"李四(L)"</span><span class="token punctuation">,</span> <span class="token string">"王五(W)"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//定义一个中文排序器</span>
        Comparator c <span class="token operator">=</span> Collator<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>CHINA<span class="token punctuation">)</span><span class="token punctuation">;</span>    
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"、"</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>输出结果：</p>
<p>　　　　<strong>1、李四(L)</strong><br>　　　　<strong>2、王五(W)</strong><br>　　　　<strong>3、张三(Z)</strong></p>
<p>​    这确实是我们期望的结果，应该不会错了吧！但是且慢，中国的汉字博大精深，Java是否都能精确的排序呢？最主要的一点是汉字中有象形文字，音形分离，是不是每个汉字都能按照拼音的顺序排好呢？我们写一个复杂的汉字来看看：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client59</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"犇(B)"</span><span class="token punctuation">,</span> <span class="token string">"鑫(X)"</span><span class="token punctuation">,</span> <span class="token string">"淼(M)"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//定义一个中文排序器</span>
        Comparator c <span class="token operator">=</span> Collator<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>CHINA<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"、"</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>输出结果如下：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160918134915642-243256239.png" alt="img"></p>
<p>​    输出结果又乱了，不要责怪Java，它们已尽量为我们考虑了，只是因为我们的汉字文化太博大精深了，要做好这个排序确实有点为难它，更深层次的原因是Java使用的是UNICODE编码，而中文UNICODE字符集来源于GB18030的,GB18030又是从GB2312发展起来，GB2312是一个包含了7000多个字符的字符集，它是按照拼音排序，并且是连续的，之后的GBK、GB18030都是在其基础上扩充而来的，所以要让它们完整的排序也就难上加难了。</p>
<p>　　如果排序对象是经常使用的汉字，使用Collator类排序完全可以满足我们的要求，毕竟GB2312已经包含了大部分的汉字，如果需要严格排序，则要使用一些开源项目来自己实现了，比如pinyin4j可以把汉字转换为拼音，然后我们自己来实现排序算法，不过此时你会发现要考虑的诸如算法、同音字、多音字等众多问题。</p>
<p><strong><font color="red">注意：如果排序不是一个关键算法，使用Collator类即可。</font></strong></p>
<h2><span id="第5章-数组和集合">第5章 数组和集合</span></h2><p>噢，他明白了，河水既没有牛伯伯说的那么浅，也没有小松鼠说的那么深，只有自己亲自试过才知道。——寓言故事《小马过河》</p>
<p>​    数据集处理是每种语言必备的功能，Java更甚之，数据集可以允许重复，也可以不允许重复，可以允许null存在，也可以不允许null存在，可以自动排序，也可以不自动排序，可以是阻塞式的，也可以是非阻塞式的，可以是栈，也可以是队列……本章将围绕我们使用最多的三个数据集合（数组、ArrayList和HashMap）来阐述在开发过程中要注意的事项，并由此延伸至Set、Queue、Stack等集合。</p>
<h3><span id="建议60性能考虑数组是首选">建议60：性能考虑，数组是首选</span></h3><p>​    数组在实际的系统开发中用的越来越少了，我们通常只有在阅读一些开源项目时才会看到它们的身影，在Java中它确实没有List、Set、Map这些集合类用起来方便，但是在基本类型处理方面，数组还是占优势的，而且集合类的底层也都是通过数组实现的，比如对一数据集求和这样的计算：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//对数组求和</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> datas<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> datas<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> datas<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    对一个int类型 的数组求和，取出所有数组元素并相加，此算法中如果是基本类型则使用数组效率是最高的，使用集合则效率次之。再看使用List求和：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对列表求和计算</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> datas<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> datas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> datas<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>​    注意看sum += datas.get(i);这行代码，这里其实已经做了一个拆箱动作，Integer对象通过intValue方法自动转换成了一个int基本类型，对于性能濒于临界的系统来说该方案是比较危险的，特别是大数量的时候，首先，在初始化List数组时要进行装箱操作，把一个int类型包装成一个Integer对象，虽然有整型池在，但不在整型池范围内的都会产生一个新的Integer对象，而且众所周知，基本类型是在栈内存中操作的，而对象是堆内存中操作的，栈内存的特点是：速度快，容量小；堆内存的特点是：速度慢，容量大（从性能上讲，基本类型的处理占优势）。其次，在进行求和运算时(或者其它遍历计算)时要做拆箱动作，因此无谓的性能消耗也就产生了。在实际测试中发现：对基本类型进行求和运算时，数组的效率是集合的10倍。</p>
<p><strong><font color="red">注意：性能要求较高的场景中使用数组代替集合。</font></strong></p>
<h3><span id="建议61若有必要使用变长数组">建议61：若有必要，使用变长数组</span></h3><p>​    Java中的数组是定长的，一旦经过初始化声明就不可改变长度，这在实际使用中非常不方便，比如要对班级学生的信息进行统计，因为我们不知道一个班级会有多少学生(随时都可能会有学生入学、退学或转学)，所以需要一个足够大的数组来容纳所有的学生，但问题是多大才算足够大？20年前一台台式机64MB的内存已经很牛了，现在要是没有8GB的内存(现在这个都太小了)你都不好意思跟别人交流计算机的配置，所以呀，这个足够大是相对于当时的场景而言的，随着环境的变化，”足够大”也可能会转变成”足够小”，然后就会出现超出数组最大容量的情况，那该如何解决呢？事实上，可以通过对数组扩容”婉转” 地解决该问题，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">expandCapacity</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> datas<span class="token punctuation">,</span> <span class="token keyword">int</span> newLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 不能是负值</span>
    newLen <span class="token operator">=</span> newLen <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> newLen<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 生成一个新数组,并拷贝原值</span>
    <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>datas<span class="token punctuation">,</span> newLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    上述代码采用的是Arrays数组工具类的copyOf方法，产生了一个newLen长度的新数组，并把原有的值拷贝了进去，之后就可以对超长的元素进行赋值了(依据类型的不同分别赋值0、false或null)，使用方法如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client61</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//一个班级最多容纳60个学生</span>
        Stu <span class="token punctuation">[</span><span class="token punctuation">]</span> stuNums<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stu</span><span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//stuNums初始化......</span>
        <span class="token comment" spellcheck="true">//偶尔一个班级可以容纳80人，数组加长</span>
        stuNums<span class="token operator">=</span><span class="token function">expandCapacity</span><span class="token punctuation">(</span>stuNums<span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/* 重新初始化超过限额的20人...... */</span>
        
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">expandCapacity</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> datas<span class="token punctuation">,</span> <span class="token keyword">int</span> newLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 不能是负值</span>
        newLen <span class="token operator">=</span> newLen <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> newLen<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 生成一个新数组,并拷贝原值</span>
        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>datas<span class="token punctuation">,</span> newLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Stu</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
</code></pre>
<p>​    通过这样的处理方式，曲折的解决了数组的变长问题，其实，集合的长度自动维护功能的原理与此类似。在实际开发中，如果确实需要变长的数据集，数组也是在考虑范围之内的，不能因固定长度而将其否定之。</p>
<h3><span id="建议62警惕数组的浅拷贝">建议62：警惕数组的浅拷贝</span></h3><p>​    有这样一个例子，第一个箱子里有赤橙黄绿青蓝紫7色气球，现在希望在第二个箱子中也放入7个气球，其中最后一个气球改为蓝色，也就是赤橙黄绿青蓝蓝7个气球，那我们很容易就会想到第二个箱子中的气球可以通过拷贝第一个箱子中的气球来实现，毕竟有6个气球是一样的嘛，来看实现代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>builder<span class="token punctuation">.</span>ToStringBuilder<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client62</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 气球数量</span>
        <span class="token keyword">int</span> ballonNum <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 第一个箱子</span>
        Balloon<span class="token punctuation">[</span><span class="token punctuation">]</span> box1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Balloon</span><span class="token punctuation">[</span>ballonNum<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 初始化第一个箱子中的气球</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ballonNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            box1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Balloon</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 第二个箱子的气球是拷贝第一个箱子里的</span>
        Balloon<span class="token punctuation">[</span><span class="token punctuation">]</span> box2 <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>box1<span class="token punctuation">,</span> box1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 修改最后一个气球颜色</span>
        box2<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>Blue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 打印出第一个箱子中的气球颜色</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Balloon b <span class="token operator">:</span> box1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 气球颜色</span>
<span class="token keyword">enum</span> Color <span class="token punctuation">{</span>
    Red<span class="token punctuation">,</span> Orange<span class="token punctuation">,</span> Yellow<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Indigo<span class="token punctuation">,</span> Blue<span class="token punctuation">,</span> Violet
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 气球</span>
<span class="token keyword">class</span> <span class="token class-name">Balloon</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 编号</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 颜色</span>
    <span class="token keyword">private</span> Color color<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Balloon</span><span class="token punctuation">(</span>Color _color<span class="token punctuation">,</span> <span class="token keyword">int</span> _id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        color <span class="token operator">=</span> _color<span class="token punctuation">;</span>
        id <span class="token operator">=</span> _id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> Color <span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> color<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColor</span><span class="token punctuation">(</span>Color color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//apache-common-lang包下的ToStringBuilder重写toString方法</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ToStringBuilder</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"编号"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"颜色"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>​    第二个箱子里最后一个气球的颜色毫无疑问是被修改为蓝色了，不过我们是通过拷贝第一个箱子里的气球然后再修改的方式来实现的，那会对第一个箱子的气球颜色有影响吗？我们看看输出结果：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160918231713713-622853231.png" alt="img"></p>
<p>​        最后一个气球颜色竟然也被修改了，我们只是希望修改第二个箱子的气球啊，这是为何？这是典型的浅拷贝(Shallow  Clone)问题，以前第一章序列化时讲过，但是这里与之有一点不同：数组中的元素没有实现Serializable接口。</p>
<p>　　确实如此，通过copyOf方法产生的数组是一个浅拷贝，这与序列化的浅拷贝完全相同：基本类型是直接拷贝值，其它都是拷贝引用地址。需要说明的是，数组的clone方法也是与此相同的，同样是浅拷贝，而且集合的clone方法也都是浅拷贝，这就需要大家在拷贝时多留心了。</p>
<p>　　问题找到了，解决办法也很简单，遍历box1的每个元素，重新生成一个气球(Balloon)对象，并放置到box2数组中，代码比较简单，不再赘述。</p>
<p>　　该方法用的最多的地方是在使用集合(如List),进行业务处理时，比如发觉需要拷贝集合中的元素，可集合没有提供拷贝方法，如果自己写会很麻烦，所以干脆使用List.toArray方法转换成数组，然后通过Arrays.copyOf拷贝，再转换回集合，简单便捷！但是，非常遗憾的是，这里我们又撞到浅拷贝的枪口上了，虽然很多时候浅拷贝可以解决业务问题，但更多时候会留下隐患，我们需要提防又提防。</p>
<h3><span id="建议63在明确的场景下为集合指定初始容量">建议63：在明确的场景下，为集合指定初始容量</span></h3><p>​        我们经常使用ArrayList、Vector、HashMap等集合，一般都是直接用new跟上类名声明出一个集合来，然后使用add、remove等方法进行操作，而且因为它是自动管理长度的，所以不用我们特别费心超长的问题，这确实是一个非常好的优点，但也有我们必须要注意的事项。</p>
<p>　　下面以ArrayList为例深入了解一下Java是如何实现长度的动态管理的，先从add方法的阅读开始，代码（JDK7）如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//扩展长度</span>
    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>
    <span class="token comment" spellcheck="true">//追加元素</span>
    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　我们知道ArrayList是一个大小可变的数组，但它在底层使用的是数组存储(也就是elementData变量)，而且数组长度是定长的，要实现动态长度必然要进行长度的扩展，ensureCapacityInternal方法提供了此功能，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//修改计数器</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// overflow-conscious code</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// overflow-conscious code</span>
    <span class="token comment" spellcheck="true">//上次(原始)定义的数组长度</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//新长度为原始长度+原始长度右移一位 ==>原始长度的1.5倍</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>
    <span class="token comment" spellcheck="true">//数组拷贝，生成新数组</span>
    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>
        Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>
    MAX_ARRAY_SIZE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    大概分析一下这些源码，这个源码还是JDK7之前的版本上做了优化处理的。先说一下第一个方法ensureCapacityIntenal， 方法名的英文大致意思是“确保内部容量”，这里要说明，size表示的是现有的元素个数，并非ArrayList的容量，容量应该是数组 elementData的长度。参数minCapacity是需要检查的最小容量，即方法的功能就是确保elementData的长度不小于 minCapacity，如果不够，则调用grow增加容量。容量的增长也算结构性变动，所以modCount需要加1。</p>
<p>　　grow方法：先对容量扩大1.5倍，这里oldCapacity &gt;&gt; 1是二进制操作右移，相当于除以2，如果不知道这个面壁去吧。接再来把新的临时容量（还没正式改变容量，应该叫预期容量）和实际需要的最小容量比较，如果还不满 足，则把临时容量改成需要的最小容量值。在判断容量是否超过MAX_ARRAY_SIZE的值，MAX_ARRAY_SIZE值为 Integer.MAX_VALUE - 8，比int的最大值小8，不知道设计初衷是什么，可能方便判断吧。如果已经超过，调用hugeCapacity方法检查容量的int值是不是已经溢出。一般很 少用到int最大值的情况，那么多数据也不会用ArrayList来做容器了，估计没机会见到hugeCapacity运行一次了。最后确定了新的容量，就使用Arrays.copyOf方法来生成新的数组，copyOf也已经完成了将就的数据拷贝到新数组的工作。</p>
<p>　　回归正题，大家注意看数组长度的计算方法，并不是增加一个元素，elementData的长度就加1，而是在达到elementData长度的临界点时，才将elementData扩容1.5倍，这样实现避免了多次copyOf方法的性能开销，否则每增加一个元素都要扩容一次，那性能会更差。不知道大家有没有这样一个疑问，为啥要扩容1.5倍，而不是2.5,倍、3.5倍呢？其实我也这么想过，原因是一次扩容太大，占用的内存就越大，浪费的内存也就越多(1.5倍扩容，最多浪费33%的数组空间，而2.5倍则最多消耗60%的内存)，而一次扩容太小，则需要多次对数组重新分配内存，性能消耗严重，经过测试验证，扩容1.5倍既满足了性能要求，也减少了内存消耗。</p>
<p>　　现在我们知道了ArrayList的扩容原则，那还有一个问题：elementData的默认长度是多少呢？答案是10，如果我们使用默认方式声明ArrayList，如new ArrayList(),则elementData的初始长度是10，我们看看ArrayList的三个构造函数。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//无参构造</span>
<span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//构造一个具有指定初始容量的空列表。</span>
<span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>
                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的</span>
<span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　ArrayList()：默认构造函数，提供初始容量为10的空列表。</p>
<p>   ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。</p>
<p>   ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</p>
<p> 　从这里我们可以看出，如果不设置初始容量，系统会按照1.5倍的规则扩容，每次扩容都是一次数组的拷贝，如果数据量大，这样的拷贝会非常消耗资源，而且效率非常低下。所以，我们如果知道一个ArrayList的可能长度，然后对ArrayList设置一个初始容量则可以显著提高系统性能。</p>
<p>　　其它的集合如Vector和ArrayList类似，只是扩容的倍数不同而已，Vector扩容2倍，大家有兴趣的话可以看看Vector，HashMap的JDK源码。</p>
<h3><span id="建议64多种最值算法适时选择">建议64：多种最值算法，适时选择</span></h3><p>对一批数据进行排序，然后找出其中的最大值或最小值，这是基本的数据结构知识。在Java中我们可以通过编写算法的方式，也可以通过数组先排序再取值的方式来实现，下面以求最大值为例，解释一下多种算法：</p>
<p>　　(1)、自行实现，快速查找最大值　　</p>
<p>　　先看看用快速查找法取最大值的算法，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        max <span class="token operator">=</span> max <span class="token operator">></span> i <span class="token operator">?</span> max <span class="token operator">:</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> max<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        这是我们经常使用的最大值算法，也是速度最快的算法。它不要求排序，只要遍历一遍数组即可找出最大值。</p>
<p>　　(2)、先排序，后取值</p>
<p>　　对于求最大值，也可以采用先排序后取值的方式，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> data<span class="token punctuation">[</span>data<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    从效率上讲，当然是自己写快速查找法更快一些了，只用遍历一遍就可以计算出最大值，但在实际测试中发现，如果数组量少于10000，两个基本上没有区别，但在同一个毫秒级别里，此时就可以不用自己写算法了，直接使用数组先排序后取值的方式。</p>
<p>　　如果数组元素超过10000，就需要依据实际情况来考虑：自己实现，可以提高性能；先排序后取值，简单，通俗易懂。排除性能上的差异，两者都可以选择，甚至后者更方便一些，也更容易想到。</p>
<p>　　现在问题来了，在代码中为什么先使用data.clone拷贝再排序呢？那是因为数组也是一个对象，不拷贝就改变了原有的数组元素的顺序吗？除非数组元素的顺序无关紧要。那如果要查找仅次于最大值的元素(也就是老二)，该如何处理呢？要注意，数组的元素时可以重复的，最大值可能是多个，所以单单一个排序然后取倒数第二个元素时解决不了问题的。</p>
<p>　　此时，就需要一个特殊的排序算法了，先要剔除重复数据，然后再排序，当然，自己写算法也可以实现，但是集合类已经提供了非常好的方法，要是再使用自己写算法就显得有点重复造轮子了。数组不能剔除重复数据，但Set集合却是可以的，而且Set的子类TreeSet还能自动排序，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getSecond</span><span class="token punctuation">(</span>Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//转换为列表</span>
    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> dataList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//转换为TreeSet，剔除重复元素并升序排列</span>
    TreeSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>dataList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//取得比最大值小的最大值，也就是老二了</span>
    <span class="token keyword">return</span> ts<span class="token punctuation">.</span><span class="token function">lower</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span><span class="token function">last</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　    剔除重复元素并升序排列，这都是由TreeSet类实现的，然后可再使用lower方法寻找小于最大值的值，大家看，上面的程序非常简单吧?那如果是我们自己编写代码会怎么样呢？那至少要遍历数组两遍才能计算出老二的值，代码复杂度将大大提升。因此在实际应用中求最值，包括最大值、最小值、倒数第二小值等，使用集合是最简单的方式，当然从性能方面来考虑，数组才是最好的选择。</p>
<p><strong><font color="red">注意：最值计算时使用集合最简单，使用数组性能最优。</font></strong></p>
<h3><span id="建议65避开基本类型数组转换列表陷阱">建议65：避开基本类型数组转换列表陷阱</span></h3><p>​        我们在开发中经常会使用Arrays和Collections这两个工具类和列表之间转换，非常方便，但也有时候会出现一些奇怪的问题，来看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client65</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> data <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        List list<span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中的元素数量是："</span><span class="token operator">+</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        也许你会说，这很简单，list变量的元素数量当然是5了。但是运行后打印出来的列表数量为1。</p>
<p>　　事实上data确实是一个有5个元素的int类型数组，只是通过asList转换成列表后就只有一个元素了，这是为什么呢？其他4个元素到什么地方去了呢？</p>
<p>　　我们仔细看一下Arrays.asList的方法说明：输入一个变长参数，返回一个固定长度的列表。注意这里是一个变长参数，看源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">asList</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        asList方法输入的是一个泛型变长参数，我们知道基本类型是不能泛型化的，也就是说8个基本类型不能作为泛型参数，要想作为泛型参数就必须使用其所对应的包装类型，那前面的例子传递了一个int类型的数组，为何程序没有报编译错误呢？</p>
<p>　　在Java中，数组是一个对象，它是可以泛型化的，也就是说我们的例子是把一个int类型的数组作为了T的类型，所以在转换后在List中就只有一个类型为int数组的元素了，我们打印出来看看，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client65</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> data <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        List list<span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"元素类型是："</span><span class="token operator">+</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"前后是否相等："</span><span class="token operator">+</span>data<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        输出的结果是： <strong>元素类型是：class [I  前后是否相等：true</strong></p>
<p>　　很明显，放在列表中的元素时一个int数组，可能有人要问了，为什么”元素类型:”后的class是”[I”？我们并没有指明是数组(Array)类型呀！这是因为JVM不可能输出Array类型，因为Array是属于java.lang.reflect包的，它是通过反射访问数组元素的工具类。在Java中任何一个一维数组的类型都是 “ [I “ ,究其原因就是Java并没有定义数组这一个类，它是在编译器编译的时候生成的，是一个特殊的类，在JDK的帮助中也没有任何数组类的信息。</p>
<p>　　弄清楚了问题，修改也很easy，直接使用包装类即可，部分代码如下：　</p>
<pre class=" language-java"><code class="language-java">Integer data <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>　把int替换为Integer即可让输出元素数量为5.需要说明的是，不仅仅是int类型的数组有这个问题，其它7个基本类型的数组也存在相似的问题，这就需要大家注意了，在把基本类型数组转换为列表时，要特别小心asList方法的陷阱，避免出现程序逻辑混乱的情况。</p>
<p>　　<strong><font color="red">注意：原始类型数组不能作为asList的输入参数，否则会引起程序逻辑混乱。</font></strong></p>
<h3><span id="建议66aslist方法产生的list的对象不可更改">建议66：asList方法产生的List的对象不可更改</span></h3><p>​        上一个建议指出了asList方法在转换基本类型数组时存在的问题，接着我们看一下asList方法返回的列表有何特殊的地方，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client66</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 五天工作制</span>
        Week days<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> Week<span class="token punctuation">.</span>Mon<span class="token punctuation">,</span> Week<span class="token punctuation">.</span>Tue<span class="token punctuation">,</span> Week<span class="token punctuation">.</span>Wed<span class="token punctuation">,</span> Week<span class="token punctuation">.</span>Thu<span class="token punctuation">,</span> Week<span class="token punctuation">.</span>Fri <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 转换为列表</span>
        List<span class="token operator">&lt;</span>Week<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>days<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 增加周六为工作日</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Week<span class="token punctuation">.</span>Sat<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/* do something */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">enum</span> Week <span class="token punctuation">{</span>
    Sun<span class="token punctuation">,</span> Mon<span class="token punctuation">,</span> Tue<span class="token punctuation">,</span> Wed<span class="token punctuation">,</span> Thu<span class="token punctuation">,</span> Fri<span class="token punctuation">,</span> Sat
<span class="token punctuation">}</span>
</code></pre>
<p>　    很简单的程序呀，默认声明的工作日(workDays)是从周一到周五，偶尔周六也会算作工作日加入到工作日列表中，不过，这段程序执行时会不会有什么问题呢？编译没有任何问题，但是一运行，却出现了如下结果：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160920103326168-62484581.png" alt="img"></p>
<p>UnsupportedOperationException,不支持的操作，居然不支持list的add方法，这是什么原因呢？我们看看asList方法的源代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">asList</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        直接new了一个ArrayList对象返回，难道ArrayList不支持add方法，不可能呀！可能，问题就出现在这个ArrayList类上，此ArrayList<strong>非java.util.ArrayList</strong>，而是Arrays工具类的一个<strong>内部类</strong>，其构造函数如下所示：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>
    <span class="token keyword">implements</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>2764017481108945198L<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> E<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>

    <span class="token function">ArrayList</span><span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token operator">==</span>null<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a <span class="token operator">=</span> array<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/*其它方法略*/</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        这个ArrayList是一个静态私有内部类，除了Arrays能访问外，其它类都不能访问，仔细看这个类，它没有提供add方法，那肯定是父类AbstractList提供了，来看代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　父类确实提供了，但没有提供具体的实现，所以每个子类都需要自己覆写add方法，而Arrays的内部类ArrayList没有覆写，因此add一个元素就报错了。</p>
<p>　　我们深入地看看这个ArrayList静态内部类，它仅仅实现了5个方法：</p>
<ol>
<li>size：元素数量</li>
<li>get：获得制定元素</li>
<li>set：重置某一元素值</li>
<li>contains：是否包含某元素</li>
<li>toArray：转化为数组，实现了数组的浅拷贝</li>
</ol>
<p>　　把这几个方法的源代码展示一下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//元素数量</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//转化为数组，实现了数组的浅拷贝</span>
<span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>
        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> size<span class="token punctuation">,</span>
                             <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">)</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">></span> size<span class="token punctuation">)</span>
        a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//获得指定元素</span>
<span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//重置某一元素</span>
<span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    E oldValue <span class="token operator">=</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    a<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//是否包含元素</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        对于我们经常使用list.add和list.remove方法它都没有实现，也就是说asList返回的是一个长度不可变的列表，数组是多长，转换成的列表也就是多长，<strong>换句话说此处的列表只是数组的一个外壳，不再保持列表的动态变长的特性</strong>，这才是我们关注的重点。有些开发人员喜欢这样定义个初始化列表：　</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> names<span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span><span class="token string">"李四"</span><span class="token punctuation">,</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>​        一句话完成了列表的定义和初始化，看似很便捷，却隐藏着重大隐患—列表长度无法修改。想想看，如果这样一个List传递到一个允许添加的add操作的方法中，那将会产生何种结果，如果有这种习惯的javaer，请慎之戒之，除非非常自信该List只用于只读操作。</p>
<h3><span id="建议67不同的列表选择不同的遍历算法">建议67：不同的列表选择不同的遍历算法</span></h3><p>​        我们思考这样一个案例：统计一个省的各科高考平均值，比如数学平均分是多少，语文平均分是多少等，这是每年招生办都会公布的数据，我们来想想看该算法应如何实现。当然使用数据库中的一个SQL语句就可能求出平均值，不过这不再我们的考虑之列，这里还是使用纯Java的算法来解决之，看代码：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client67</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 学生数量 80万</span>
        <span class="token keyword">int</span> stuNum <span class="token operator">=</span> <span class="token number">80</span> <span class="token operator">*</span> <span class="token number">10000</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// List集合，记录所有学生的分数</span>
        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> scores <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>stuNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 写入分数</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> stuNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            scores<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 记录开始计算 时间</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"平均分是："</span> <span class="token operator">+</span> <span class="token function">average</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时间："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">average</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> scores<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 遍历求和</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> scores<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum <span class="token operator">/</span> scores<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    把80万名学生的成绩放到一个ArrayList数组中，然后通过foreach方法遍历求和，再计算平均值，程序很简单，输出结果：</p>
<p>　<strong>平均分是：74</strong><br>    <strong>执行时间：11ms</strong></p>
<p>　　仅仅计算一个算术平均值就花了11ms，不要说什么其它诸如加权平均值，补充平均值等算法，那花的时间肯定更长。我们仔细分析一下average方法，加号操作是最基本的，没有什么可以优化的，剩下的就是一个遍历了，问题是List的遍历可以优化吗？</p>
<p>　　我们尝试一下，List的遍历还有另外一种方式，即通过下标方式来访问，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">average</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> scores<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 遍历求和</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> scores<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> scores<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum <span class="token operator">/</span> scores<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        不再使用foreach遍历，而是采用下标方式遍历，我们看看输出结果：</p>
<p>　　 <strong>平均分是：74</strong><br>        <strong>执行时间：8ms</strong><br>　　执行时间已经下降，如果数据量更大，会更明显。那为什么我们使用下标方式遍历数组可以提高的性能呢？</p>
<p>　　这是因为ArrayList数组实现了RandomAccess接口(随机存取接口)，这样标志着ArrayList是一个可以随机存取的列表。在Java中，RandomAccess和Cloneable、Serializable一样，都是标志性接口，不需要任何实现，只是用来表明其实现类具有某种特质的，实现了Cloneable表明可以被拷贝，实现了Serializable接口表明被序列化了，实现了RandomAccess接口则表明这个类可以随机存取，对我们的ArrayList来说也就标志着其数据元素之间没有关联，即两个位置相邻的元素之间没有相互依赖和索引关系，可以随机访问和存取。我们知道，Java的foreach语法时iterator（迭代器）的变形用法，也就是说上面的foreach与下面的代码等价：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> i <span class="token operator">=</span> scores<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        那我们再想想什么是迭代器，迭代器是23中设计模式中的一种，”提供一种方法访问一个容器对象中的各个元素，同时又无须暴露该对象的内部细节”，也就是说对于ArrayList，需要先创建一个迭代器容器，然后屏蔽内部遍历细节，对外提供hasNext、next等方法。问题是ArrayList实现RandomAccess接口，表明元素之间本来没有关系，可是，为了使用迭代器就需要强制建立一种相互”知晓”的关系，比如上一个元素可以判断是否有下一个元素，以及下一个元素时什么等关系，这也就是foreach遍历耗时的原因。</p>
<p>　　Java的ArrayList类加上了RandomAccess接口，就是在告诉我们，“ArrayList是随机存取的，采用下标方式遍历列表速度回更快”，接着又有一个问题，为什么不把RandomAccess接口加到所有List的实现类上呢？</p>
<p>　　那是因为有些List的实现类不是随机存取的，而是有序存取的，比如LinkedList类，LinkedList类也是一个列表，但它实现了双向链表，每个数据节点都有三个数据项：前节点的引用(Previous Node)、本节点元素(Node Element)、后继结点的引用(Next Node)，这是数据结构的基本知识，不多讲了，也就是说在LinkedList中的两个元素本来就是有关联的，我知道你的存在，你也知道我的存在。那大家想想看，元素之间已经有关联了，使用foreach也就是迭代器方式是不是效率更高呢？我们修改一下例子，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 学生数量 80万</span>
    <span class="token keyword">int</span> stuNum <span class="token operator">=</span> <span class="token number">80</span> <span class="token operator">*</span> <span class="token number">10000</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// List集合，记录所有学生的分数</span>
    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> scores <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 写入分数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> stuNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        scores<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 记录开始计算 时间</span>
    <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"平均分是："</span> <span class="token operator">+</span> <span class="token function">average</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时间："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">average</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> scores<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 遍历求和</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> scores<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum <span class="token operator">/</span> scores<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        输出结果为： <strong>平均分是：74</strong> <strong>执行时间：12ms 。执行效率还好。但是比ArrayList就慢了，但如果LinkedList采用下标方式遍历：效率会如何呢？我告诉你会很慢。直接分析一下源码：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>由node方法查找指定下标的节点，然后返回其包含的元素，看node方法：</p>
<pre class=" language-java"><code class="language-java">Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// assert isElementIndex(index);</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        看懂了吗？程序会先判断输入的下标与中间值(size右移一位，也就是除以2了)的关系，小于中间值则从头开始正向搜索，大于中间值则从尾节点反向搜索，想想看，每一次的get方法都是一个遍历，”性能”两字从何说去呢？　　</p>
<p>　　明白了随机存取列表和有序存取列表的区别，我们的average方法就必须重构了，以便实现不同的列表采用不同的遍历方式，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">average</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> scores<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>scores <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 可以随机存取，则使用下标遍历</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> scores<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> scores<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 有序存取，使用foreach方式</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> scores<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum <span class="token operator">/</span> scores<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    如此一来，列表的遍历就可以”以不变应万变”了，无论是随机存取列表还是有序列表，它都可以提供快速的遍历。</p>
<p><strong><font color="red">注意：列表遍历不是那么简单的，适时选择最优的遍历方式，不要固化为一种。</font></strong></p>
<h3><span id="建议68频繁插入和删除时使用linkedlist">建议68：频繁插入和删除时使用LinkedList</span></h3><p>​        上一个建议介绍了列表的遍历方式，也就是“读” 操作，本建议将介绍列表的”写”操作：即插入、删除、修改动作。</p>
<p>　　(1)、插入元素：列表中我们使用最多的是ArrayList，下面来看看它的插入(add方法)算法，源代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//检查下标是否越界</span>
    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//若需要扩容，则增大底层数组的长度</span>
    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>
    <span class="token comment" spellcheck="true">//给index下标之后的元素(包括当前元素)的下标加1，空出index位置</span>
    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
                     size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//赋值index位置元素</span>
    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//列表长度加1</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        注意看arrayCopy方法，只要插入一个元素，其后的元素就会向后移动一位，虽然arrayCopy是一个本地方法，效率非常高，但频繁的插入，每次后面的元素都要拷贝一遍，效率就更低了，特别是在头位置插入元素时，现在的问题是，开发中确实会遇到要插入的元素的情况，哪有什么更好的方法解决此效率问题吗？</p>
<p>　　有，使用LinkedList即可。我么知道LinkedList是一个双向列表，它的插入只是修改了相邻元素的next和previous引用，其插入算法(add方法)如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>
        <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>
        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">linkBefore</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> succ<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// assert succ != null;</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>
    succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span>
        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        这个方法，第一步检查是否越界，下来判断插入元素的位置与列表的长度比较，如果相等，调用linkLast，否则调用linkBefore方法。但这两个方法的共同点都是双向链表插入算法，把自己插入到链表，然后再把前节点的next和后节点的previous指向自己。想想看，这样插入一个元素的过程中，没有任何元素会有拷贝过程，只是引用地址变了，那效率自然就高了。</p>
<p>​    　(2)、删除元素：插入了解清楚了，我们再来看看删除动作。ArrayList提供了删除指定位置上的元素，删除指定元素，删除一个下标范围内的元素集等删除动作。三者的实现原理基本相似，都是找索引位置，然后删除。我们以最常用的删除指定下标的方法（remove方法）为例来看看删除动作的性能到底如何，源码如下：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//下标校验</span>
    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//修改计数器加1</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//记录要删除的元素</span>
    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//有多少个元素向前移动</span>
    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">//index后的元素向前移动一位</span>
        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>
                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//列表长度减1</span>
    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Let gc do its work</span>
    <span class="token comment" spellcheck="true">//返回删除的值</span>
    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        注意看，index位置后的元素都向前移动了一位，最后一个位置空出来了，这又是一个数组拷贝，和插入一样，如果数据量大，删除动作必然会暴露出性能和效率方面的问题。ArrayList其它的两个删除方法与此类似，不再赘述。</p>
<p>　　我么再来看LinkedList的删除动作。LinkedList提供了非常多的删除操作，比如删除指定位置元素，删除头元素等，与之相关的poll方法也会执行删除动作，下面来看最基本的删除指定位置元素的方法remove，源代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java">E <span class="token function">unlink</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// assert x != null;</span>
    <span class="token keyword">final</span> E element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        first <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    x<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>
    size<span class="token operator">--</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> element<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    E item<span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span>

    <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        这也是双向链表标准删除算法，没有任何耗时的操作，全部都是引用指针的变更，效率自然高了。</p>
<p>​        (3)、修改元素：写操作还有一个动作，修改元素值，在这一点上LinkedList输给了ArrayList，这是因为LinkedList是按顺序存储的，因此定位元素必然是一个遍历过程，效率大打折扣，我们来看Set方法的代码：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//定位节点</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    E oldVal <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点元素替换</span>
    x<span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        看似很简洁，但是这里使用了node方法定位元素，上一个建议中我们已经说明了LinkedList这种顺序存取列表的元素定位方式会折半遍历，这是一个极耗时的操作，而ArrayList的修改动作则是数组元素的直接替换，简单高效。</p>
<p>　　在修改动作上，LinkedList比ArrayList慢很多，特别是要进行大量的修改时，两者完全不在一个数量级上。</p>
<p>　　上面通过分析源码完成了LinkedList与ArrayList之间的PK，其中<strong>LinkedList胜两局：删除和插入效率高</strong>；<strong>ArrayList胜一局：修改元素效率高</strong>。总体来说，在写方面LinkedList占优势，而且在实际使用中，修改是一个比较少的动作。因此有大量写的操作(更多的是插入和删除)，推荐使用LinkedList。不过何为少量？何为大量呢？</p>
<p>　　这就依赖于咱们在开发中系统了，具体情况具体分析了。</p>
<h3><span id="建议69列表list相等只关心元素数据">建议69：列表(List)相等只关心元素数据</span></h3><p>我们来看一个比较列表相等的例子，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client69</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> strs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Vector<span class="token operator">&lt;</span>String<span class="token operator">></span> strs2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strs2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strs<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>strs2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        两个类都不同，一个是ArrayList，一个是Vector，那结果肯定不相等了。真是这样吗？但其实结果为true，也就是两者相等。</p>
<p>　　我们分析一下，两者为何相等，两者都是列表（List），都实现了List接口，也都继承了AbstractList抽象类，其equals方法是在AbstractList中定义的，我们来看源代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//是否是列表，注意这里：只要实现List接口即可</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">List</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//通过迭代器访问List的所有元素</span>
    ListIterator<span class="token operator">&lt;</span>E<span class="token operator">></span> e1 <span class="token operator">=</span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListIterator e2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>List<span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//遍历两个List的元素</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>e1<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> e2<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        E o1 <span class="token operator">=</span> e1<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Object o2 <span class="token operator">=</span> e2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//只要存在着不相等就退出</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o1<span class="token operator">==</span>null <span class="token operator">?</span> o2<span class="token operator">==</span>null <span class="token operator">:</span> o1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//长度是否也相等</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>e1<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> e2<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        看到没，这里只要实现了List接口就成，它不关心List的具体实现类，只要所有元素相等，并且长度也相等就表明两个List是相等的，与具体的容量类型无关。也就是说，上面的例子虽然一个是Arraylist,一个是Vector，只要里面的元素相等，那结果也就相等。</p>
<p>　　Java如此处理也确实是在为开发者考虑，列表只是一个容器，只要是同一种类型的容器(如List)，不用关心，容器的细节差别，只要确定所有的元素数据相等，那这两个列表就是相等的，如此一来，我们在开发中就不用太关注容器的细节了，可以把注意力更多地放在数据元素上，而且即使中途重构容器类型，也不会对相等的判断产生太大的影响。</p>
<p>　　其它的集合类型，如Set、Map等于此相同，也是只关心集合元素，不用考虑集合类型。</p>
<p><strong><font color="red">注意：判断集合是否相等时只须关注元素是否相等即可。</font></strong></p>
<h3><span id="建议70子列表只是原列表的一个视图">建议70：子列表只是原列表的一个视图</span></h3><p>​        List接口提供了subList方法，其作用是返回一个列表的子列表，这与String类subSting有点类似，但它们的功能是否相同呢？我们来看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client70</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 定义一个包含两个字符串的列表</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">></span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 构造一个包含c列表的字符串列表</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">></span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// subList生成与c相同的列表</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">></span> c2 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// c2增加一个元素</span>
        c2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"c==c1? "</span> <span class="token operator">+</span> c<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"c==c2? "</span> <span class="token operator">+</span> c<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        c1是通过ArrayList的构造函数创建的，c2是通过列表的subList方法创建的，然后c2又增加了一个元素”C”，现在的问题是输出的结果是什么呢？列表c与c1、c2之间是什么关系呢？先不回答这个问题，我们先来回想一下String类的subString方法，看看它是如何工作的，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String str <span class="token operator">=</span> <span class="token string">"AB"</span><span class="token punctuation">;</span>
    String str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    String str2 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"C"</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"str==str1? "</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"str==str2? "</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        很明显，str和str1是相等的(虽然不是同一个对象，但用equals方法判断是相等的)，但它们与str2不相等，这毋庸置疑，因为str2在对象池中重新生成了一个新的对象，其表面值是ABC，那当然与str和str1不相等了。</p>
<p>　　说完了subString的小插曲，现在回到List是否相等的判断上来。subList与subString的输出结果是一样的吗？让事实说话，运行结果如下：<strong>c= =c1? false   c= =c2? true</strong></p>
<p>　　很遗憾，与String类正好相反，同样是一个sub类型的操作，为什么会相反呢？c2是通过subList方法从c列表中生成的一个子列表，然后c2又增加了一个元素，可为什么增加了一个元素还会相等呢？我们从subList的源码来分析一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">subList</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">?</span>
            <span class="token keyword">new</span> <span class="token class-name">RandomAccessSubList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> fromIndex<span class="token punctuation">,</span> toIndex<span class="token punctuation">)</span> <span class="token operator">:</span>
            <span class="token keyword">new</span> <span class="token class-name">SubList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> fromIndex<span class="token punctuation">,</span> toIndex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        subList的方法是由AbstractList实现的，它会根据是不是可以随机存取来提供不同的SubList实现方式，不过，随机存取的使用频率比较高，而且RandomAccessSubList也是subList的子类，所以所有的操作都是由Sublist类实现的(除了自身的SubList方法外)，那么，我们就直接看看SubList类的代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SubList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//原始列表</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> AbstractList<span class="token operator">&lt;</span>E<span class="token operator">></span> l<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//偏移量</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> offset<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//构造函数，注意list参数就是我们的原始列表</span>
    <span class="token function">SubList</span><span class="token punctuation">(</span>AbstractList<span class="token operator">&lt;</span>E<span class="token operator">></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/*下标校验代码  略*/</span>
        <span class="token comment" spellcheck="true">//传递原始列表</span>
        l <span class="token operator">=</span> list<span class="token punctuation">;</span>
        offset <span class="token operator">=</span> fromIndex<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//子列表的长度</span>
        size <span class="token operator">=</span> toIndex <span class="token operator">-</span> fromIndex<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>modCount <span class="token operator">=</span> l<span class="token punctuation">.</span>modCount<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//获得制定位置的元素</span>
    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/*下标校验 略*/</span>
        <span class="token comment" spellcheck="true">//从原始字符串中获得制定位置的元素</span>
        <span class="token keyword">return</span> l<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token operator">+</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//增加或插入</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/*下标校验 略*/</span>
        <span class="token comment" spellcheck="true">//直接增加到原始字符串上</span>
        l<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>index<span class="token operator">+</span>offset<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/*处理长度和修改计数器*/</span>
    <span class="token punctuation">}</span>
   <span class="token comment" spellcheck="true">/*其它方法 略*/</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        通过阅读这段代码，我们就非常清楚subList方法的实现原理了：<strong>它返回的SubList类也是AbstractList的子类，其所有的get、set、add、remove等都是在原始列表上的操作，它自身并没有生成一个新的数组或是链表，也就是子列表只是原列表的一个视图(View)而已。所有的修改动作都映射到了原列表上。</strong></p>
<p>　　我们例子中的c2增加了一个元素C，不过增加的元素C到了c列表上，两个变量的元素仍然保持一致，相等也就是自然的了。</p>
<p>　　解释完相等的问题，再回过头来看看变量c与c1不行等的原因，很简单，因为通过ArrayList构造函数创建的List对象实际上是新列表，它是通过数组的copyOf动作生成的，所生成的列表c1与原列表c之间没有任何关系(虽然是浅拷贝，但元素类型是String，也就是说元素是深拷贝的)，然后c又增加了元素，因为c1与c之间已经没有一毛线关系了。</p>
<p><strong><font color="red">注意：subList产生的列表只是一个视图，所有的修改动作直接作用于原列表。</font></strong></p>
<h3><span id="建议71推荐使用sublist处理局部列表">建议71：推荐使用subList处理局部列表</span></h3><p>​        我们来看这样一个简单的需求：一个列表有100个元素，现在要删除索引位置为20~30的元素。这很简单，一个遍历很快就可以完成，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client71</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 初始化一个固定长度，不可变列表</span>
        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> initData <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">nCopies</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 转换为可变列表</span>
        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>initData<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 遍历，删除符合条件的元素</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">20</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>或者将for循环改为：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">30</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           
        list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        相信首先出现在大家脑海中的实现算法就是此算法了，遍历一遍，符合条件的删除，简单而使用，不过，有没有其它方式呢？有没有“one-lining”一行代码就解决问题的方式呢？</p>
<p>　　有，直接使用ArrayList的removeRange方法不就可以了吗？不过好像不可能呀，虽然JDK上由此方法，但是它有protected关键字修饰着，不能直接使用，那怎么办？看看如下代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 初始化一个固定长度，不可变列表</span>
    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> initData <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">nCopies</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 转换为可变列表</span>
    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>initData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//删除指定范围内的元素</span>
    list<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        上一个建议讲了subList方法的具体实现方式，所有的操作都是在原始列表上进行的，那我们就用subList先取出一个子列表，然后清空。因为subList返回的list是原始列表的一个视图，删除这个视图中 的所有元素，最终都会反映到原始字符串上，那么一行代码解决问题了。</p>
<p>　　顺便贴一下上面方法调用的源码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">removeRange</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">removeRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListIterator<span class="token operator">&lt;</span>E<span class="token operator">></span> it <span class="token operator">=</span> <span class="token function">listIterator</span><span class="token punctuation">(</span>fromIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">=</span>toIndex<span class="token operator">-</span>fromIndex<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><span id="建议72生成子列表后不要再操作原列表">建议72：生成子列表后不要再操作原列表</span></h3><p>​         前面说了，subList生成的子列表是原列表的一个视图，那在subList执行完后，如果修改了原列表的内容会怎样呢？视图是否会改变呢？如果是数据库视图，表数据变更了，视图当然会变了，至于subList生成的视图是否会改变，还是从源码上来看吧，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client72</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">></span> subList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//原字符串增加一个元素</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原列表长度："</span><span class="token operator">+</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子列表长度："</span><span class="token operator">+</span>subList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        程序中有一个原始列表，生成了一个子列表，然后在原始列表中增加一个元素，最后打印出原始列表和子列表的长度，大家想一下，这段程序什么地方会出现错误呢？list.add(“D”)会报错吗？不会，subList并没有锁定原列表，原列表当然可以继续修改。难道有size方法？正确，确实是size方法出错了，输出结果如下：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160920211722324-1741297553.png" alt="img"></p>
<p>​        什么，居然是subList的size方法出现了异常，而且还是并发修改异常？这没道理呀，这里根本就没有多线程操作，何来并发修改呢？这个问题很容易回答，那是因为subList取出的列表是原列表的一个视图，原数据集(代码中的lsit变量)修改了，但是subList取出的子列表不会重新生成一个新列表(这点与数据库视图是不相同的)，后面在对子列表继续操作时，就会检测到修改计数器与预期的不相同，于是就抛出了并发修改异常。出现这个问题的最终原因还是在子列表提供的size方法的检查上，还记得上面几个例子中经常提到的修改计数器？原因就在这里，我们来看看size的源代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        其中的checkForComodification()方法就是用于检测是否并发修改的，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//判断当前修改计数器是否与子列表生成时一致</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>modCount <span class="token operator">!=</span> l<span class="token punctuation">.</span>modCount<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        modCount 是从什么地方来的呢？它是在subList子列表的构造函数中赋值的，其值等于生成子列表时的修改次数吗。因此在生成子列表后再修改原始列表，l.modCount的值就必然比modeCount大1，不再保持相等了，于是就抛出了ConcurrentModificationException异常。</p>
<p>　　subList的其它方法也会检测修改计数器，例如set、get、add等方法，若生成子列表后，再修改原列表，这些方法也会抛出ConcurrentModificationException异常。</p>
<p>　　对于子列表的操作，因为视图是动态生成的，生成子列表后再操作原列表，必然会导致”视图 “的不稳定，最有效的方法就是通过Collections.unmodifiableList方法设置列表为只读状态，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> subList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//设置列表为只读状态</span>
    list<span class="token operator">=</span>Collections<span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//对list进行只读操作</span>
    <span class="token comment" spellcheck="true">//......</span>
    <span class="token comment" spellcheck="true">//对subList进行读写操作</span>
    <span class="token comment" spellcheck="true">//......</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        这在团队编码中特别有用，比如我生成了一个list，需要调用其他同事写的共享方法，但是一些元素是不能修改的，想想看，此时subList方法和unmodifiableList方法配合使用是不是就可以解决我们的问题了呢？防御式编程就是教我们如此做的。</p>
<p>　　这里还有一个问题，数据库的一张表可以有多个视图，我们的List也可以有多张视图，也就是可以有多个子列表，但问题是只要生成的子列表多于一个，任何一个子列表都不能修改了，否则就会抛出ConcurrentModificationException异常。</p>
<p><strong><font color="red">注意：subList生成子列表后，保持原列表的只读状态。</font></strong></p>
<h3><span id="建议73使用comparator进行排序">建议73：使用Comparator进行排序</span></h3><p>​        在项目开发中，我们经常要对一组数据进行排序，或者升序或者降序，在Java中排序有多种方式，最土的方式就是自己写排序算法，比如冒泡排序、快速排序、二叉树排序等，但一般不需要自己写，JDK已经为我们提供了很多的排序算法，我们采用”拿来主义” 就成了。在Java中，要想给数据排序，有两种实现方式，一种是实现Comparable接口，一种是实现Comparator接口，这两者有什么区别呢？我们来看一个例子，就比如给公司职员按照工号排序吧，先定义一个职员类代码，如下所示：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>builder<span class="token punctuation">.</span>CompareToBuilder<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>builder<span class="token punctuation">.</span>ToStringBuilder<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Employee<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 工号--按照进入公司的先后顺序编码的</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 姓名</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 职位</span>
    <span class="token keyword">private</span> Position position<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Employee</span><span class="token punctuation">(</span><span class="token keyword">int</span> _id<span class="token punctuation">,</span> String _name<span class="token punctuation">,</span> Position _position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        id <span class="token operator">=</span> _id<span class="token punctuation">;</span>
        name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
        position <span class="token operator">=</span> _position<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//getter和setter方法略</span>
    <span class="token comment" spellcheck="true">// 按照Id排序，也就是按照资历的深浅排序</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Employee o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CompareToBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> o<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toComparison</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ToStringBuilder<span class="token punctuation">.</span><span class="token function">reflectionToString</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//枚举类型(三个级别Boss(老板)、经理(Manager)、普通员工(Staff))</span>
<span class="token keyword">enum</span> Position <span class="token punctuation">{</span>
    Boss<span class="token punctuation">,</span> Manager<span class="token punctuation">,</span> Staff
<span class="token punctuation">}</span>
</code></pre>
<p>​        这是一个简单的JavaBean，描述的是一个员工的基本信息，其中id是员工编号，按照进入公司的先后顺序编码，position是岗位描述，表示是经理还是普通职员，这是一个枚举类型。</p>
<p>　　注意Employee类中的compareTo方法，它是Comparable接口要求必须实现的方法，这里使用apache的工具类来实现，表明是按照Id的自然序列排序的(也就是升序)，现在我们看看如何排序：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Employee<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 两个职员</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token number">1004</span><span class="token punctuation">,</span> <span class="token string">"马六"</span><span class="token punctuation">,</span> Position<span class="token punctuation">.</span>Staff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token number">1005</span><span class="token punctuation">,</span> <span class="token string">"赵七"</span><span class="token punctuation">,</span> Position<span class="token punctuation">.</span>Staff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 两个经理</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">,</span> Position<span class="token punctuation">.</span>Manager<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token number">1003</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">,</span> Position<span class="token punctuation">.</span>Manager<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 一个老板</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">,</span> Position<span class="token punctuation">.</span>Boss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 按照Id排序，也就是按照资历排序</span>
    Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Employee e <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在收集数据的时候本来应该从老板到员工，为了结果更清晰，故将其打乱，从员工到老板，排序结果如下：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160921124450481-181677613.png" alt="img"></p>
<p>​        是按照ID升序排列的，结果正确，但是，有时候我们希望按照职位来排序，那怎么做呢？此时，重构Employee类已经不合适了，Employee已经是一个稳定类，为了排序功能修改它不是一个好办法，哪有什么好的解决办法吗？</p>
<p>　　有办法，看Collections.sort方法，它有一个重载方法Collections.sort(List<t> list, Comparator&lt;? super T&gt; c),可以接收一个Comparator实现类，这下就好办了，代码如下：　　</t></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">PositionComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Employee<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Employee o1<span class="token punctuation">,</span> Employee o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 按照职位降序排列</span>
        <span class="token keyword">return</span> o1<span class="token punctuation">.</span><span class="token function">getPosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o2<span class="token punctuation">.</span><span class="token function">getPosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    创建了一个职位排序法，依据职位的高低进行降序排列，然后只要Collections.sort（list）修改为Collections.sort(list,new PositionComparator() )即可实现按照职位排序的要求。</p>
<p>　　现在问题又来了：按职位临时倒叙排列呢？注意只是临时的，是否需要重写一个排序器呢？完全不用，有两个解决办法：</p>
<ul>
<li>直接使用Collections.reverse（List &lt;?&gt; list）方法实现倒序排列；</li>
<li>通过Collections.sort(list , Collections.reverseOrder(new PositionComparator()))也可以实现倒序排列。</li>
</ul>
<p>　　第二个问题：先按照职位排序，职位相同再按照工号排序，这如何处理呢？这可是我们经常遇到的实际问题。很好处理，在compareTo或者compare方法中判断职位是否相等，相等的话再根据工号排序，使用apache工具类来简化处理，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Employee o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CompareToBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> o<span class="token punctuation">.</span>position<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> o<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toComparison</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        在JDK中，对Collections.sort方法的解释是按照自然顺序进行升序排列，这种说法其实不太准确的，sort方法的排序方式并不是一成不变的升序，也可能是倒序，这依赖于compareTo的返回值，我们知道如果compareTo返回负数，表明当前值比对比值小，零表示相等，正数表明当前值比对比值大，比如我们修改一下Employee的compareTo方法，如下所示：　</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Employee o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CompareToBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>id<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toComparison</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        两个参数调换了一下位置，也就是compareTo的返回值与之前正好相反，再使用Collections.sort进行排序，顺序也就相反了，这样也实现了倒序。</p>
<p>　　第三个问题：在Java中，为什么要有两个排序接口呢？</p>
<p>　　其实也很好回答，实现了Comparable接口的类表明自身是可以比较的，有了比较才能进行排序，而Comparator接口是一个工具类接口，它的名字(比较器)也已经表明了它的作用：用作比较，它与原有类的逻辑没有关系，只是实现两个类的比较逻辑，从这方面来说，一个类可以有很多的比较器，只要有业务需求就可以产生比较器，有比较器就可以产生N多种排序，而Comparable接口的排序只能说是实现类的默认排序算法，一个类稳定、成熟后其compareTo方法基本不会变，也就是说一个类只能有一个固定的、由compareTo方法提供的默认排序算法。</p>
<p><strong><font color="red">注意：Comparable接口可以作为实现类的默认排序算法，Comparator接口则是一个类的扩展排序工具。</font></strong></p>
<h3><span id="建议74不推荐使用binarysearch对列表进行检索">建议74：不推荐使用binarySearch对列表进行检索</span></h3><pre><code> 　对一个列表进行检索时，我们使用最多的是indexOf方法，它简单、好用，而且也不会出错，虽然它只能检索到第一个符合条件的值，但是我们可以生成子列表后再检索，这样也即可以查找出所有符合条件的值了。
</code></pre>
<p>　　Collections工具类也提供了一个检索方法，binarySearch，这个是干什么的？该方法也是对一个列表进行检索的，可查找出指定值的索引，但是在使用这个方法时就有一些注意事项，我们看如下代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client74</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">></span> cities <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cities<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cities<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"广州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cities<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"广州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cities<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"北京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cities<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"天津"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//indexOf取得索引值</span>
        <span class="token keyword">int</span> index1<span class="token operator">=</span> cities<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"广州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//binarySearch找到索引值</span>
        <span class="token keyword">int</span> index2<span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>cities<span class="token punctuation">,</span> <span class="token string">"广州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"索引值(indexOf)："</span><span class="token operator">+</span>index1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"索引值(binarySearch)："</span><span class="token operator">+</span>index2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　先不考虑运行结果，直接看JDK上对binarySearch的描述：使用二分搜索法搜索指定列表，以获得指定对象。其实现的功能与indexOf是相同的，只是使用的是二分法搜索列表，所以估计两种方法返回的结果是一样的，看结果：</p>
<p>　    <strong>索引值(indexOf)：1</strong><br>       <strong>索引值(binarySearch)：2</strong></p>
<p>　　结果不一样，虽然我们说有两个”广州” 这样的元素，但是返回的结果都应该是1才对呀，为何binarySearch返回的结果是2呢？问题就出在二分法搜索上，二分法搜索就是“折半折半再折半” 的搜索方法，简单，而且效率高。看看JDK是如何实现的。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> BINARYSEARCH_THRESHOLD   <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span>
    <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">>></span> list<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>BINARYSEARCH_THRESHOLD<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">//随机存取列表或者元素数量少于5000的顺序存取列表</span>
        <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">indexedBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment" spellcheck="true">//元素数量大于5000的顺序存取列表</span>
        <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">iteratorBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>ArrayList实现了RandomAccess接口，是一个顺序存取列表，使用了indexedBinarySearch方法，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">int</span> <span class="token function">indexedBinarySearch</span><span class="token punctuation">(</span>
    List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">>></span> list<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 默认商界</span>
    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 默认下界</span>
    <span class="token keyword">int</span> high <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//中间索引，无符号右移一位</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//中间值</span>
        Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> midVal <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//比较中间值</span>
        <span class="token keyword">int</span> cmp <span class="token operator">=</span> midVal<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//重置上界和下界</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token comment" spellcheck="true">//找到元素</span>
            <span class="token keyword">return</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// key found</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//没有找到，返回负值</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token punctuation">(</span>low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// key not found</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　    这也没啥说的，就是二分法搜索的Java版实现。注意看第10和14行代码，首先是获得中间的索引值，我们的例子中也就是2，那索引值是2的元素值是多少呢？正好是“广州” ，于是就返回索引值2，正确，没问题，我们再看看indexOf的实现，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//null元素查找</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//非null元素查找</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">//两个元素是否相等，注意这里是equals方法</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        indexOf方法就是一个遍历，找到第一个元素值相等则返回，没什么玄机，回到我们的程序来看，for循环的第二遍即是我们要查找的 “ 广州 “ ，于是就返回索引值1了，也正确，没有任何问题。</p>
<p>　　两者的算法都没有问题，难道是我们用错了。这的确是我们使用的错误，**<font color="red">因为二分法查询的一个首要前提是：数据集以实现升序排列，否则二分法查找的值是不准确的。不排序怎么确定是在小区(比中间值小的区域) 中查找还是在大区(比中间值大的区域)中查找呢？二分法查找必须要先排序，这是二分法查找的首要条件。</font>**</p>
<p>​        使用binarySearch首先要考虑排序问题，这是我们经常忘记的，而且在测试期间还不好发现问题，等到投入生产环境后才发现查找到的数据不准确，又是一个bug产生了，从这点看，indexOf要比binarySearch简单的多.</p>
<p>　<strong><font color="red">使用binarySearch的二分法查找比indexOf的遍历算法性能上高很多，特别是在大数据集且目标值又接近尾部时，binarySearch方法与indexOf方法相比，性能上会提升几十倍，因此从性能的角度考虑时可以选择binarySearch。</font></strong></p>
<h3><span id="建议75集合中的元素必须做到compareto和equals同步">建议75：集合中的元素必须做到compareTo和equals同步</span></h3><p>​        实现了Comparable接口的元素就可以排序，compareTo方法是Comparable接口要求必须实现的，它与equals方法有关系吗?有关系，在compareTo的返回为0时，它表示的是 进行比较的两个元素时相等的。equals是不是也应该对此作出相应的动作呢？我们看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">City</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>City<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String code<span class="token punctuation">;</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">City</span><span class="token punctuation">(</span>String _code<span class="token punctuation">,</span> String _name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        code <span class="token operator">=</span> _code<span class="token punctuation">;</span>
        name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//code、name的setter和getter方法略</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>City o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//按照城市名称排序</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CompareToBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> o<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toComparison</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        City city <span class="token operator">=</span> <span class="token punctuation">(</span>City<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 根据code判断是否相等</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">EqualsBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> city<span class="token punctuation">.</span>code<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEquals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>​    　我们把多个城市对象放在一个list中，然后使用不同的方法查找同一个城市，看看返回值有神么异常？代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>City<span class="token operator">></span> cities <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>City<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cities<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">City</span><span class="token punctuation">(</span><span class="token string">"021"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cities<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">City</span><span class="token punctuation">(</span><span class="token string">"021"</span><span class="token punctuation">,</span> <span class="token string">"沪"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 排序</span>
        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>cities<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 查找对象</span>
        City city <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">City</span><span class="token punctuation">(</span><span class="token string">"021"</span><span class="token punctuation">,</span> <span class="token string">"沪"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// indexOf方法取得索引值</span>
        <span class="token keyword">int</span> index1 <span class="token operator">=</span> cities<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>city<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// binarySearch查找索引值</span>
        <span class="token keyword">int</span> index2 <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>cities<span class="token punctuation">,</span> city<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 索引值(indexOf) :"</span> <span class="token operator">+</span> index1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 索引值(binarySearch) :"</span> <span class="token operator">+</span> index2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>​        输出的index1和index2应该一致吧，都是从一个列表中查找相同的元素，只是使用的算法不同嘛。但是很遗憾，结果不一致：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160922095602387-1177688839.png" alt="img"></p>
<p>​        indexOf返回的是第一个元素，而binarySearch返回的是第二个元素(索引值为1)，这是怎么回事呢？</p>
<p>　　这是因为indexOf是通过equals方法判断的，equals方法等于true就认为找到符合条件的元素了，而binarySearch查找的依据是compareTo方法的返回值，返回0即认为找到符合条件的元素了。</p>
<p>　　仔细审查一下代码，我们覆写了compareTo和equals方法，但是两者并不一致。使用indexOf方法查找时 ，遍历每个元素，然后比较equals方法的返回值，因为equals方法是根据code判断的，因此当第一次循环时 ，equals就返回true，indexOf方法结束，查找到指定值。而使用binarySearch二分法查找时，依据的是每个元素的compareTo方法返回值，而compareTo方法又是依赖属性的，name相等就返回0，binarySearch就认为找到元素了。</p>
<p>　　问题明白了，修改很easy，将equals方法修改成判断name是否相等即可，虽然可以解决问题，但这是一个很无奈的办法，而且还要依赖我们的系统是否支持此类修改，因为逻辑已经发生了很大的变化，从这个例子，我们可以理解两点：</p>
<ul>
<li><p>indexOf依赖equals方法查找，binarySearch则依赖compareTo方法查找；</p>
</li>
<li><p>equals是判断元素是否相等，compareTo是判断元素在排序中的位置是否相同。</p>
<p>　既然一个决定排序位置，一个是决定相等，那我们就应该保证当排序相同时，其equals也相同，否则就会产生逻辑混乱。</p>
</li>
</ul>
<p><strong><font color="red">注意：实现了compareTo方法就应该覆写equals方法，确保两者同步。</font></strong></p>
<h3><span id="建议76集合运算时使用最优雅方式">建议76：集合运算时使用最优雅方式</span></h3><p>​        在初中代数中，我们经常会求两个集合的并集、交集、差集等，在Java中也存在着此类运算，那如何实现呢？一提到此类集合操作，大部分的实现者都会说：对两个集合进行遍历，即可求出结果。是的。遍历可以实现并集、交集、差集等运算，但这不是最优雅的处理方式，下面来看看如何进行更优雅、快速、方便的集合操作：</p>
<p>　　(1)、并集：也叫作合集，把两个集合加起来即可，这非常简单，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 并集</span>
        list1<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>(2)、交集：计算两个集合的共有元素，也就是你有我也有的元素集合，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//交集</span>
list1<span class="token punctuation">.</span><span class="token function">retainAll</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>​    　其中的变量list1和list2是两个列表，仅此一行，list1中就只包含了list1、list2中共有的元素了，注意retailAll方法会删除list1中没有出现在list2中的元素。</p>
<p>​        (3)、差集：由所有属于A但不属于B的元素组成的集合，叫做A与B的差集，也就是我有你没有的元素，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//差集</span>
list1<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>​        也很简单，从list1中删除出现在list2中的元素，即可得出list1和list2的差集部分。</p>
<p>　　(4)、无重复的并集：并集是集合A加集合B，那如果集合A和集合B有交集，就需要确保并集的结果中只有一份交集，此为无重复的并集，此操作也比较简单，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//删除在list1中出现的元素</span>
list2<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//把剩余的list2元素加到list1中</span>
list1<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>​        可能有人会说，求出两个集合的并集，然后转成hashSet剔除重复元素不就解决了吗？错了，这样解决是不行的，比如集合A有10个元素(其中有两个元素值是相同的)，集合B有8个元素，它们的交集有两个元素，我们可以计算出它们的并集是18个元素，而无重复的并集有16个元素，但是如果用hashSet算法，算出来则只有15个元素，因为你把集合A中原本就重复的元素也剔除了。</p>
<p>　　之所以介绍并集、交集、差集，那是因为在实际开发中，很少有使用JDK提供的方法实现集合这些操作，基本上都是采用了标准的嵌套for循环：要并集就是加法，要交集就是contains判断是否存在，要差集就使用了!contains（不包含），有时候还要为这类操作提供了一个单独的方法看似很规范，其实应经脱离了优雅的味道。</p>
<p>　　集合的这些操作在持久层中使用的非常频繁，从数据库中取出的就是多个数据集合，之后我们就可以使用集合的各种方法构建我们需要的数据，需要两个集合的and结果，那是交集，需要两个集合的or结果，那是并集，需要两个集合的not结果，那是差集。</p>
<h3><span id="建议77使用shuffle打乱列表">建议77：使用shuffle打乱列表</span></h3><p>​        在网站上，我们经常会看到关键字云(word cloud)和标签云(tag cloud)，用于表达这个关键字或标签是经常被查阅的，而且还可以看到这些标签的动态运动，每次刷新都会有不一样的关键字或标签，让浏览者觉得这个网站的访问量很大，短短的几分钟就有这么多的搜索量。不过，在Java中该如何实现呢？代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> tagCloudNum <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> tagClouds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>tagCloudNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 初始化标签云，一般是从数据库读入，省略</span>
    Random rand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tagCloudNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 取得随机位置</span>
        <span class="token keyword">int</span> randomPosition <span class="token operator">=</span> rand<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>tagCloudNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 当前元素与随机元素交换</span>
        String temp <span class="token operator">=</span> tagClouds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        tagClouds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> tagClouds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>randomPosition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tagClouds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>randomPosition<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　    现从数据库中读取标签，然后使用随机数打乱，每次产生不同的顺序，嗯，确实能让浏览者感觉到我们的标签云顺序在变化—浏览者多嘛！但是，对于乱序处理我们可以有更好的实现方式，先来修改第一版：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> tagCloudNum <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> tagClouds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>tagCloudNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 初始化标签云，一般是从数据库读入，省略</span>
    Random rand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tagCloudNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 取得随机位置</span>
        <span class="token keyword">int</span> randomPosition <span class="token operator">=</span> rand<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>tagCloudNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 当前元素与随机元素交换</span>
        Collections<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>tagClouds<span class="token punctuation">,</span> i<span class="token punctuation">,</span> randomPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　    上面使用了Collections的swap方法，该方法会交换两个位置的元素值，不用我们自己写交换代码了。难道乱序到此就优化完了吗？没有，我们可以继续重构，第二版如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> tagCloudNum <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> tagClouds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>tagCloudNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 初始化标签云，一般是从数据库读入，省略</span>
    <span class="token comment" spellcheck="true">//打乱顺序</span>
    Collections<span class="token punctuation">.</span><span class="token function">shuffle</span><span class="token punctuation">(</span>tagClouds<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        这才是我们想要的结果，就这一行，即可打乱一个列表的顺序，我们不用费尽心思的遍历、替换元素了。我们一般很少用到shuffle这个方法，那它在什么地方用呢？</p>
<ul>
<li>可用在程序的 “伪装” 上：比如我们例子中的标签云，或者是游侠中的打怪、修行、群殴时宝物的分配策略。</li>
<li>可用在抽奖程序中：比如年会的抽奖程序，先使用shuffle把员工顺序打乱，每个员工的中奖几率相等，然后就可以抽出第一名、第二名。</li>
<li>可以用在安全传输方面：比如发送端发送一组数据，先随机打乱顺序，然后加密发送，接收端解密，然后进行排序，即可实现即使是相同的数据源，也会产生不同密文的效果，加强了数据的安全性。</li>
</ul>
<h3><span id="建议78减少hashmap中元素的数量">建议78：减少HashMap中元素的数量</span></h3><p>​    本建议是说HahMap中存放数据过多的话会出现内存溢出，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> Runtime rt <span class="token operator">=</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// JVM中止前记录信息</span>
    rt<span class="token punctuation">.</span><span class="token function">addShutdownHook</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">long</span> heapMaxSize <span class="token operator">=</span> rt<span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">20</span><span class="token punctuation">;</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" 最大可用内存："</span> <span class="token operator">+</span> heapMaxSize <span class="token operator">+</span> <span class="token string">" M\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">long</span> total <span class="token operator">=</span> rt<span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">20</span><span class="token punctuation">;</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" 堆内存大小："</span> <span class="token operator">+</span> total <span class="token operator">+</span> <span class="token string">"M\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">long</span> free <span class="token operator">=</span> rt<span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">20</span><span class="token punctuation">;</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" 空闲内存："</span> <span class="token operator">+</span> free <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token operator">*</span><span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key"</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token string">"value"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//            list.add("list"+i);</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　这个例子，我经过多次运算，发现在40万的数据并不会内存溢出，如果要复现此问题，需要修改Eclipse的内存配置，才会复现。但现在的机器的内存逐渐的增大，硬件配置的提高，应该可以容纳更多的数据。本人机器是windows64，内存8G配置，Eclipse的配置为  -Xms286M  -Xmx1024M，在单独运行此程序时，数据量加到千万级别才会复现出此问题。但在生产环境中，如果放的是复杂对象，可能同样配置的机器存放的数据量会小一些。</p>
<p>　　但如果换成list存放，则同样的配置存放的数据比HashMap要多一些，本人就针对此现象进行分析一下几点：</p>
<p>　　1.HashMap和ArrayList的长度都是动态增加的，不过两者的扩容机制不同，先说HashMap,它在底层是以数组的方式保存元素的，其中每一个键值对就是一个元素，也就是说HashMap把键值对封装成了一个Entry对象，然后再把Entry对象放到了数组中。也就是说HashMap比ArrayList多了一次封装，多出了一倍的对象。其中HashMap的扩容机制代码如下**(resize(2 *** **table.length)**这就是扩容核心代码)：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
            bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>​     在插入键值对时会做长度校验，如果大于或者等于阈值，则数组长度会增大一倍。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>
        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> oldAltHashing <span class="token operator">=</span> useAltHashing<span class="token punctuation">;</span>
        useAltHashing <span class="token operator">|=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">isBooted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span>newCapacity <span class="token operator">>=</span> Holder<span class="token punctuation">.</span>ALTERNATIVE_HASHING_THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> rehash <span class="token operator">=</span> oldAltHashing <span class="token operator">^</span> useAltHashing<span class="token punctuation">;</span>
        <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> rehash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>
        threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>而阈值就是代码中红色标注的部分，新容量*加权因子和MAXIMUM_CAPACITY + 1两个值的最小值。MAXIMUM_CAPACITY的值如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>
</code></pre>
<p>而加权因子的值为0.75，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>
</code></pre>
<p>　　所以hashMap的size大于数组的0.75倍时，就开始扩容，经过计算得知(怎么计算的，以文中例子来说，查找2的N次幂大于40万的最小值即为数组的最大长度，再乘以0.75，也就是最后一次扩容点，计算的结果是N=19)，在Map的size为393216时，符合了扩容条件，于是393216个元素开始搬家，要扩容则需要申请一个长度为1048576(当前长度的两倍，2的20次方)的数组，如果此时内存不足以支撑此运算，就会爆出内存溢出。这个就是这个问题的根本原因。</p>
<p>　2、我们思考一下ArrayList的扩容策略，它是在小于数组长度的时候才会扩容1.5倍，经过计算得知，ArrayLsit在超过80万后(一次加两个元素，40万的两倍)，最近的一次扩容是在size为1005305时同样的道理，如果此时内存不足以申请扩容1.5倍时的数组，也会出现内存溢出。</p>
<p>　综合来说，HashMap比ArrayList多了一层Entry的底层封装对象，多占用了内存，并且它的扩容策略是2倍长度的递增，同时还会根据阈值判断规则进行判断，因此相对于ArrayList来说，同样的数据，它就会优先内存溢出。</p>
<p>　也许大家会想到，可以在声明时指定HashMap的默认长度和加载因子来减少此问题的发生，可以缓解此问题，可以不再频繁的进行数组扩容，但仍避免不了内存溢出问题，因为键值对的封装对象Entry还是少不了的，内存依然增长比较快，所以尽量让HashMap中的元素少量并简单一点。也可以根据需求以及系统的配置来计算出，自己放入map中的数据会不会造成内存溢出呢？</p>
<h3><span id="建议79集合中的哈希码不要重复">建议79：集合中的哈希码不要重复</span></h3><p>​        在一个列表中查找某值是非常耗费资源的，随机存取的列表是遍历查找，顺序存储的列表是链表查找，或者是Collections的二分法查找，但这都不够快，毕竟都是遍历嘛，最快的还要数以Hash开头的集合(如HashMap、HashSet等类)查找，我们以HashMap为例，看看是如何查找key值的，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client79</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 初始化</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"value"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 记录开始时间，单位纳秒</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 开始查找</span>
        list<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"value"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 记录结束时间,单位纳秒</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"List的执行时间："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ns"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Map的查找时间</span>
        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key"</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token string">"value"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"key"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"map的执行时间："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ns"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        两个不同的集合容器，一个是ArrayList，一个是HashMap，都是插入10000个元素，然后判断是否包含最后一个加入的元素。逻辑相同，但是执行时间差别却非常大，结果如下：</p>
<p>​    List的执行时间：478300ns<br>​    map的执行时间：14700ns</p>
<p>​        HahsMap比ArrayList快了两个数量级！两者的contains方法都是判断是否包含指定值，为何差距如此巨大呢？而且如果数据量增大，差距也会非线性增长。</p>
<p>　　我们先来看看ArrayList，它的contains方法是一个遍历对比，这很easy，不多说。我们看看HashMap的ContainsKey方法是如何实现的，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//判断getEntry是否为空</span>
    <span class="token keyword">return</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    getEntry方法会根据key值查找它的键值对（也就是Entry对象）,如果没有找到，则返回null。我们再看看该方法又是如何实现的，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//计算key的哈希码</span>
    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//定位Entry、indexOf方法是根据hash定位数组的位置的</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>
         e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Object k<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//哈希码相同，并且键值也相等才符合条件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        注意看上面代码中红色字体部分，通过indexFor方法定位Entry在数组table中的位置，这是HashMap实现的一个关键点，怎么能根据hashCode定位它在数组中的位置呢？</p>
<p>　　要解释此问题，还需要从HashMap的table数组是如何存储元素的说起，首先要说明三点：</p>
<ul>
<li>table数组的长度永远是2的N次幂。</li>
<li>table数组的元素是Entry类型</li>
<li>table数组中的元素位置是不连续的</li>
</ul>
<p>　　table数组为何如此设计呢？下面逐步来说明，先来看HashMap是如何插入元素的，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//null键处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//计算hash码，并定位元素</span>
    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Object k<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//哈希码相同，并且key相等，则覆盖</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//插入新元素，或者替换哈希的旧元素并建立链表</span>
    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        注意看，HashMap每次增加元素时都会先计算其哈希码值，然后使用hash方法再次对hashCode进行抽取和统计，同时兼顾哈希码的高位和低位信息产生一个唯一值，也就是说hashCode不同，hash方法返回的值也不同，之后再通过indexFor方法与数组长度做一次与运算，即可计算出其在数组中的位置，简单的说，hash方法和indexFor方法就是把哈希码转变成数组的下标，源代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>useAltHashing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Hashing<span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>
    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>
    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>
    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
     * Returns index for hash code h.
     */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        顺便说一下，null值也是可以作为key值的，它的位置永远是在Entry数组中的第一位。</p>
<p>　　现在有一个很重要的问题摆在前面了：哈希运算存在着哈希冲突问题，即对于一个固定的哈希算法f(k)，允许出现f(k1)=f(k2)，但k1≠k2的情况，也就是说两个不同的Entry，可能产生相同的哈希码，HashMap是如何处理这种冲突问题的呢？答案是通过链表，每个键值对都是一个Entry，其中每个Entry都有一个next变量，也就是说它会指向一个键值对—很明显，这应该是一个单向链表，该链表是由addEntity方法完成的，其代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//取得当前位置元素</span>
    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//生成新的键值对，并进行替换，建立链表</span>
    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        这段程序涵盖了两个业务逻辑，如果新加入的元素的键值对的hashCode是唯一的，那直接插入到数组中，它Entry的next值则为null；如果新加入的键值对的hashCode与其它元素冲突，则替换掉数组中的当前值，并把新加入的Entry的next变量指向被替换的元素，于是一个链表就产生了，如下图所示：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160923150928231-1236782779.png" alt="img"></p>
<p>​        HashMap的存储主线还是数组，遇到哈希码冲突的时候则使用链表解决。了解了HashMap是如何存储的，查找也就一目了然了：使用hashCode定位元素，若有哈希冲突，则遍历对比，换句话说，如果没有哈希冲突的情况下，HashMap的查找则是依赖hashCode定位的，因为是直接定位，那效率当然就高了。</p>
<p>　　知道HashMap的查找原理，我们就应该很清楚：如果哈希码相同，它的查找效率就与ArrayList没什么两样了，遍历对比，性能会大打折扣。特别是哪些进度紧张的项目中，虽重写了hashCode方法但返回值却是固定的，此时如果把哪些对象插入到HashMap中，查找就相当耗时了。</p>
<p><strong><font color="red">注意：HashMap中的hashCode应避免冲突。</font></strong></p>
<h3><span id="建议80多线程使用vector或hashtable">建议80：多线程使用Vector或HashTable</span></h3><p>​        Vector是ArrayList的多线程版本，HashTable是HashMap的多线程版本，这些概念我们都很清楚，但我们经常会逃避使用Vector和HashTable,因为用的少，不熟嘛！只有在真正需要的时候才会想要使用它们，但问题是什么时候真正需要呢？我们来看一个例子，看看使用多线程安全的Vector是否可以解决问题，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client80</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 火车票列表</span>
        <span class="token keyword">final</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> tickets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 初始化票据池</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            tickets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"火车票"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 退票</span>
        Thread returnThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    tickets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"车票"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 售票</span>
        Thread saleThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>String ticket <span class="token operator">:</span> tickets<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    tickets<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ticket<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 启动退票线程</span>
        returnThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 启动售票线程</span>
        saleThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        模拟火车站售票程序，先初始化一堆火车票，然后开始出售，同时也有退票产生，这段程序有木有问题呢？可能会有人看出了问题，ArrayList是线程不安全的，两个线程访问同一个ArrayList数组肯定会有问题。</p>
<p>　　没错，确定有问题，运行结果如下：</p>
<pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"Thread-1"</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ConcurrentModificationException
    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList$Itr<span class="token punctuation">.</span><span class="token function">checkForComodification</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>
    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList$Itr<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>
    at com<span class="token punctuation">.</span>etol<span class="token punctuation">.</span>advice<span class="token punctuation">.</span>ad80<span class="token punctuation">.</span>Client80$<span class="token number">2</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Client80<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">35</span><span class="token punctuation">)</span>
Exception in thread <span class="token string">"Thread-0"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token operator">:</span> Java heap space
    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>
    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>
    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">.</span><span class="token function">grow</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>
    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">.</span><span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>
    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">.</span><span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>
    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>
    at com<span class="token punctuation">.</span>etol<span class="token punctuation">.</span>advice<span class="token punctuation">.</span>ad80<span class="token punctuation">.</span>Client80$<span class="token number">1</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Client80<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">25</span><span class="token punctuation">)</span>
</code></pre>
<p>　    运气好的话，该异常马上就会抛出，也会会有人说这是一个典型错误，只须把ArrayList替换成Vector即可解决问题，真的是这样吗？我们把ArrayList替换成Vector后，结果依旧。仍然抛出相同的异常，Vector应经是线程安全的，为什么还会报这个错呢？</p>
<p>​    **<font color="red">这是因为它混淆了线程安全和同步修改异常，基本上所有的集合类都有一个快速失败(Fail-Fast)的校验机制，当一个集合在被多个线程修改并访问时，就可能出现ConcurrentModificationException异常，这是为了确保集合方法一致而设置的保护措施，它的实现原理就是我们经常提到的modCount修改计数器：如果在读列表时，modCount发生变化(也就是有其它线程修改)则会抛出ConcurrentModificationException异常，这与线程同步是两码事，线程同步是为了保护集合中的数据不被脏读、脏写而设置的</font>**，我们来看看线程安全到底用在什么地方，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 火车票列表</span>
    <span class="token keyword">final</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> tickets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 初始化票据池</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tickets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"火车票"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 10个窗口售票</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                       <span class="token operator">+</span> <span class="token string">"----"</span> <span class="token operator">+</span> tickets<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>tickets<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    还是火车站售票程序，有10个窗口在卖火车票，程序打印出窗口号(也就是线程号)和车票编号，我们很快就可以看到这样的输出：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160923155533871-512571463.png" alt="img"></p>
<p>​        注意看，上面有两个线程在卖同一张火车票，这才是线程不同步的问题，此时把ArrayList修改为Vector即可解决问题，因为Vector的每个方法前都加上了synchronized关键字，同时知会允许一个线程进入该方法，确保了程序的可靠性。</p>
<p>　　虽然在系统开发中我们一再说明，除非必要，否则不要使用synchronized，这是从性能的角度考虑的，但是一旦涉及到多线程(注意这里说的是真正的多线程，并不是并发修改的问题，比如一个线程增加，一个线程删除，这不属于多线程的范畴)，Vector会是最佳选择，当然自己在程序中加synchronized也是可行的方法。</p>
<p>　　HashMap的线程安全类HashTable与此相同，不再赘述。</p>
<h3><span id="建议81非稳定排序推荐使用list">建议81：非稳定排序推荐使用List</span></h3><p>​        我们知道Set和List的最大区别就是Set中的元素不可以重复(这个重复指的是equals方法的返回值相等)，其它方面则没有太大区别了，在Set的实现类中有一个比较常用的类需要了解一下：TreeSet，该类实现了默认排序为升序的Set集合，如果插入一个元素，默认会按照升序排列(当然是根据Comparable接口的compareTo的返回值确定排序位置了)，不过，这样的排序是不是在元素经常变化的场景中也适用呢?我们来看看例子：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client81</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        SortedSet<span class="token operator">&lt;</span>Person<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 身高180CM</span>
        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 身高175CM</span>
        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Person p <span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"身高："</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 身高</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> height<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> _height<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            height <span class="token operator">=</span> _height<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> height<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token keyword">int</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 按照身高排序</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Person o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> height <span class="token operator">-</span> o<span class="token punctuation">.</span>height<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这是Set的简单用法，定义一个Set集合，之后放入两个元素，虽然175后放入，但是由于是按照升序排列的，所以输出结果应该是175在前，180在后。</p>
<p>　　这没有问题，随着时间的推移，身高175cm的人长高了10cm，而180cm却保持不变，那排序位置应该改变一下吧，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SortedSet<span class="token operator">&lt;</span>Person<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 身高180CM</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 身高175CM</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    set<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Person p <span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"身高："</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>找出身高最矮的人，也就是排在第一位的人，然后修改一下身高值，重新排序了？我们看下输出结果：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160923171115496-1552785739.png" alt="img"></p>
<p>​        很可惜，竟然没有重现排序，偏离了我们的预期。这正是下面要说明的问题，SortedSet接口(TreeSet实现了此接口)只是定义了在给集合加入元素时将其进行排序，并不能保证元素修改后的排序结果，因此TreeSet适用于不变量的集合数据排序，比如String、Integer等类型，但不使用与可变量的排序，特别是不确定何时元素会发生变化的数据集合。</p>
<p>　　原因知道了，那如何解决此类重排序问题呢？有两种方式：</p>
<p>　　(1)、Set集合重排序：重新生成一个Set对象，也就是对原有的Set对象重新排序，代码如下：</p>
<pre class=" language-java"><code class="language-java">set<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//set重排序</span>
set<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>就这一行红色代码即可重新排序，可能有人会问，使用TreeSet&lt;SortedSet<e> s&gt; 这个构造函数不是可以更好的解决问题吗？不行，该构造函数只是原Set的浅拷贝，如果里面有相同的元素，是不会重新排序的。</e></p>
<p>　　(2)、彻底重构掉TreeSet，使用List解决问题</p>
<p>　    我们之所以使用TreeSet是希望实现自动排序，即使修改也能自动排序，既然它无法实现，那就用List来代替，然后使用Collections.sort()方法对List排序，代码比较简单，不再赘述。</p>
<p>　　两种方式都可以解决我们的问题，如果需要保证集合中元素的唯一性，又要保证元素值修改后排序正确，那该如何处理呢？List不能保证集合中的元素唯一，它是可以重复的，而Set能保证元素唯一，不重复。如果采用List解决排序问题，就需要自行解决元素重复问题(若要剔除也很简单，转变为HashSet，剔除后再转回来)。若采用TreeSet，则需要解决元素修改后的排序问题，孰是孰非，就需要根据具体的开发场景来决定了。</p>
<p><strong><font color="red">注意：SortedSet中的元素被修改后可能会影响到其排序位置。</font></strong></p>
<h3><span id="建议82由点及面集合大家族总结">建议82：由点及面，集合大家族总结</span></h3><p>​        Java中的集合类实在是太丰富了，有常用的ArrayList、HashMap,也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap，有阻塞式的ArrayBlockingQueue，也有非阻塞式的PriorityQueue等，整个集合大家族非常庞大，可以划分以下几类：</p>
<p>　　(1)、List：实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack，其中ArrayList是一个动态数组，LinkedList是一个双向链表，Vector是一个线程安全的动态数组，Stack是一个对象栈，遵循先进后出的原则。　　</p>
<p>　　(2)、Set：Set是不包含重复元素的集合，其主要实现类有：EnumSet、HashSet、TreeSet，其中EnumSet是枚举类型专用Set，所有元素都是枚举类型；HashSet是以哈希码决定其元素位置的Set，其原理与HashMap相似，它提供快速的插入和查找方法；TreeSet是一个自动排序的Set，它实现了SortedSet接口。</p>
<p>　　(3)、Map：Map是一个大家族，他可以分为排序Map和非排序Map，排序Map主要是TreeMap类，他根据key值进行自动排序；非排序Map主要包括：HashMap、HashTable、Properties、EnumMap等，其中Properties是HashTable的子类，它的主要用途是从Property文件中加载数据，并提供方便的操作，EnumMap则是要求其Key必须是某一个枚举类型。</p>
<p>　　　Map中还有一个WeakHashMap类需要说明，　　它是一个采用弱键方式实现的Map类，它的特点是：WeakHashMap对象的存在并不会阻止垃圾回收器对键值对的回收，也就是说使用WeakHashMap装载数据不用担心内存溢出的问题，GC会自动删除不用的键值对，这是好事。但也存在一个严重的问题：GC是静悄悄的回收的(何时回收，God，Knows！)我们的程序无法知晓该动作，存在着重大的隐患。</p>
<p>　　(4)、Queue：对列，它分为两类，一类是阻塞式队列，队列满了以后再插入元素会抛出异常，主要包括：ArrayBlockingQueue、PriorityQueue、LinkedBlockingQueue，其中ArrayBlockingQueue是一个以数组方式实现的有界阻塞队列；另一类是非阻塞队列，无边界的，只要内存允许，都可以持续追加元素，我们经常使用的是PriorityQuene类。</p>
<p>　　还有一种队列，是双端队列，支持在头、尾两端插入和移除元素，它的主要实现类是：ArrayDeque、LinkedBlockingDeque、LinkedList。</p>
<p>　　(5)、数组：数组与集合的最大区别就是数组能够容纳基本类型，而集合就不行，更重要的一点就是所有的集合底层存储的都是数组。</p>
<p>　　(6)、工具类：数组的工具类是java.util.Arrays和java.lang.reflect.Array，集合的工具类是java.util.Collections，有了这两个工具类，操作数组和集合就会易如反掌，得心应手。</p>
<p>　　(7)、扩展类：集合类当然可以自行扩展了，想写一个自己的List？没问题，但最好的办法还是”拿来主义”，可以使用Apache的common-collections扩展包，也可以使用Google的google-collections扩展包，这些足以应对我们的开发需要。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">CANDY</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://codercandy.github.io/2021/12/19/bian-xie-gao-zhi-liang-dai-ma-gai-shan-java-cheng-xu-de-151-ge-jian-yi-du-shu-bi-ji-shang/">https://codercandy.github.io/2021/12/19/bian-xie-gao-zhi-liang-dai-ma-gai-shan-java-cheng-xu-de-151-ge-jian-yi-du-shu-bi-ji-shang/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">CANDY</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%90%8E%E7%AB%AF/">
                                    <span class="chip bg-color">后端</span>
                                </a>
                            
                                <a href="/tags/java/">
                                    <span class="chip bg-color">java</span>
                                </a>
                            
                                <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
                                    <span class="chip bg-color">读书笔记</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC81NDg3My8zMTM0Mg==">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/12/19/yuan-gong-de-chi-zhi-cheng-ben/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="员工的离职成本">
                        
                        <span class="card-title">员工的离职成本</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-12-19
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%B7%A5%E4%BD%9C/" class="post-category">
                                    工作
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%9A%8F%E7%AC%94/">
                        <span class="chip bg-color">随笔</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/12/12/mi-ma-xue-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="密码学学习笔记">
                        
                        <span class="card-title">密码学学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-12-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">
                        <span class="chip bg-color">密码学</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('10')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 梓妤<br />'
            + '文章作者: Candy liu<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2023</span>
            
            <a href="/about" target="_blank">Candy liu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2021";
                        var startMonth = "12";
                        var startDate = "5";
                        var startHour = "22";
                        var startMinute = "49";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
<a href="https://gitee.com/CandyLoveYL" class="tooltipped" target="_blank" data-tooltip="访问我的gitee" data-position="top" data-delay="50">
	<i class="fab fa-github"></i>
</a>
<a href="mailto:595487347@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
	<i class="fas fa-envelope-open"></i>
</a>
<a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=595487347" class="tooltipped" target="_blank" data-tooltip="QQ联系我:595487347" data-position="top" data-delay="50">
	<i class="fab fa-qq"></i>
</a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
