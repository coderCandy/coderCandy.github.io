<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="《编写高质量代码 改善java程序的151个建议》读书笔记-下, Java,Flink,高级项目管理,Electron.js等">
    <meta name="description" content="《编写高质量代码 改善java程序的151个建议》读书笔记-下
本篇博客记录《编写高质量代码 改善java程序的151个建议》这本书的读书笔记。方便自己查看，也方便大家查阅，在此感谢原书作者秦小波对java的独特见解，帮助java爱好者的成">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	 <!- 图床 -->
	<meta name="referrer" content="no-referrer" />
	<!- 统计 -->
	<meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《编写高质量代码 改善java程序的151个建议》读书笔记-下 | 梓妤</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="梓妤" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">梓妤</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">梓妤</div>
        <div class="logo-desc">
            
            一个不懂生活的程序猿
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《编写高质量代码 改善java程序的151个建议》读书笔记-下</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%90%8E%E7%AB%AF/">
                                <span class="chip bg-color">后端</span>
                            </a>
                        
                            <a href="/tags/java/">
                                <span class="chip bg-color">java</span>
                            </a>
                        
                            <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
                                <span class="chip bg-color">读书笔记</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="post-category">
                                学习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-12-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-12-29
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    45k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>《编写高质量代码 改善java程序的151个建议》读书笔记-下</p>
<p>本篇博客记录《编写高质量代码 改善java程序的151个建议》这本书的读书笔记。方便自己查看，也方便大家查阅，在此感谢原书作者<a target="_blank" rel="noopener" href="https://weread.qq.com/web/reader/3cc32750597de83cc5abc31ke4d32d5015e4da3b7fbb1fa">秦小波</a>对java的独特见解，帮助java爱好者的成长。</p>
<h2><span id="第6章-枚举和注解">第6章 枚举和注解</span></h2><p>日光之下，并无新事。——《圣经》</p>
<p>​        枚举和注解都是在Java 1.5中引入的，虽然它们是后起之秀，但其功效不可小觑，枚举改变了常量的声明方式，注解耦合了数据和代码。本章就如何更好地使用注解和枚举提出了多条建议，以便读者能够在系统开发中更好地使用它们。</p>
<h3><span id="建议83推荐使用枚举定义常量">建议83：推荐使用枚举定义常量</span></h3><p>​        常量声明是每一个项目都不可或缺的，在Java1.5之前，我们只有两种方式的声明：类常量和接口常量，若在项目中使用的是Java1.5之前的版本，基本上都是如此定义的。不过，在1.5版本以后有了改进，即新增了一种常量声明方式：枚举声明常量，看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Season <span class="token punctuation">{</span>
    Spring<span class="token punctuation">,</span> Summer<span class="token punctuation">,</span> Autumn<span class="token punctuation">,</span> Winter<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        这是一个简单的枚举常量命名，清晰又简单。顺便提一句，JLS(Java Language Specification，Java语言规范)提倡枚举项全部大写，字母之间用下划线分割，这也是从常量的角度考虑的(当然，使用类似类名的命名方式也是比较友好的)。</p>
<p>　　那么枚举常量与我们经常使用的类常量和静态常量相比有什么优势？问得好，枚举的优点主要表现在四个方面：</p>
<p>1.枚举常量简单：简不简单，我们来对比一下两者的定义和使用情况就知道了。先把Season枚举翻写成接口常量，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Season</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> SPRING <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> SUMMER <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> AUTUMN <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> WINTER <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        此处定义了春夏秋冬四个季节，类型都是int，这与Season枚举的排序值是相同的。首先对比一下两者的定义，枚举常量只需定义每个枚举项，不需要定义枚举值，而接口常量(或类常量)则必须定义值，否则编译不通过，即使我们不需要关注其值是多少也必须定义；其次，虽然两者被引用的方式相同(都是 “类名 . 属性”，如Season.SPRING),但是枚举表示的是一个枚举项，字面含义是春天，而接口常量确是一个int类型，虽然其字面含义也是春天，但在运算中我们势必要关注其int值。</p>
<p>2.枚举常量属于稳态型</p>
<p>　　例如我们要描述一下春夏秋冬是什么样子，使用接口常量应该是这样写。　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">describe</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// s变量不能超越边界，校验条件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> Season<span class="token punctuation">.</span>SPRING<span class="token operator">:</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is spring"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> Season<span class="token punctuation">.</span>SUMMER<span class="token operator">:</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is summer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　很简单，先使用switch语句判断哪一个是常量，然后输出。但问题是我们得对输入值进行检查，确定是否越界，如果常量非常庞大，校验输入就成了一件非常麻烦的事情，但这是一个不可逃避的过程，特别是如果我们的校验条件不严格，虽然编译能照样通过，但是运行期就会产生无法预知的后果。</p>
<p>　　我们再来看看枚举常量是否能够避免校验的问题，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">describe</span><span class="token punctuation">(</span>Season s<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">case</span> Spring<span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is "</span><span class="token operator">+</span>Season<span class="token punctuation">.</span>Spring<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> Summer<span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is summer"</span><span class="token operator">+</span>Season<span class="token punctuation">.</span>Summer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>不用校验，已经限定了是Season枚举，所以只能是Season类的四个实例，即春夏秋冬4个枚举项，想输入一个int类型或其它类型？门都没有！这是我们最看重枚举的地方：<strong>在编译期间限定类型，不允许发生越界的情况</strong>。</p>
<p>3.枚举具有内置方法</p>
<p>　　有一个简单的问题：如果要列出所有的季节常量，如何实现呢？接口常量或类常量可以通过反射来实现，这没错，只是虽然能实现，但会非常繁琐，大家可以自己写一个反射类实现此功能(当然，一个一个地动手打印出输出常量，也可以算是列出)。对于此类问题可以非常简单的解决，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Season s <span class="token operator">:</span> Season<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>通过values方法获得所有的枚举项，然后打印出来即可。如此简单，得益于枚举内置的方法，每个枚举都是java.lang.Enum的子类，该基类提供了诸如获得排序值的ordinal方法、compareTo比较方法等，大大简化了常量的访问。</p>
<p>4.枚举可以自定义的方法</p>
<p>　　这一点似乎并不是枚举的优点，类常量也可以有自己的方法呀，但关键是枚举常量不仅可以定义静态方法，还可以定义非静态方法，而且还能够从根本上杜绝常量类被实例化。比如我们要在常量定义中获得最舒服季节的方法，使用常量枚举的代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Season <span class="token punctuation">{</span>
    Spring<span class="token punctuation">,</span> Summer<span class="token punctuation">,</span> Autumn<span class="token punctuation">,</span> Winter<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Season <span class="token function">getComfortableSeason</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> Spring<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　我们知道，每个枚举项都是该枚举的一个实例，对于我们的例子来说，也就表示Spring其实是Season的一个实例，Summer也是其中一个实例，那我们在枚举中定义的静态方法既可以在类(也就是枚举Season)中引用，也可以在实例(也就是枚举项Spring、Summer、Autumn、Winter)中引用，看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The most comfortable season is "</span><span class="token operator">+</span>Season<span class="token punctuation">.</span><span class="token function">getComfortableSeason</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>那如果使用类常量要如何实现呢？代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Season</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> SPRING <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> SUMMER <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> AUTUMN <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> WINTER <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token keyword">int</span> <span class="token function">getComfortableSeason</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> SPRING<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>想想看，我们怎么才能打印出”The most comfortable season is Spring” 这句话呢？除了使用switch和if判断之外没有其它办法了。</p>
<p>　　虽然枚举在很多方面比接口常量和类常量好用，但是有一点它是比不上接口常量和类常量的，那就是继承，枚举类型是不能继承的，也就是说一个枚举常量定义完毕后，除非修改重构，否则无法做扩展，而接口常量和类常量则可以通过继承进行扩展。但是，一般常量在项目构建时就定义完毕了，很少会出现必须通过扩展才能实现业务逻辑的场景。</p>
<p><strong><font color="red">注意： 在项目中推荐使用枚举常量代替接口常量或类常量。</font></strong></p>
<h3><span id="建议84使用构造函数协助描述枚举项">建议84：使用构造函数协助描述枚举项</span></h3><p>​    　一般来说，我们经常使用的枚举项只有一个属性，即排序号，其默认值是从0、1、2……，这一点我们很熟悉，但是除了排序号之外，枚举还有一个(或多个)属性：枚举描述，他的含义是通过枚举的构造函数，声明每个枚举项(也就是枚举的实例)必须具有的属性和行为，这是对枚举项的描述或补充，目的是使枚举项描述的意义更加清晰准确。例如有这样一段代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Season <span class="token punctuation">{</span>
    <span class="token function">Spring</span><span class="token punctuation">(</span><span class="token string">"春"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Summer</span><span class="token punctuation">(</span><span class="token string">"夏"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Autumn</span><span class="token punctuation">(</span><span class="token string">"秋"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Winter</span><span class="token punctuation">(</span><span class="token string">"冬"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> String desc<span class="token punctuation">;</span>

    <span class="token function">Season</span><span class="token punctuation">(</span>String _desc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        desc <span class="token operator">=</span> _desc<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//获得枚举描述</span>
    <span class="token keyword">public</span> String <span class="token function">getDesc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> desc<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    其枚举选项是英文的，描述是中文的，如此设计使其表述的意义更加精确，方便了多个作者共同引用该常量。若不考虑描述的使用（即访问getDesc方法），它与如下接口定义的描述很相似：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Season</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//春</span>
    <span class="token keyword">int</span> SPRING <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//夏</span>
    <span class="token keyword">int</span> SUMMER <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//......</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　比较两段代码，很容易看出使用枚举项描述是一个很好的解决办法，非常简单、清晰。因为是一个描述(Description)，那我们在开发时就可以赋予更多的含义，比如可以通过枚举构造函数声明业务值，定义可选项，添加属性等，看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Role <span class="token punctuation">{</span>
    <span class="token function">Admin</span><span class="token punctuation">(</span><span class="token string">"管理员"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LifeTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"普通用户"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LifeTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> LifeTime lifeTime<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Scope scope<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* setter和getter方法略 */</span>

    <span class="token function">Role</span><span class="token punctuation">(</span>String _name<span class="token punctuation">,</span> LifeTime _lifeTime<span class="token punctuation">,</span> Scope _scope<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> _name<span class="token punctuation">;</span>
        lifeTime <span class="token operator">=</span> _lifeTime<span class="token punctuation">;</span>
        scope <span class="token operator">=</span> _scope<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">LifeTime</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Scope</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这是一个角色定义类，描述了两个角色：管理员和普通用户，同时它还通过构造函数对这两个角色进行了描述：</p>
<ul>
<li>name：表示的是该角色的中文名称</li>
<li>lifeTime：表示的是该角色的生命周期，也就是多长时间该角色失效</li>
<li>scope：表示的该角色的权限范围</li>
</ul>
<p>　　大家可以看出，这样一个描述可以使开发者对Admin和User两个常量有一个立体多维度的认知，有名称，有周期，还有范围，而且还可以在程序中方便的获得此类属性。所以，推荐大家在枚举定义中为每个枚举项定义描述，特别是在大规模的项目开发中，大量的常量定义使用枚举项描述比在接口常量或类常量中增加注释的方式友好的多，简洁的多。</p>
<h3><span id="建议85小心switch带来的空指针异常">建议85：小心switch带来的空指针异常</span></h3><p>使用枚举定义常量时。会伴有大量switch语句判断，目的是为了每个枚举项解释其行为，例如这样一个方法：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSports</span><span class="token punctuation">(</span>Season season<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>season<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> Spring<span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"春天放风筝"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> Summer<span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"夏天游泳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> Autumn<span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"秋天是收获的季节"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> Winter<span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"冬天滑冰"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输出错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面的代码传入了一个Season类型的枚举，然后使用switch进行匹配，目的是输出每个季节的活动，现在的问题是这段代码又没有问题：</p>
<p>　　我们先来看看它是如何被调用的，因为要传递进来的是Season类型，也就是一个实例对象，那当然允许为空了，我们就传递一个null值进去看看代码又没有问题，如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">doSports</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　似乎会打印出“输出错误”，因为switch中没有匹配到指定值，所以会打印出defaut的代码块，是这样的吗？不是，运行后的结果如下：</p>
<pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>NullPointerException
    at com<span class="token punctuation">.</span>book<span class="token punctuation">.</span>study85<span class="token punctuation">.</span>Client85<span class="token punctuation">.</span><span class="token function">doSports</span><span class="token punctuation">(</span>Client85<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">8</span><span class="token punctuation">)</span>
    at com<span class="token punctuation">.</span>book<span class="token punctuation">.</span>study85<span class="token punctuation">.</span>Client85<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>Client85<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">)</span>
</code></pre>
<p>　    竟然是空指针异常，也就是switch的那一行，怎么会有空指针呢？这就与枚举和switch的特性有关了，此问题也是在开发中经常发生的。我们知道，目前Java中的switch语句只能判断byte、short、char、int类型（JDk7允许使用String类型），这是Java编译器的限制。问题是为什么枚举类型也可以跟在switch后面呢？</p>
<p>　　因为编译时，编译器判断出switch语句后跟的参数是枚举类型，然后就会根据枚举的排序值继续匹配，也就是或上面的代码与以下代码相同：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSports</span><span class="token punctuation">(</span>Season season<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>season<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> season<span class="token punctuation">.</span>Spring<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"春天放风筝"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> season<span class="token punctuation">.</span>Summer<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"夏天游泳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//......</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    看明白了吧，switch语句是先计算season变量的排序值，然后与枚举常量的每个排序值进行对比，在我们的例子中season是null，无法执行ordinal()方法，于是就报空指针异常了。问题清楚了，解决很简单，在doSports方法中判断输入参数是否为null即可。</p>
<h3><span id="建议86在switch的default代码块中增加assertionerror错误">建议86：在switch的default代码块中增加AssertionError错误</span></h3><p>​        switch后跟枚举类型，case后列出所有的枚举项，这是一个使用枚举的主流写法，那留着default语句似乎没有任何作用，程序已经列举了所有的可能选项，肯定不会执行到defaut语句，看上去纯属多余嘛！错了，这个default还是很有作用的。以我们定义的日志级别来说明，这是一个典型的枚举常量，如下所示:　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> LogLevel<span class="token punctuation">{</span>
    DEBUG<span class="token punctuation">,</span>INFO<span class="token punctuation">,</span>WARN<span class="token punctuation">,</span>ERROR
<span class="token punctuation">}</span>
</code></pre>
<p>　　一般在使用的时候，会通过switch语句来决定用户设置的日志级别，然后输出不同级别的日志代码，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">switch</span><span class="token punctuation">(</span>LogLevel<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">case</span><span class="token operator">:</span>DEBUG<span class="token operator">:</span>
        <span class="token comment" spellcheck="true">//.....</span>
    <span class="token keyword">case</span><span class="token operator">:</span>INFO<span class="token operator">:</span>
        <span class="token comment" spellcheck="true">//......</span>
    <span class="token keyword">case</span><span class="token operator">:</span>WARN<span class="token operator">:</span>
        <span class="token comment" spellcheck="true">//......</span>
    <span class="token keyword">case</span><span class="token operator">:</span>ERROR<span class="token operator">:</span>
        <span class="token comment" spellcheck="true">//......</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　由于把所有的枚举项都列举完了，不可能有其它值，所以就不需要default代码快了，这是普遍认识，但问题是我们的switch代码与枚举之间没有强制约束关系，也就是说两者只是在语义上建立了联系，并没有一个强制约束，比如LogLevel的枚举项发生变化了，增加了一个枚举项FATAL，如果此时我们对switch语句不做任何修改，编译虽不会出问题，但是运行期会发生非预期的错误：FATAL类型的日志没有输出。</p>
<p>　　为了避免出现这类错误，建议在default后直接抛出一个AssertionError错误，其含义就是“不要跑到这里来，一跑到这里就会出问题”，这样可以保证在增加一个枚举项的情况下，若其它代码未修改，运行期马上就会出错，这样一来就很容易找到错误，方便立即排除。</p>
<p>　　<strong>当然也有其它方法解决此问题，比如修改IDE工具，以Eclipse为例，可以把Java–&gt;Compiler—&gt;Errors/Warnings中的“Enum type constant not covered on ‘switch’ ”设置为Error级别，如果不判断所有的枚举项就不能编译通过。</strong></p>
<h3><span id="建议87使用valueof前必须进行校验">建议87：使用valueOf前必须进行校验</span></h3><p>　　我们知道每个枚举项都是java.lang.Enum的子类，都可以访问Enum类提供的方法，比如hashCode、name、valueOf等，其中valueOf方法会把一个String类型的名称转换为枚举项，也就是在枚举项中查找出字面值与参数相等的枚举项。虽然这个方法简单，但是JDK却做了一个对于开发人员来说并不简单的处理，我们来看代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 注意summer是小写</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> params <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Spring"</span><span class="token punctuation">,</span> <span class="token string">"summer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 查找字面值与name相同的枚举项，其中Season是前面例子中枚举Season</span>
        Season s <span class="token operator">=</span> Season<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 有枚举项时</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 没有该枚举项</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"无相关枚举项"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这段程序看起来没什么错吧，其中考虑到从String转换为枚举类型可能存在着转换不成功的情况，比如没有匹配找到指定值，此时ValueOf的返回值应该为空，所以后面又跟着if…else判断输出。我们看看运行结果　</p>
<pre class=" language-java"><code class="language-java">Spring
Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>IllegalArgumentException<span class="token operator">:</span> No <span class="token keyword">enum</span> constant com<span class="token punctuation">.</span>book<span class="token punctuation">.</span>study01<span class="token punctuation">.</span>Season<span class="token punctuation">.</span>summer
    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Enum<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>
    at com<span class="token punctuation">.</span>book<span class="token punctuation">.</span>study01<span class="token punctuation">.</span>Season<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>Season<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">)</span>
    at com<span class="token punctuation">.</span>book<span class="token punctuation">.</span>study85<span class="token punctuation">.</span>Client85<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>Client85<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">14</span><span class="token punctuation">)</span>
</code></pre>
<p>　　报无效的参数异常，也就说我们的summer(注意s是小写)，无法转换为Season枚举，无法转换就 不转换嘛，那也别抛出IllegalArgumentException异常啊，一但抛出这个异常，后续的代码就不会执行了，这与我们的习惯不符合呀，例如我们从List中查找一个元素，即使不存在也不会报错，顶多indexOf方法返回-1。那么我们来深入分析一下该问题，valueOf方法的源代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> T <span class="token function">valueOf</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> enumType<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//通过反射，从常量列表中查找</span>
    T result <span class="token operator">=</span> enumType<span class="token punctuation">.</span><span class="token function">enumConstantDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> null<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"Name is null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//最后抛出无效参数异常</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No enum constant "</span> <span class="token operator">+</span> enumType<span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　valueOf方法先通过反射从枚举类的常量声明中查找，若找到就直接返回，若找不到则抛出无效参数异常。valueOf的本意是保护编码中的枚举安全性，使其不产生空枚举对象，简化枚举操作，但是却引入了一个我们无法避免的IllegalArgumentException异常。</p>
<p>　　大家是否觉得此处的valueOf方法的源码不对，这里要输入两个参数，而我们的Season.valueOf只传递一个String类型的参数，真的是这样吗？是的，因为valueOf（String name）方法是不可见的，是JVM内置的方法，我们只有通过阅读公开的valueOf方法来了解其运行原理了。</p>
<p>　　问题清楚了，有两个方法可以解决此问题：</p>
<p>　　(1)、使用try……catch捕捉异常</p>
<p>　　这里是最直接也是最简单的方式，产生IllegalArgumentException即可确认为没有同名的枚举的枚举项，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>
    Season s <span class="token operator">=</span> Season<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//有该枚举项时</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"无相关枚举项"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　(2)、扩展枚举类：由于Enum类定义的方法基本上都是final类型的，所以不希望被覆写，我们可以学习String和List，通过增加一个contains方法来判断是否包含指定的枚举项，然后再继续转换，代码如下。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Season <span class="token punctuation">{</span>
    Spring<span class="token punctuation">,</span> Summer<span class="token punctuation">,</span> Autumn<span class="token punctuation">,</span> Winter<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 是否包含指定的枚举项</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 所有的枚举值</span>
        Season<span class="token punctuation">[</span><span class="token punctuation">]</span> season <span class="token operator">=</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Season s <span class="token operator">:</span> season<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　Season枚举具备了静态方法contains后，就可以在valueOf前判断一下是否包含指定的枚举名称了，若包含则可以通过valueOf转换为枚举，若不包含则不转换。</p>
<h3><span id="建议88用枚举实现工厂方法模式更简洁">建议88：用枚举实现工厂方法模式更简洁</span></h3><p>​        工厂方法模式(Factory Method Pattern)是” 创建对象的接口，让子类决定实例化哪一个类，并使一个类的实例化延迟到其它子类”。工厂方法模式在我们的开发中经常会用到。下面以汽车制造为例，看看一般的工厂方法模式是如何实现的，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象产品</span>
<span class="token keyword">interface</span> <span class="token class-name">Car</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//具体产品类</span>
<span class="token keyword">class</span> <span class="token class-name">FordCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//具体产品类</span>
<span class="token keyword">class</span> <span class="token class-name">BuickCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//工厂类</span>
<span class="token keyword">class</span> <span class="token class-name">CarFactory</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//生产汽车</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Car <span class="token function">createCar</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Car</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> <span class="token operator">|</span> IllegalAccessException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这是最原始的工厂方法模式，有两个产品：福特汽车和别克汽车，然后通过工厂方法模式来生产。有了工厂方法模式，我们就不用关心一辆车具体是怎么生成的了，只要告诉工厂” 给我生产一辆福特汽车 “就可以了，下面是产出一辆福特汽车时客户端的代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//生产车辆</span>
    Car car <span class="token operator">=</span> CarFactory<span class="token punctuation">.</span><span class="token function">createCar</span><span class="token punctuation">(</span>FordCar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这就是我们经常使用的工厂方法模式，但经常使用并不代表就是最优秀、最简洁的。此处再介绍一种通过枚举实现工厂方法模式的方案，谁优谁劣你自行评价。枚举实现工厂方法模式有两种方法：</p>
<p>(1)、枚举非静态方法实现工厂方法模式</p>
<p>　　我们知道每个枚举项都是该枚举的实例对象，那是不是定义一个方法可以生成每个枚举项对应产品来实现此模式呢？代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> CarFactory <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 定义生产类能生产汽车的类型</span>
    FordCar<span class="token punctuation">,</span> BuickCar<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 生产汽车</span>
    <span class="token keyword">public</span> Car <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> FordCar<span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FordCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> BuickCar<span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BuickCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token string">"无效参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　create是一个非静态方法，也就是只有通过FordCar、BuickCar枚举项才能访问。采用这种方式实现工厂方法模式时，客户端要生产一辆汽车就很简单了，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 生产车辆</span>
    Car car <span class="token operator">=</span> CarFactory<span class="token punctuation">.</span>BuickCar<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>(2)、通过抽象方法生成产品</p>
<p>　　枚举类型虽然不能继承，但是可以用abstract修饰其方法，此时就表示该枚举是一个抽象枚举，需要每个枚举项自行实现该方法，也就是说枚举项的类型是该枚举的一个子类，我们俩看代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> CarFactory <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 定义生产类能生产汽车的类型</span>
    FordCar<span class="token punctuation">{</span>
        <span class="token keyword">public</span> Car <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FordCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    BuickCar<span class="token punctuation">{</span>
        <span class="token keyword">public</span> Car <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BuickCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//抽象生产方法</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Car <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　首先定义一个抽象制造方法create，然后每个枚举项自行实现，这种方式编译后会产生CarFactory的匿名子类，因为每个枚举项都要实现create抽象方法。客户端调用与上一个方案相同，不再赘述。</p>
<p>　　大家可能会问，为什么要使用枚举类型的工厂方法模式呢？那是因为使用枚举类型的工厂方法模式有以下三个优点：</p>
<ul>
<li>避免错误调用的发生：一般工厂方法模式中的生产方法(也就是createCar方法)，可以接收三种类型的参数：类型参数(如我们的例子)、String参数(生产方法中判断String参数是需要生产什么产品)、int参数(根据int值判断需要生产什么类型的的产品)，这三种参数都是宽泛的数据类型，很容易发生错误(比如边界问题、null值问题)，而且出现这类错误编译器还不会报警，例如：</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 生产车辆</span>
    Car car <span class="token operator">=</span> CarFactory<span class="token punctuation">.</span><span class="token function">createCar</span><span class="token punctuation">(</span>Car<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　Car是一个接口，完全合乎createCar的要求，所以它在编译时不会报任何错误，但一运行就会报出InstantiationException异常，而使用枚举类型的工厂方法模式就不存在该问题了，不需要传递任何参数，只需要选择好生产什么类型的产品即可。</p>
<ul>
<li>性能好，使用简洁：枚举类型的计算时以int类型的计算为基础的，这是最基本的操作，性能当然会快，至于使用便捷，注意看客户端的调用，代码的字面意思就是” 汽车工厂，我要一辆别克汽车，赶快生产”。</li>
<li>降低类间耦合：不管生产方法接收的是Class、String还是int的参数，都会成为客户端类的负担，这些类并不是客户端需要的，而是因为工厂方法的限制必须输入的，例如Class参数，对客户端main方法来说，他需要传递一个FordCar.class参数才能生产一辆福特汽车，除了在create方法中传递参数外，业务类不需要改Car的实现类。这严重违背了迪米特原则(Law of Demeter 简称LoD),也就是最少知识原则：一个对象应该对其它对象有最少的了解。</li>
</ul>
<p>　　而枚举类型的工厂方法就没有这种问题了，它只需要依赖工厂类就可以生产一辆符合接口的汽车，完全可以无视具体汽车类的存在。</p>
<h3><span id="建议89枚举项的数量限制在64个以内">建议89：枚举项的数量限制在64个以内</span></h3><p>　为了更好地使用枚举，Java提供了两个枚举集合：EnumSet和EnumMap，这两个集合使用的方法都比较简单，EnumSet表示其元素必须是某一枚举的枚举项，EnumMap表示Key值必须是某一枚举的枚举项，由于枚举类型的实例数量固定并且有限，相对来说EnumSet和EnumMap的效率会比其它Set和Map要高。</p>
<p>   虽然EnumSet很好用，但是它有一个隐藏的特点，我们逐步分析。在项目中一般会把枚举用作常量定义，可能会定义非常多的枚举项，然后通过EnumSet访问、遍历，但它对不同的枚举数量有不同的处理方式。为了进行对比，我们定义两个枚举，一个数量等于64，一个是65（大于64即可，为什么是64而不是128,512呢，一会解释），代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//普通枚举项，数量等于64</span>
<span class="token keyword">enum</span> Const<span class="token punctuation">{</span>
    A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">,</span>D<span class="token punctuation">,</span>E<span class="token punctuation">,</span>F<span class="token punctuation">,</span>G<span class="token punctuation">,</span>H<span class="token punctuation">,</span>I<span class="token punctuation">,</span>J<span class="token punctuation">,</span>K<span class="token punctuation">,</span>L<span class="token punctuation">,</span>M<span class="token punctuation">,</span>N<span class="token punctuation">,</span>O<span class="token punctuation">,</span>P<span class="token punctuation">,</span>Q<span class="token punctuation">,</span>R<span class="token punctuation">,</span>S<span class="token punctuation">,</span>T<span class="token punctuation">,</span>U<span class="token punctuation">,</span>V<span class="token punctuation">,</span>W<span class="token punctuation">,</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">,</span>Z<span class="token punctuation">,</span>
    AA<span class="token punctuation">,</span>BB<span class="token punctuation">,</span>CC<span class="token punctuation">,</span>DD<span class="token punctuation">,</span>EE<span class="token punctuation">,</span>FF<span class="token punctuation">,</span>GG<span class="token punctuation">,</span>HH<span class="token punctuation">,</span>II<span class="token punctuation">,</span>JJ<span class="token punctuation">,</span>KK<span class="token punctuation">,</span>LL<span class="token punctuation">,</span>MM<span class="token punctuation">,</span>NN<span class="token punctuation">,</span>OO<span class="token punctuation">,</span>PP<span class="token punctuation">,</span>QQ<span class="token punctuation">,</span>RR<span class="token punctuation">,</span>SS<span class="token punctuation">,</span>TT<span class="token punctuation">,</span>UU<span class="token punctuation">,</span>VV<span class="token punctuation">,</span>WW<span class="token punctuation">,</span>XX<span class="token punctuation">,</span>YY<span class="token punctuation">,</span>ZZ<span class="token punctuation">,</span>
    AAA<span class="token punctuation">,</span>BBB<span class="token punctuation">,</span>CCC<span class="token punctuation">,</span>DDD<span class="token punctuation">,</span>EEE<span class="token punctuation">,</span>FFF<span class="token punctuation">,</span>GGG<span class="token punctuation">,</span>HHH<span class="token punctuation">,</span>III<span class="token punctuation">,</span>JJJ<span class="token punctuation">,</span>KKK<span class="token punctuation">,</span>LLL
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//大枚举，数量超过64</span>
<span class="token keyword">enum</span> LargeConst<span class="token punctuation">{</span>
    A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">,</span>D<span class="token punctuation">,</span>E<span class="token punctuation">,</span>F<span class="token punctuation">,</span>G<span class="token punctuation">,</span>H<span class="token punctuation">,</span>I<span class="token punctuation">,</span>J<span class="token punctuation">,</span>K<span class="token punctuation">,</span>L<span class="token punctuation">,</span>M<span class="token punctuation">,</span>N<span class="token punctuation">,</span>O<span class="token punctuation">,</span>P<span class="token punctuation">,</span>Q<span class="token punctuation">,</span>R<span class="token punctuation">,</span>S<span class="token punctuation">,</span>T<span class="token punctuation">,</span>U<span class="token punctuation">,</span>V<span class="token punctuation">,</span>W<span class="token punctuation">,</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">,</span>Z<span class="token punctuation">,</span>
    AA<span class="token punctuation">,</span>BB<span class="token punctuation">,</span>CC<span class="token punctuation">,</span>DD<span class="token punctuation">,</span>EE<span class="token punctuation">,</span>FF<span class="token punctuation">,</span>GG<span class="token punctuation">,</span>HH<span class="token punctuation">,</span>II<span class="token punctuation">,</span>JJ<span class="token punctuation">,</span>KK<span class="token punctuation">,</span>LL<span class="token punctuation">,</span>MM<span class="token punctuation">,</span>NN<span class="token punctuation">,</span>OO<span class="token punctuation">,</span>PP<span class="token punctuation">,</span>QQ<span class="token punctuation">,</span>RR<span class="token punctuation">,</span>SS<span class="token punctuation">,</span>TT<span class="token punctuation">,</span>UU<span class="token punctuation">,</span>VV<span class="token punctuation">,</span>WW<span class="token punctuation">,</span>XX<span class="token punctuation">,</span>YY<span class="token punctuation">,</span>ZZ<span class="token punctuation">,</span>
    AAAA<span class="token punctuation">,</span>BBBB<span class="token punctuation">,</span>CCCC<span class="token punctuation">,</span>DDDD<span class="token punctuation">,</span>EEEE<span class="token punctuation">,</span>FFFF<span class="token punctuation">,</span>GGGG<span class="token punctuation">,</span>HHHH<span class="token punctuation">,</span>IIII<span class="token punctuation">,</span>JJJJ<span class="token punctuation">,</span>KKKK<span class="token punctuation">,</span>LLLL<span class="token punctuation">,</span>MMMM
<span class="token punctuation">}</span>
</code></pre>
<p>​    Const的枚举项数量是64，LagrgeConst的枚举项数量是65,接下来我们希望把这两个枚举转换为EnumSet，然后判断一下它们的class类型是否相同，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client89</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        EnumSet<span class="token operator">&lt;</span>Const<span class="token operator">></span> cs <span class="token operator">=</span> EnumSet<span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>Const<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        EnumSet<span class="token operator">&lt;</span>LargeConst<span class="token operator">></span> lcs <span class="token operator">=</span> EnumSet<span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>LargeConst<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//打印出枚举数量</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Const的枚举数量："</span><span class="token operator">+</span>cs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LargeConst的枚举数量："</span><span class="token operator">+</span>lcs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//输出两个EnumSet的class</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cs<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>lcs<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        程序很简单，现在的问题是：cs和lcs的class类型是否相同？应该相同吧，都是EnumSet类的工厂方法allOf生成的EnumSet类，而且JDK API也没有提示EnumSet有子类。我们来看看输出结果：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160927105808235-1641372744.png" alt="img"></p>
<p>​        很遗憾，两者不相等。就差一个元素，两者就不相等了？确实如此，这也是我们重点关注枚举项数量的原因。先来看看Java是如何处理的，首先跟踪allOf方法，其源码如下： 　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>E<span class="token operator">>></span> EnumSet<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">allOf</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>E<span class="token operator">></span> elementType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//生成一个空EnumSet</span>
    EnumSet<span class="token operator">&lt;</span>E<span class="token operator">></span> result <span class="token operator">=</span> <span class="token function">noneOf</span><span class="token punctuation">(</span>elementType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//加入所有的枚举项</span>
    result<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　allOf通过noneOf方法首先生成了一个EnumSet对象，然后把所有的枚举都加进去，问题可能就出在EnumSet的生成上了，我们来看看noneOf的源码：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>E<span class="token operator">>></span> EnumSet<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">noneOf</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>E<span class="token operator">></span> elementType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//获得所有的枚举项</span>
    Enum<span class="token punctuation">[</span><span class="token punctuation">]</span> universe <span class="token operator">=</span> <span class="token function">getUniverse</span><span class="token punctuation">(</span>elementType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>universe <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassCastException</span><span class="token punctuation">(</span>elementType <span class="token operator">+</span> <span class="token string">" not an enum"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//枚举数量小于等于64</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>universe<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">64</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegularEnumSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>elementType<span class="token punctuation">,</span> universe<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment" spellcheck="true">//枚举数量大于64</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JumboEnumSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>elementType<span class="token punctuation">,</span> universe<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    看到这里，恍然大悟，Java原来是如此处理的：当枚举项数量小于等于64时，创建一个RegularEnumSet实例对象，大于64时则创建一个JumboEnumSet实例对象。</p>
<p>　　为什么要如此处理呢？这还要看看这两个类之间的差异，首先看RegularEnumSet类，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">RegularEnumSet</span><span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>E<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">EnumSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 3411599620347842686L<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * Bit vector representation of this set.  The 2^k bit indicates the
     * presence of universe[k] in this set.
     */</span>
    <span class="token comment" spellcheck="true">//记录所有的枚举号，注意是long型</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> elements <span class="token operator">=</span> 0L<span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">//构造函数</span>
    <span class="token function">RegularEnumSet</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>E<span class="token operator">></span>elementType<span class="token punctuation">,</span> Enum<span class="token punctuation">[</span><span class="token punctuation">]</span> universe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>elementType<span class="token punctuation">,</span> universe<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

   <span class="token comment" spellcheck="true">//加入所有元素</span>
    <span class="token keyword">void</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>universe<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            elements <span class="token operator">=</span> <span class="token operator">-</span>1L <span class="token operator">>>></span> <span class="token operator">-</span>universe<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

   <span class="token comment" spellcheck="true">//其它代码略</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​        我们知道枚举项的排序值ordinal 是从0、1、2……依次递增的，没有重号，没有跳号，RegularEnumSet就是利用这一点把每个枚举项的ordinal映射到一个long类型的每个位置上的，注意看addAll方法的elements元素，它使用了无符号右移操作，并且操作数是负值，位移也是负值，这表示是负数(符号位是1)的”无符号左移”：符号位为0，并补充低位，简单的说，Java把一个不多于64个枚举项映射到了一个long类型变量上。这才是EnumSet处理的重点，其他的size方法、contains方法等都是根据elements方法等都是根据elements计算出来的。想想看，一个long类型的数字包含了所有的枚举项，其效率和性能能肯定是非常优秀的。</p>
<p>　　我们知道long类型是64位的，所以RegularEnumSet类型也就只能负责枚举项的数量不大于64的枚举(这也是我们以64来举例，而不以128,512举例的原因)，大于64则由JumboEnumSet处理，我们看它是怎么处理的：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">JumboEnumSet</span><span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>E<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">EnumSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 334349849919042784L<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * Bit vector representation of this set.  The ith bit of the jth
     * element of this array represents the  presence of universe[64*j +i]
     * in this set.
     */</span>
    <span class="token comment" spellcheck="true">//映射所有的枚举项</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> elements<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Redundant - maintained for performance</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">JumboEnumSet</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>E<span class="token operator">></span>elementType<span class="token punctuation">,</span> Enum<span class="token punctuation">[</span><span class="token punctuation">]</span> universe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>elementType<span class="token punctuation">,</span> universe<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//默认长度是枚举项数量除以64再加1</span>
        elements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">long</span><span class="token punctuation">[</span><span class="token punctuation">(</span>universe<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">63</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//elements中每个元素表示64个枚举项</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        elements<span class="token punctuation">[</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>>>=</span> <span class="token operator">-</span>universe<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        size <span class="token operator">=</span> universe<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　JumboEnumSet类把枚举项按照64个元素一组拆分成了多组，每组都映射到一个long类型的数字上，然后该数组再放置到elements数组中，简单来说JumboEnumSet类的原理与RegularEnumSet相似，只是JumboEnumSet使用了long数组容纳更多的枚举项。不过，这样的程序看着会不会觉得郁闷呢？其实这是因为我们在开发中很少使用位移操作。大家可以这样理解：RegularEnumSet是把每个枚举项映射到一个long类型数字的每个位上，JumboEnumSet是先按照64个一组进行拆分，然后每个组再映射到一个long类型数字的每个位上。</p>
<p>　　从以上的分析可知，EnumSet提供的两个实现都是基本的数字类型操作，其性能肯定比其他的Set类型要好的多，特别是Enum的数量少于64的时候，那简直就是飞一般的速度。</p>
<p>　　<strong>注意：枚举项数量不要超过64，否则建议拆分。</strong></p>
<h3><span id="建议90小心注解继承">建议90：小心注解继承</span></h3><p>　Java从1.5版本开始引入注解(Annotation),其目的是在不影响代码语义的情况下增强代码的可读性，并且不改变代码的执行逻辑，对于注解始终有两派争论，正方认为注解有益于数据与代码的耦合，”在有代码的周边集合数据”；反方认为注解把代码和数据混淆在一起，增加了代码的易变性，消弱了程序的健壮性和稳定性。这些争论暂且搁置，我们要说的是一个我们不常用的元注解(Meta-Annotation):@Inheruted,它表示一个注解是否可以自动继承，我们开看它如何使用。</p>
<p>　　思考一个例子，比如描述鸟类，它有颜色、体型、习性等属性，我们以颜色为例，定义一个注解来修饰一下，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Inherited<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Inherited</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Desc</span> <span class="token punctuation">{</span>
    <span class="token keyword">enum</span> Color <span class="token punctuation">{</span>
        White<span class="token punctuation">,</span> Grayish<span class="token punctuation">,</span> Yellow
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 默认颜色是白色的</span>
    Color <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> Color<span class="token punctuation">.</span>White<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　该注解Desc前增加了三个注解：Retention表示的是该注解的保留级别，Target表示的是注解可以标注在什么地方，@Inherited表示该注解会被自动继承。注解定义完毕，我们把它标注在类上，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Desc</span><span class="token punctuation">(</span>c <span class="token operator">=</span> Color<span class="token punctuation">.</span>White<span class="token punctuation">)</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Color <span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 麻雀</span>
<span class="token keyword">class</span> <span class="token class-name">Sparrow</span> <span class="token keyword">extends</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Color color<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 默认是浅灰色</span>
    <span class="token keyword">public</span> <span class="token function">Sparrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Grayish<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 构造函数定义鸟的颜色</span>
    <span class="token keyword">public</span> <span class="token function">Sparrow</span><span class="token punctuation">(</span>Color _color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        color <span class="token operator">=</span> _color<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Color <span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> color<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 鸟巢，工厂方法模式</span>
<span class="token keyword">enum</span> BirdNest <span class="token punctuation">{</span>
    Sparrow<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 鸟类繁殖</span>
    <span class="token keyword">public</span> Bird <span class="token function">reproduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Desc bd <span class="token operator">=</span> Sparrow<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>Desc<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> bd <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">Sparrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Sparrow</span><span class="token punctuation">(</span>bd<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　上面程序声明了一个Bird抽象类，并且标注了Desc注解，描述鸟类的颜色是白色，然后编写一个麻雀Sparrow类，它有两个构造函数，一个是默认的构造函数，也就是我们经常看到的麻雀是浅灰色的，另外一个构造函数是自定义麻雀的颜色，之后又定义了一个鸟巢(工厂方法模式)，它是专门负责鸟类繁殖的，它的生产方法reproduce会根据实现类注解信息生成不同颜色的麻雀。我们编写一个客户端调用，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Bird bird <span class="token operator">=</span> BirdNest<span class="token punctuation">.</span>Sparrow<span class="token punctuation">.</span><span class="token function">reproduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Color color <span class="token operator">=</span> bird<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Bird's color is :"</span> <span class="token operator">+</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    现在问题是这段客户端程序会打印出什么来？因为采用了工厂方法模式，它最主要的问题就是bird变量到底采用了那个构造函数来生成，是无参构造函数还是有参构造？如果我们单独看子类Sparrow，它没有被添加任何注释，那工厂方法中的bd变量就应该是null了，应该调用的是无参构造。是不是如此呢？我们来看运行结果：“Bird‘s Color is White ”；</p>
<p>　　白色？这是我们添加到父类Bird上的颜色，为什么？这是因为我们在注解上加了@Inherited注解，它表示的意思是我们只要把注解@Desc加到父类Bird上，它的所有子类都会从父类继承@Desc注解，不需要显示声明，这与Java的继承有点不同，若Sparrow类继承了Bird却不用显示声明，只要@Desc注解释可自动继承的即可。</p>
<p>　　采用@Inherited元注解有利有弊，利的地方是一个注解只要标注到父类，所有的子类都会自动具有父类相同的注解，整齐，统一而且便于管理，弊的地方是单单阅读子类代码，我们无从知道为何逻辑会被改变，因为子类没有显示标注该注解。总体上来说，使用@Inherited元注解弊大于利，特别是一个类的继承层次较深时，如果注解较多，则很难判断出那个注解对子类产生了逻辑劫持。</p>
<h3><span id="建议91枚举和注解结合使用威力更大">建议91：枚举和注解结合使用威力更大</span></h3><p>　　我们知道注解的写法和接口很类似，都采用了关键字interface，而且都不能有实现代码，常量定义默认都是public static final 类型的等，它们的主要不同点是：注解要在interface前加上@字符，而且不能继承，不能实现，这经常会给我们的开发带来些障碍。　　</p>
<p>　　我们来分析一下ACL(Access Control  List,访问控制列表)设计案例，看看如何避免这些障碍，ACL有三个重要元素：</p>
<ul>
<li>资源，有哪些信息是要被控制起来的。</li>
<li>权限级别，不同的访问者规划在不同的级别中。</li>
<li>控制器(也叫鉴权人)，控制不同的级别访问不同的资源。</li>
</ul>
<p>　　鉴权人是整个ACL的设计核心，我们从最主要的鉴权人开始，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Identifier</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//无权访问时的礼貌语</span>
    String REFUSE_WORD  <span class="token operator">=</span>  <span class="token string">"您无权访问"</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//鉴权</span>
    <span class="token keyword">public</span>  <span class="token keyword">boolean</span> <span class="token function">identify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　这是一个鉴权人接口，定义了一个常量和一个鉴权方法。接下来应该实现该鉴权方法，但问题是我们的权限级别和鉴权方法之间是紧耦合，若分拆成两个类显得有点啰嗦，怎么办？我们可以直接顶一个枚举来实现，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> CommonIdentifier <span class="token keyword">implements</span> <span class="token class-name">Identifier</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 权限级别</span>
    Reader<span class="token punctuation">,</span> Author<span class="token punctuation">,</span> Admin<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">identify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    定义了一个通用鉴权者，使用的是枚举类型，并且实现了鉴权者接口。现在就剩下资源定义了，这很容易定义，资源就是我们写的类、方法等，之后再通过配置来决定哪些类、方法允许什么级别的访问，这里的问题是：怎么把资源和权限级别关联起来呢？使用XML配置文件？是个方法，但对我们的示例程序来说显得太繁重了，如果使用注解会更简洁些，不过这需要我们首先定义出权限级别的注解，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
@<span class="token keyword">interface</span> <span class="token class-name">Access</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//什么级别可以访问，默认是管理员</span>
    CommonIdentifier <span class="token function">level</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> CommonIdentifier<span class="token punctuation">.</span>Admin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　该注解释标注在类上面的，并且会保留到运行期。我们定义一个资源类，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Access</span><span class="token punctuation">(</span>level<span class="token operator">=</span>CommonIdentifier<span class="token punctuation">.</span>Author<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
</code></pre>
<p>　　Foo类只能是作者级别的人访问。场景都定义完毕了，那我们看看如何模拟ACL实现，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 初始化商业逻辑</span>
    Foo b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 获取注解</span>
    Access access <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>Access<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 没有Access注解或者鉴权失败</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> access <span class="token operator">||</span> <span class="token operator">!</span>access<span class="token punctuation">.</span><span class="token function">level</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">identify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 没有Access注解或者鉴权失败</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>access<span class="token punctuation">.</span><span class="token function">level</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>REFUSE_WORD<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　看看这段代码，简单，易读，而且如果我们是通过ClassLoader类来解释该注解的，那会使我们的开发更简洁，所有的开发人员只要增加注解即可解决访问控制问题。注意看加粗代码，access是一个注解类型，我们想使用Identifier接口的identity鉴权方法和REFUSE_WORD常量，但注解释不能集成的，那怎么办?此处，可通过枚举类型CommonIdentifier从中间做一个委派动作(Delegate),委派？你可以然identity返回一个对象，或者在Identifier上直接定义一个常量对象，那就是“赤裸裸” 的委派了。</p>
<h3><span id="建议92注意override不同版本的区别">建议92：注意@Override不同版本的区别</span></h3><p>　    @Override注解用于方法的覆写上，它是在编译器有效，也就是Java编译器在编译时会根据注解检查方法是否真的是覆写，如果不是就报错，拒绝编译。该注解可以很大程度地解决我们的误写问题，比如子类和父类的方法名少写一个字符，或者是数字0和字母O为区分出来等，这基本是每个程序员都曾将犯过的错误。在代码中加上@Override注解基本上可以杜绝出现此类问题，但是@Override有个版本问题，我们来看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">FooImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　这是一个简单的@Override示例，接口中定义了一个doSomething方法，实现类FooImpl实现此方法，并且在方法前加上了@Override注解。这段代码在Java1.6版本上编译没问题，虽然doSomething方法只是实现了接口的定义，严格来说并不是覆写，但@Override出现在这里可减少代码中出现的错误。</p>
<p>　　可如果在Java1.5版本上编译此段代码可能会出现错误：</p>
<p>　　　　　　The method doSomeThing() of type FooImpl must override  a superclass method </p>
<p>　　注意，这是个错误，不能继续编译，原因是<strong>Java1.5版本的@Override是严格遵守覆写的定义</strong>：子类方法与父类方法必须具有相同的方法名、输出参数、输出参数(允许子类缩小)、访问权限(允许子类扩大)，父类必须是一个类，不能是接口，否则不能算是覆写。而这在Java1.6就开放了很多，实现接口的方法也可以加上@Override注解了，可以避免粗心大意导致方法名称与接口不一致的情况发生。</p>
<p>　　在多环境部署应用时，需呀考虑@Override在不同版本下代表的意义，如果是Java1.6版本的程序移植到1.5版本环境中，就需要删除实现接口方法上的@Override注解。</p>
<h2><span id="第7章-泛型和反射">第7章 泛型和反射</span></h2><p>Don’t let complexity stop you. Be activists. Take on the big inequities. Itwill be one of the great experiences of your lives.</p>
<p>不要让这个世界的复杂性阻碍你的前进。要成为一个行动主义者，将解决人类的不平等视为己任。它将成为你生命中最重要的经历之一。——比尔·盖茨在哈佛大学的演讲</p>
<p>​    泛型可以减少强制类型的转换，可以规范集合的元素类型，还可以提高代码的安全性和可读性，正是因为有这些优点，自从Java引入泛型后，项目的编码规则上便多了一条：优先使用泛型。反射可以“看透”程序的运行情况，可以让我们在运行期知晓一个类或实例的运行状况，可以动态地加载和调用，虽然有一定的性能忧患，但它带给我们的便利远远大于其性能缺陷。</p>
<h3><span id="建议93java的泛型是可以擦除的">建议93：Java的泛型是可以擦除的</span></h3><p>​    java泛型(Generic) 的引入加强了参数类型的安全性，减少了类型的转换，它与C++中的模板(Temeplates) 比较类似，但是有一点不同的是：Java的泛型在编译器有效，在运行期被删除，也就是说所有的泛型参数类型在编译后会被清除掉，我们来看一个例子，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//arrayMethod接收数组参数，并进行重载</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">arrayMethod</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> intArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">arrayMethod</span><span class="token punctuation">(</span>Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> intArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//listMethod接收泛型List参数，并进行重载</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listMethod</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> stringList<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listMethod</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> intList<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    程序很简单，编写了4个方法，arrayMethod方法接收String数组和Integer数组，这是一个典型的重载，listMethod接收元素类型为String和Integer的list变量。现在的问题是，这段程序是否能编译？如果不能？问题出在什么地方？</p>
<p>　　事实上，这段程序时无法编译的，编译时报错信息如下：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20160929095002516-214649817.png" alt="img"></p>
<p>​        这段错误的意思：简单的的说就是方法签名重复，其实就是说listMethod(List<integer> intList)方法在编译时擦除类型后是listMethod(List<e> intList)与另一个方法重复。这就是Java泛型擦除引起的问题：在编译后所有的泛型类型都会做相应的转化。转换规则如下：</e></integer></p>
<ul>
<li>List<string>、List<integer>、List<t>擦除后的类型为List</t></integer></string></li>
<li>List<string>[] 擦除后的类型为List[].</string></li>
<li>List&lt;? extends E&gt; 、List&lt;? super E&gt; 擦除后的类型为List<e>.</e></li>
<li>List&lt;T extends Serializable &amp; Cloneable &gt;擦除后的类型为List&lt; Serializable&gt;.</li>
</ul>
<p>　　明白了这些规则，再看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String str <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    Java编译后字节码中已经没有泛型的任何信息了，也就是说一个泛型类和一个普通类在经过编译后都指向了同一字节码，比如Foo<t>类，经过编译后将只有一份Foo.class类，不管是Foo<string>还是Foo<integer>引用的都是同一字节码。Java之所以如此处理，有两个原因：</integer></string></t></p>
<ul>
<li>避免JVM的大换血。C++泛型生命期延续到了运行期，而Java是在编译期擦除掉的，我们想想，如果JVM也把泛型类型延续到运行期，那么JVM就需要进行大量的重构工作了。</li>
<li>版本兼容：在编译期擦除可以更好的支持原生类型(Raw Type)，在Java1.5或1.6…平台上，即使声明一个List这样的原生类型也是可以正常编译通过的，只是会产生警告信息而已。</li>
</ul>
<p>　　明白了Java泛型是类型擦除的，我们就可以解释类似如下的问题了：</p>
<ol>
<li>泛型的class对象是相同的：每个类都有一个class属性，泛型化不会改变class属性的返回值，例如：</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>list2<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　以上代码返回true，原因很简单，List<string>和List<integer>擦除后的类型都是List，没有任何区别。</integer></string></p>
<p>　　2.泛型数组初始化时不能声明泛型，如下代码编译时通不过：　</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> listArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//    　原因很简单，可以声明一个带有泛型参数的数组，但不能初始化该数组，因为执行了类型擦除操作，List&lt;Object>[]与List&lt;String>[] 就是同一回事了，编译器拒绝如此声明。</span>
</code></pre>
<p>​        3.instanceof不允许存在泛型参数</p>
<p>　　　　以下代码不能通过编译，原因一样，泛型类型被擦除了：　　</p>
<pre class=" language-java"><code class="language-java">  List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list <span class="token keyword">instanceof</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3><span id="建议94不能初始化泛型参数和数组">建议94：不能初始化泛型参数和数组</span></h3><p>　泛型类型在编译期被擦除，我们在类初始化时将无法获得泛型的具体参数，比如这样的代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> T t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> tArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这段代码有神么问题呢？t、tArray、list都是类变量，都是通过new声明了一个类型，看起来非常相似啊！但这段代码是编译不过的，因为编译器在编译时需要获得T类型，但泛型在编译期类型已经被擦除了，所有new T()和 new T[5]都会报错(有人可能会有疑问，泛型类型可以擦除为顶级Object，那T类型擦除成Object不就可以编译了吗？这样也不行，泛型只是Java语言的一部分，Java语言毕竟是一个强类型、编译型的安全语言，要确保运行期的稳定性和安全性就必须要求在编译器上严格检查)。可为什么new ArrayList<t>()却不会报错呢？</t></p>
<p>　　这是因为ArrayList表面是泛型，其实已经在编译期转为Object了，我们来看一下ArrayList的源代码就清楚了，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span>
        RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 容纳元素的数组</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 构造函数</span>
    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 获得一个元素</span>
    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 返回前强制类型转换</span>
        <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/* 其它代码略 */</span>

<span class="token punctuation">}</span>
</code></pre>
<p>　　注意看elementData的定义，它容纳了ArrayList的所有元素，其类型是Object数组，因为Object是所有类的父类，数组又允许协变(Covariant)，因此elementData数组可以容纳所有的实例对象。元素加入时向上转型为Object类型(E类型转换为Object)，取出时向下转型为E类型，如此处理而已。</p>
<p>　　在某些情况下，我们需要泛型数组，那该如何处理呢？代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 不再初始化，由构造函数初始化</span>
    <span class="token keyword">private</span> T t<span class="token punctuation">;</span>
    <span class="token keyword">private</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> tArray<span class="token punctuation">;</span>
    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 构造函数初始化</span>
    <span class="token keyword">public</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> tType <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            t <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> tType<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tArray <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>tType<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　此时，运行就没有什么问题了，剩下的问题就是怎么在运行期获得T的类型，也就是tType参数，一般情况下泛型类型是无法获取的，不过，在客户端调用时多传输一个T类型的class就会解决问题。</p>
<p>　　类的成员变量是在类初始化前初始化的，所以要求在初始化前它必须具有明确的类型，否则就只能声明，不能初始化。</p>
<h3><span id="建议95强制声明泛型的实际类型">建议95：强制声明泛型的实际类型</span></h3><p>​    Arrays工具类有一个方法asList可以把一个变长参数或数组转变为列表，但是它有一个缺点：它所生成的list长度是不可变的，而这在我们的项目开发中有时会很不方便。如果你期望生成的列表长度可变，那就需要自己来写一个数组的工具类了，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ArrayUtils</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 把一个变长参数转化为列表，并且长度可变</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">asList</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>T<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Collections<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这很简单，与Arrays.asList的调用方式相同，我们传入一个泛型对象，然后返回相应的List，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 正常用法</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list1 <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 参数为空</span>
    List list2 <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 参数为整型和浮点型的混合</span>
    List list3 <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这里有三个变量需要说明：</p>
<p>(1)、变量list1：变量list1是一个常规用法，没有任何问题，泛型实际参数类型是String，返回结果就是一个容纳String元素的List对象。</p>
<p>(2)、变量list2：变量list2它容纳的是什么元素呢？我们无法从代码中推断出list2列表到底容纳的是什么元素(因为它传递的参数是空，编译器也不知道泛型的实际参数类型是什么)，不过，编译器会很聪明地推断出最顶层类Object就是其泛型类型，也就是说list2的完整定义如下：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Object<span class="token operator">></span> list2 <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　　如此一来，编译器就不会给出” unchecked “警告了。现在新的问题又出现了：如果期望list2是一个Integer类型的列表，而不是Object列表，因为后续的逻辑会把Integer类型加入到list2中，那该如何处理呢？</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//　强制类型转换(把asList强制转换成List&lt;Integer>)？行不通，虽然Java泛型是编译期擦出的，但是List&lt;Object>和List&lt;Integer>没有继承关系，不能强制转换。　</span>
<span class="token comment" spellcheck="true">//重新声明一个List&lt;Integer>，然后读取List&lt;Object>元素，一个一个地向下转型过去？麻烦，而且效率又低。</span>
</code></pre>
<p>　  最好的解决办法是强制声明泛型类型，代码如下：　</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> intList <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span>&lt;Integer<span class="token operator">></span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　　就这么简单，asList方法要求的是一个泛型参数，那我们就在输入前定义这是一个Integer类型的参数，当然，输出也是Integer类型的集合了。</p>
<p>(3)、变量list3：变量list3有两种类型的元素：整数类型和浮点类型，那它生成的List泛型化参数应该是什么呢？是Integer和Float的父类Number？你太高看编译器了，它不会如此推断的，当它发现多个元素的实际类型不一致时就会直接确认泛型类型是Object，而不会去追索元素的公共父类是什么，但是对于list3，我们更期望它的泛型参数是Number，都是数字嘛，参照list2变量，代码修改如下：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Number<span class="token operator">></span> list3 <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span>&lt;Number<span class="token operator">></span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　　Number是Integer和Float的父类，先把三个输入参数、输出参数同类型，问题是我们要在什么时候明确泛型类型呢？一句话：无法从代码中推断出泛型的情况下，即可强制声明泛型类型。</p>
<h3><span id="建议96不同的场景使用不同的泛型通配符">建议96：不同的场景使用不同的泛型通配符</span></h3><p>​    　Java泛型支持通配符(Wildcard)，可以单独使用一个“?”表示任意类，也可以使用extends关键字表示某一个类(接口)的子类型，还可以使用super关键字表示某一个类(接口)的父类型，但问题是什么时候该用extends，什么该用super呢？</p>
<p>(1)、泛型结构只参与 “读” 操作则限定上界(extends关键字)</p>
<p>　　阅读如下代码，想想看我们的业务逻辑操作是否还能继续：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Object obj <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 业务逻辑操作</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　从List列表中读取元素的操作(比如一个数字列表中的求和计算)，你觉得方法read能继续写下去吗？</p>
<p>　　答案是：不能，我们不知道list到底存放的是什么元素，只能推断出E类型是父类，但问题是E类型的父类又是什么呢？无法再推断，只有运行期才知道，那么编码器就无法操作了。当然，你可以把它当做是Object类来处理，需要时再转换成E类型—这完全违背了泛型的初衷。在这种情况下，“读” 操作如果期望从List集合中读取数据就需要使用extends关键字了，也就是要界定泛型的上界，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>E e <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 业务逻辑操作</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　此时，已经推断出List集合中取出的元素时E类型的元素。具体是什么类型的元素就要等到运行期才确定了，但它一定是一个确定的类型，比如read(Arrays.asList(“A”))调用该方法时，可以推断出List中的元素类型是String，之后就可以对List中的元素进行操作了。如加入到另外的List<e>中，或者作为Map&lt;E,V&gt;的键等。</e></p>
<p>(2)、泛型结构只参与“写” 操作则限定下界(使用super关键字)</p>
<p>　　先看如下代码能否编译：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//加入一个元素</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　编译失败，失败的原因是list中的元素类型不确定，也就是编译器无法推断出泛型类型到底是什么，是Integer类型？是Double？还是Byte？这些都符合extends关键字的定义，由于无法确定实际的泛型类型，所以编译器拒绝了此类操作。</p>
<p>　　在此种情况下，只有一个元素时可以add进去的：null值，这是因为null是一个万用类型，它可以是所有类的实例对象，所以可以加入到任何列表中。</p>
<p>　　Object是否可以？不可以，因为它不是Number子类，而且即使把List变量修改为List&lt;? extends Object&gt; 类型也不能加入，原因很简单，编译器无法推断出泛型类型，加什么元素都是无效的。</p>
<p>　　在这种“写”的操作的情况下，使用super关键字限定泛型的下界才是正道，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Number<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//加入元素</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　甭管它是Integer的123，还是浮点数3.14，都可以加入到list列表中，因为它们都是Number的类型，这就保证了泛型类的可靠性。</p>
<p>　　对于是要限定上界还是限定下界，JDK的Collections.copy方法是一个非常好的例子，它实现了把源列表的所有元素拷贝到目标列表中对应的索引位置上，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> dest<span class="token punctuation">,</span> List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> srcSize <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcSize <span class="token operator">></span> dest<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"Source does not fit in dest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcSize <span class="token operator">&lt;</span> COPY_THRESHOLD <span class="token operator">||</span>
        <span class="token punctuation">(</span>src <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">&amp;&amp;</span> dest <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>srcSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            dest<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        ListIterator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> di<span class="token operator">=</span>dest<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ListIterator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> si<span class="token operator">=</span>src<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>srcSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            di<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            di<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>si<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　源列表是用来提供数据的，所以src变量需要界定上界，要有extends关键字。目标列表是用来写数据的，所以dest变量需要界定下界，带有super关键字。</p>
<p>　　如果一个泛型结构既用作 “读” 操作又用作“写操作”，那该如何进行限定呢？不限定，使用确定的泛型类型即可，如List<e>.</e></p>
<h3><span id="建议97警惕泛型是不能协变和逆变的">建议97：警惕泛型是不能协变和逆变的</span></h3><p>　    什么叫协变和逆变？</p>
<p>　　在编程语言的类型框架中，协变和逆变是指宽类型和窄类型在某种情况下(如参数、泛型、返回值)替换或交换的特性，简单的说，协变是一个窄类型替换宽类型，而逆变则是用宽类型覆盖窄类型。其实，在Java中协变和逆变我们已经用了很久了，只是我们没发觉而已，看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> Number <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Integer <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　子类的doStuff方法返回值的类型比父类方法要窄，此时doStuff方法就是一个协变方法，同时根据Java的覆写定义来看，这又属于覆写。那逆变是怎么回事呢？代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doStuff</span><span class="token punctuation">(</span>Integer i<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doStuff</span><span class="token punctuation">(</span>Number n<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p> 　子类的doStuff方法的参数类型比父类要宽，此时就是一个逆变方法，子类扩大了父类方法的输入参数，但根据覆写的定义来看，doStuff不属于覆写，只是重载而已。由于此时的doStuff方法已经与父类没有任何关系了，只是子类独立扩展出的一个行为，所以是否声明为doStuff方法名意义不大，逆变已经不具有特别的意义了，我们重点关注一下协变，先看如下代码是否是协变：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Base base <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　base变量是否发生了协变？是的，发生了协变，base变量是Base类型，它是父类，而其赋值却是在子类实例，也就是用窄类型覆盖了宽类型。这也叫多态，两者同含义。</p>
<p>　　说了这么多，下面再再来想想泛型是否支持协变和逆变呢，答案是：泛型既不支持协变，也不支持逆变。为什么会不支持呢？</p>
<p>(1)、泛型不支持协变：数组和泛型很相似，一个是中括号，一个是尖括号，那我们就以数组为参照对象，看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//数组支持协变</span>
    Number <span class="token punctuation">[</span><span class="token punctuation">]</span> n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//编译不通过，泛型不支持协变</span>
    List<span class="token operator">&lt;</span>Number<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　ArrayList是List的子类型，Integer是Number的子类型，里氏替换原则在此行不通了，原因就是Java为了保证运行期的安全性，必须保证泛型参数的类型是固定的，所以它不允许一个泛型参数可以同时包含两种类型，即使是父子类关系也不行。</p>
<p>　　泛型不支持协变，但可以使用通配符模拟协变，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Number子类型(包括Number类型) 都可以是泛型参数类型</span>
List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　“ ? extends Number “ 表示的意思是，允许Number的所有子类(包括自身) 作为泛型参数类型，但在运行期只能是一个具体类型，或者是Integer类型，或者是Double类型，或者是Number类型，也就是说通配符只在编码期有效，运行期则必须是一个确定的类型。</p>
<p>(2)、泛型不支持逆变</p>
<p>　　java虽然允许逆变存在，但在对类型赋值上是不允许逆变的，你不能把一个父类实例对象赋给一个子类类型变量，泛型自然也不允许此种情况发生了。但是它可以使用super关键字来模拟实现，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Integer的父类型(包括Integer)都可以是泛型参数类型</span>
List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Number<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　　“ ? super Integer “ 的意思是可以把所有的Integer父类型(自身、父类或接口) 作为泛型参数，这里看着就像是把一个Number类型的ArrayList赋值给了Integer类型的List，其外观类似于使用一个宽类型覆盖一个窄类型，它模拟了逆变的实现。</p>
<p>　　泛型既不支持协变，也不支持逆变，带有泛型参数的子类型定义与我们经常使用的类类型也不相同，其基本类型关系如下表所示：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/image-20211225195753140-16404334753096.png" alt="image-20211225195753140"></p>
<h3><span id="建议98采用顺序是list中泛型顺序依次为t-object">建议98：采用顺序是List中泛型顺序依次为T、?、Object</span></h3><pre class=" language-java"><code class="language-java">　<span class="token comment" spellcheck="true">//List&lt;T>、List&lt;?>、List&lt;Object>这三者都可以容纳所有的对象，但使用的顺序应该是首选List&lt;T>，次之List&lt;?>，最后选择List&lt;Object>，原因如下：</span>
</code></pre>
<p>(1)、List<t>是确定的某一个类型</t></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//　List&lt;T>表示的是List集合中的元素都为T类型，具体类型在运行期决定；List&lt;？>表示的是任意类型，与List&lt;T>类似，而List&lt;Object>则表示List集合中的所有元素为Object类型，因为Object是所有类的父类，所以List&lt;Object>也可以容纳所有的类类型，从这一字面意义上分析，List&lt;T>更符合习惯：编码者知道它是某一个类型，只是在运行期才确定而已。</span>
</code></pre>
<p>(2)List<t>可以进行读写操作</t></p>
<p>　　List<t>可以进行诸如add，remove等操作，因为它的类型是固定的T类型，在编码期不需要进行任何的转型操作。</t></p>
<p>　　List<t>是只读类型的，不能进行增加、修改操作，因为编译器不知道List中容纳的是什么类型的元素，也就无法校验类型是否安全了，而且List&lt;?&gt;读取出的元素都是Object类型的，需要主动转型，所以它经常用于泛型方法的返回值。注意List&lt;？&gt;虽然无法增加，修改元素，但是却可以删除元素，比如执行remove、clear等方法，那是因为它的删除动作与泛型类型无关。</t></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//　List&lt;Object> 也可以读写操作，但是它执行写入操作时需要向上转型(Up cast)，在读取数据的时候需要向下转型，而此时已经失去了泛型存在的意义了。</span>
<span class="token comment" spellcheck="true">//打个比方，有一个篮子用来容纳物品，比如西瓜，番茄等.List&lt;?>的意思是说，“嘿，我这里有一个篮子，可以容纳固定类别的东西，比如西瓜，番茄等”。List&lt;?>的意思是说：“嘿，我有一个篮子，我可以容纳任何东西，只要是你想得到的”。而List&lt;Object>就更有意思了，它说" 嘿，我也有一个篮子，我可以容纳所有物质，只要你认为是物质的东西都可以容纳进来 "。</span>
<span class="token comment" spellcheck="true">//推而广之，Dao&lt;T>应该比Dao&lt;？>、Dao&lt;Object>更先采用，Desc&lt;Person>则比Desc&lt;？>、Desc&lt;Object></span>
</code></pre>
<h3><span id="建议99严格限定泛型类型采用多重界限">建议99：严格限定泛型类型采用多重界限</span></h3><p>　　从哲学来说，很难描述一个具体的人，你可以描述他的长相、性格、工作等，但是人都是由多重身份的，估计只有使用多个And(与操作)将所有的描述串联起来才能描述一个完整的人，比如我，上班时我是一个职员，下班了坐公交车我是一个乘客，回家了我是父母的孩子，是儿子的父亲……角色时刻在变换。那如果我们要使用Java程序来对一类人进行管理，该如何做呢？比如在公交车费优惠系统中，对部分人员(如工资低于2500元的上班族并且是站立的乘客)车费打8折，该如何实现呢？</p>
<p>　　注意这里的类型参数有两个限制条件：一个为上班族；二为乘客。具体到我们的程序中就应该是一个泛型参数具有两个上界(Upper Bound)，首先定义两个接口及实现类，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Staff</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 工资</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Passenger</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 是否是站立状态</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isStanding</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//定义我这个类型的人</span>
<span class="token keyword">class</span> <span class="token class-name">Me</span> <span class="token keyword">implements</span> <span class="token class-name">Staff</span><span class="token punctuation">,</span> Passenger <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isStanding</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">2000</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>　　“Me”这种类型的人物有很多，比如系统分析师也是一个职员，也坐公交车，但他的工资实现就和我不同，再比如Boss级的人物，偶尔也坐公交车，对大老板来说他也只是一个职员，他的实现类也不同，也就是说如果我们使用“T extends Me”是限定不了需求对象的，那该怎么办呢？可以考虑使用多重限定，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client99</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//工资低于2500的并且站立的乘客车票打8折</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Staff</span> <span class="token operator">&amp;</span> Passenger<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">discount</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2500</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span><span class="token function">isStanding</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 恭喜您，您的车票打八折!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">discount</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Me</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　使用“&amp;”符号设定多重边界，指定泛型类型T必须是Staff和Passenger的共有子类型，此时变量t就具有了所有限定的方法和属性，要再进行判断就一如反掌了。在Java的泛型中，可以使用”&amp;”符号关联多个上界并实现多个边界限定，而且只有上界才有此限定，下界没有多重限定的情况。想想你就会明白：多个下界，编码者可自行推断出具体的类型，比如“? super Integer” 和 “? extends Double”,可以更细化为Number类型了，或者Object类型了，无需编译器推断了。</p>
<p>　　为什么要说明多重边界？是因为编码者太少使用它了，比如一个判断用户权限的方法，使用的是策略模式(Strategy Pattern) ,示意代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">UserHandler</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">User</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 判断用户是否有权限执行操作</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">permit</span><span class="token punctuation">(</span>T user<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Job<span class="token operator">></span> jobs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> iList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 判断 是否是管理员</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>iList<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>Admin<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Admin admin <span class="token operator">=</span> <span class="token punctuation">(</span>Admin<span class="token punctuation">)</span> user<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 判断管理员是否有此权限</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 判断普通用户是否有此权限</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Job</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Admin</span> <span class="token keyword">extends</span> <span class="token class-name">User</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
<p>　 此处进行了一次泛型参数类别判断，这里不仅仅违背了单一职责原则(Single Responsibility Principle)，而且让泛型很“汗颜” ：已经使用了泛型限定参数的边界了，还要进行泛型类型判断。事实上，使用多重边界可以很方便的解决此问题，而且非常优雅，建议大家 在开发中考虑使用多重限定。</p>
<h3><span id="建议100数组的真实类型必须是泛型类型的子类型">建议100：数组的真实类型必须是泛型类型的子类型</span></h3><p>　　List接口的toArray方法可以把一个集合转化为数组，但是使用不方便，toArray()方法返回的是一个Object数组，所以需要自行转变。toArray(T[] a)虽然返回的是T类型的数组，但是还需要传入一个T类型的数组，这也挺麻烦的，我们期望输入的是一个泛型化的List，这样就能转化为泛型数组了，来看看能不能实现，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    T<span class="token punctuation">[</span><span class="token punctuation">]</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　上面要输出的参数类型定义为Object数组，然后转型为T类型数组，之后遍历List赋值给数组的每个元素，这与ArrayList的toArray方法很类似(注意只是类似)，客户端的调用如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>String str <span class="token operator">:</span><span class="token function">toArray</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　编译没有任何问题，运行后出现如下异常：　　</p>
<pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassCastException<span class="token operator">:</span> <span class="token punctuation">[</span>Ljava<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">;</span> cannot be cast to <span class="token punctuation">[</span>Ljava<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">;</span>
    at com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>advice100<span class="token punctuation">.</span>Client100<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>Client100<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">)</span>
</code></pre>
<p>　　类型转换异常，也就是说不能把一个Object数组转换为String数组，这段异常包含了两个问题：</p>
<ul>
<li>为什么Object数组不能向下转型为String数组：数组是一个容器，只有确保容器内的所有元素类型与期望的类型有父子关系时才能转换，Object数组只能保证数组内的元素时Object类型，却不能确保它们都是String的父类型或子类，所以类型转换失败。</li>
<li>为什么是main方法抛出异常，而不是toArray方法：其实，是在toArray方法中进行的类型向下转换，而不是main方法中。那为什么异常会在main方法中抛出，应该在toArray方法的“ T[] t = (T[]) new Object[list.size()];”这段代码才对呀?那是因为泛型是类型擦除的，toArray方法经过编译后与如下代码相同：　　</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArrayTwo</span><span class="token punctuation">(</span>List list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 此处的强制类型转换没必要存在，只是为了与源代码对比</span>
    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> <span class="token punctuation">(</span>String <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token function">toArrayTwo</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　阅读完此段代码后就很清楚了：toArray方法返回后进行一次类型转换，Object数组转换成了String数组，于是就报ClassCastException异常了。</p>
<p>　　Object数组不能转为String数组，T类型又无法在运行期获得，那该如何解决这个问题呢？其实，要想把一个Object数组转换为String数组，只要Object数组的实际类型也就是String就可以了，例如：　</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// objArray的实际类型和表面类型都是String数组</span>
Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 抛出ClassCastException</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span> strArray <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> objArray<span class="token punctuation">;</span>

String<span class="token punctuation">[</span><span class="token punctuation">]</span> ss <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//objs的真实类型是String数组，显示类型为Object数组</span>
Object objs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>ss<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//顺利转换为String数组</span>
String strs<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>objs<span class="token punctuation">;</span>
</code></pre>
<p>　　明白了这个问题，我们就把泛型数组声明为泛型的子类型吧！代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">,</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//声明并初始化一个T类型的数组</span>
    T<span class="token punctuation">[</span><span class="token punctuation">]</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>tClass<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　通过反射类Array声明了一个T类型的数组,由于我们无法在运行期获得泛型类型的参数，因此就需要调用者主动传入T参数类型。此时，客户端再调用就不会出现任何异常了。</p>
<p>　　在这里我们看到，当一个泛型类(特别是泛型集合)转变为泛型数组时，泛型数组的真实类型不能是泛型的父类型(比如顶层类Object)，只能是泛型类型的子类型(当然包括自身类型)，否则就会出现类型转换异常。</p>
<h3><span id="建议101注意class类的特殊性">建议101：注意Class类的特殊性</span></h3><p>　　Java语言是先把Java源文件编译成后缀为class的字节码文件，然后再通过ClassLoader机制把这些类文件加载到内存中，最后生成实例执行的，这是Java处理的基本机制，但是加载到内存中的数据的如何描述一个类的呢？比如在Dog.class文件中定义一个Dog类，那它在内存中是如何展现的呢？</p>
<p>　　Java使用一个元类(MetaClass)来描述加载到内存中的类数据，这就是Class类，它是一个描述类的类对象，比如Dog.class文件加载到内存中后就会有一个class的实例对象描述之。因为是Class类是“类中类”，也就有预示着它有很多特殊的地方：</p>
<ol>
<li><p>无构造函数：Java中的类一般都有构造函数，用于创建实例对象，但是Class类却没有构造函数，不能实例化，Class对象是在加载类时由Java虚拟机通过调用类加载器中的difineClass方法自动构造的。</p>
</li>
<li><p>可以描述基本类型：虽然8个基本类型在JVM中并不是一个对象，它们一般存在于栈内存中，但是Class类仍然可以描述它们，例如可以使用int.class表示int类型的类对象。</p>
</li>
<li><p>其对象都是单例模式：一个Class的实例对象描述一个类，并且只描述一个类，反过来也成立。一个类只有一个Class实例对象，如下代码返回的<strong>结果都为true</strong>：　</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 类的属性class所引用的对象与实例对象的getClass返回值相同</span>
<span class="token keyword">boolean</span> b1<span class="token operator">=</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> b2<span class="token operator">=</span><span class="token string">"ABC"</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// class实例对象不区分泛型</span>
<span class="token keyword">boolean</span> b3<span class="token operator">=</span>ArrayList<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ol>
<p>　Class类是Java的反射入口，只有在获得了一个类的描述对象后才能动态的加载、调用，一般获得一个Class对象有三种途径：</p>
<ol>
<li><p>类属性方式：如String.class</p>
</li>
<li><p>对象的getClass方法，如new String().getClass()</p>
</li>
<li><p>forName方法加载：如Class.forName(“ java.lang.String”)</p>
<p>　获得了Class对象后，就可以通过getAnnotations()获得注解，通过getMethods()获得方法，通过getConstructors()获得构造函数等，这位后续的反射代码铺平了道路。</p>
</li>
</ol>
<h3><span id="建议102适时选择getdeclaredxxx和getxxx">建议102：适时选择getDeclaredXXX和getXXX</span></h3><p>　　Java的Class类提供了很多的getDeclaredXXX方法和getXXX方法，例如getDeclaredMethod和getMethod成对出现，getDeclaredConstructors和getConstructors也是成对出现，那这两者之间有什么差别呢？看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client102</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException<span class="token punctuation">,</span>
            SecurityException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 方法名称</span>
        String methodName <span class="token operator">=</span> <span class="token string">"doStuff"</span><span class="token punctuation">;</span>
        Method m1 <span class="token operator">=</span> Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Method m2 <span class="token operator">=</span> Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//静态内部类</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　此段代码运行后输出如下：</p>
<pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>NoSuchMethodException<span class="token operator">:</span> com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>advice102<span class="token punctuation">.</span>Client102$Foo<span class="token punctuation">.</span><span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Class<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>Class<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1622</span><span class="token punctuation">)</span>
    at com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>advice102<span class="token punctuation">.</span>Client102<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>Client102<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">)</span>
</code></pre>
<p>　　该异常是说m2变量的getMethod方法没有找到doStuff方法，明明有这个方法呀，为什么没有找到呢？这是因为getMethod方法获得的是所有public访问级别的方法，包括从父类继承的方法，而getDeclaredMethod获得的是自身类的方法，包括公用的(public)方法、私有(private)方法，而且不受限于访问权限。</p>
<p>　　其它的getDeclaredConstructors和getConstructors、getDeclaredFileds和getFields等于此相似。Java之所以如此处理，是因为反射本意只是正常代码逻辑的一种补充，而不是让正常代码逻辑发生翻天覆地的变化，所以public的属性和方法最容易获取，私有属性和方法也可以获取，但要限定本类。</p>
<p>　　那么问题来了：如果需要列出所有继承自父类的方法，该如何实现呢？简单，先获得父类，然后使用getDeclaredMethods，之后持续递归即可。</p>
<h3><span id="建议103反射访问属性或方法时将accessible设置为true">建议103：反射访问属性或方法时将Accessible设置为true</span></h3><p>　　Java中通过反射执行一个方法的过程如下：获取一个方法对象，然后根据isAccessible返回值确定是否能够执行，如果返回值为false则需要调用setAccessible（true），最后再调用invoke执行方法，具体如下：　</p>
<pre class=" language-java"><code class="language-java">Method method<span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//检查是否可以访问</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>method<span class="token punctuation">.</span><span class="token function">isAccessible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    method<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//执行方法</span>
method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>​        此段代码已经成了习惯用法：通过反射方法执行方法时，必须在invoke之前检查Accessible属性。这是一个好习惯，也确实该如此，但方法对象的Accessible属性并不是用来决定是否可以访问的，看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Do Stuff..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　定义一个public类的public方法，这是一个没有任何限制的方法，按照我们对Java语言的理解，此时doStuff方法可以被任何一个类访问。我们编写一个客户端类来检查该方法是否可以反射执行：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException<span class="token punctuation">,</span>
SecurityException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span>
IllegalArgumentException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 反射获取方法</span>
    Method m <span class="token operator">=</span> Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"doStuff"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 打印是否可以访问</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Accessible："</span> <span class="token operator">+</span> m<span class="token punctuation">.</span><span class="token function">isAccessible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 执行方法</span>
    m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　很简单的反射操作，获得一个方法，然后检查是否可以访问，最后执行方法输出。让我们来猜想一下结果：因为Foo类是public的，方法也是public的，全部都是最开放的访问权限Accessible也应该等于true。但是运行结果却是：</p>
<p>　　<strong>Accessible：false</strong><br>   <strong>Do Stuff…</strong></p>
<p>　　为什么Accessible属性会等于false？而且等于false还能执行？这是因为Accessible的属性并不是我们语法层级理解的访问权限，而是指是否更容易获得，是否进行安全检查。</p>
<p>　　我们知道，动态修改一个类或执行方法时都会受到Java安全体制的制约，而安全的处理是非常耗资源的(性能非常低)，因此对于运行期要执行的方法或要修改的属性就提供了Accessible可选项：由开发者决定是否要逃避安全体系的检查。</p>
<p>　　阅读源代码是最好的理解方式，我们来看AccessibleObject类的源代码，它提供了取消默认访问控制检查的功能。首先查看isAccessible方法，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccessibleObject</span> <span class="token keyword">implements</span> <span class="token class-name">AnnotatedElement</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//定义反射的默认操作权限suppressAccessChecks</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">private</span> java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>Permission ACCESS_PERMISSION <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ReflectPermission</span><span class="token punctuation">(</span><span class="token string">"suppressAccessChecks"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//是否重置了安全检查，默认为false</span>
    <span class="token keyword">boolean</span> override<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//构造函数</span>
    <span class="token keyword">protected</span> <span class="token function">AccessibleObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//是否可以快速获取，默认是不能</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAccessible</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> override<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　AccessibleObject是Filed、Method、Constructor的父类，决定其是否可以快速访问而不进行访问控制检查，在AccessibleObject类中是以override变量保存该值的，但是具体是否快速执行时在Method的invoke方法中决定的，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span>
InvocationTargetException
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//见擦汗是否可以快速获取，其值是父类AccessibleObject的override变量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>override<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//不能快速获取，执行安全检查   </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Reflection<span class="token punctuation">.</span><span class="token function">quickCheckMemberAccess</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> caller <span class="token operator">=</span> Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token function">checkAccess</span><span class="token punctuation">(</span>caller<span class="token punctuation">,</span> clazz<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    MethodAccessor ma <span class="token operator">=</span> methodAccessor<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// read volatile</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ma <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ma <span class="token operator">=</span> <span class="token function">acquireMethodAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//直接执行方法</span>
    <span class="token keyword">return</span> ma<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p> 　看了这段代码，大家就清楚了：Accessible属性只是用来判断是否需要进行安全检查的，如果不需要则直接执行，这就可以大幅度的提升系统性能了(当然了，取消了安全检查，也可以运行private方法、访问private属性的)。经过测试，在大量的反射情况下，设置Accessible为true可以提高性能20倍左右。</p>
<p>　　AccessibleObject的其它两个子类Field和Constructor与Method的情形类似：Accessible属性决定Field和Constructor是否受访问控制检查。我们在设置Field或执行Constructor时，务必要设置Accessible为true，这并不仅仅是因为操作习惯的问题，还是为我们的系统性能考虑。</p>
<h3><span id="建议104使用forname动态加载类文件">建议104：使用forName动态加载类文件</span></h3><p>　　动态加载(Dynamic Loading)是指在程序运行时加载需要的类库文件，对Java程序来说，一般情况下，一个类文件在启动时或首次初始化时会被加载到内存中，而反射则可以在运行时再决定是否需要加载一个类，比如从Web上接收一个String参数作为类名，然后在JVM中加载并初始化，这就是动态加载，此动态加载通常是通过Class.forName(String)实现的，只是这个forName方法到底是什么意思呢？</p>
<p>　　我们知道一个类文件只有在被加载到内存中才可能生成实例对象，也就是说一个对象的生成必然会经过两个步骤：</p>
<ul>
<li><p>加载到内存中生成Class的实例对象</p>
</li>
<li><p>通过new关键字生成实例对象</p>
<p>　如果我们使用的是import关键字产生的依赖包，JVM在启动时会自动加载所有的依赖包的类文件，这没有什么问题，如果好动态加载类文件，就要使用forName的方法了，但问题是我们为什么要使用forName方法动态加载一个类文件呢？那是因为我们不知道生成的实例对象是什么类型(如果知道就不用动态加载)，而且方法和属性都不可访问呀。问题又来了：动态加载的意义在什么地方呢？</p>
</li>
</ul>
<p>　　意义在于：加载一个类即表示要初始化该类的static变量，特别是static代码块，在这里我们可以做大量的工作，比如注册自己，初始化环境等，这才是我们要重点关注的逻辑，例如如下代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>advice103<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client103</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//动态加载</span>
        Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.study.advice103.Utils"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Utils</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//静态代码块</span>
    <span class="token keyword">static</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Do Something....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　注意看Client103类，我们并没有对Utils做任何初始化，只是通过forName方法加载了Utils类，但是却产生了一个“Do Something…..”的输出，这就是因为Utils类加载后，JVM会自动初始化其static变量和static静态代码块，这是类加载机制所决定的。</p>
<p>　　对于动态加载，最经典的应用是数据库驱动程序的加载片段，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//加载驱动</span>
Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql..jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String url<span class="token operator">=</span><span class="token string">"jdbc:mysql://localhost:3306/db?user=&amp;password="</span><span class="token punctuation">;</span>
Connection conn <span class="token operator">=</span>DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
Statement stmt <span class="token operator">=</span>conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　　在没有Hibernate和Ibatis等ORM框架的情况下，基本上每个系统都会有这么一个JDBC链接类，然后提供诸如Query、Delete等的方法，大家有没有想过为什么要加上forName这句话呢？没有任何的输出呀，要它干什么用呢？事实上非常有用，我们看一下Driver的源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token keyword">extends</span> <span class="token class-name">NonRegisteringDriver</span>
    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>Driver</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//构造函数</span>
    <span class="token keyword">public</span> <span class="token function">Driver</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">throws</span> SQLException
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//静态代码块</span>
    <span class="token keyword">static</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">try</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//把自己注册到DriverManager中</span>
            DriverManager<span class="token punctuation">.</span><span class="token function">registerDriver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Driver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span><span class="token punctuation">(</span>SQLException E<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//异常处理</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Can't register driver!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　该程序的逻辑是这样的：数据库驱动程序已经由NonRegisteringDriver实现了，Driver类只是负责把自己注册到DriverManager中。当程序动态加载该驱动时，也就是执行到Class.forName(“com.mysql..jdbc.Driver”)时，Driver类会被加载到内存中，于是static代码块开始执行，也就是把自己注册到DriverManager中。</p>
<p>　　需要说明的是，forName只是把一个类加载到内存中，并不保证由此产生一个实例对象，也不会执行任何方法，之所以会初始化static代码，那是由类加载机制所决定的，而不是forName方法决定的。也就是说，如果没有static属性或static代码块，forName就是加载类，没有任何的执行行为。</p>
<p>　　<strong><font color="red">注意：forName只是加载类，并不执行任何代码。</font></strong></p>
<h3><span id="建议105动态加载不适合数组">建议105：动态加载不适合数组</span></h3><p>　上一个建议解释了为什么要用forName，本建议就来说说那些地方不适合动态加载。如果forName要加载一个类，那它首先必须是一个类___8个基本类型排除在外,它们不是一个具体的类；其次，它必须具有可追溯的类路径，否则就会报ClassNotFoundException。</p>
<p>　在Java中，数组是一个非常特殊的类，虽然它是一个类，但没有定义类类路径，例如这样的代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>
    String <span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String[]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　String []是一个类型声明，它作为forName的参数应该也是可行的吧！但是非常遗憾，其运行结果如下：</p>
<pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassNotFoundException<span class="token operator">:</span> java<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span>
    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Class<span class="token punctuation">.</span><span class="token function">forName0</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>
    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>Class<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">186</span><span class="token punctuation">)</span>
</code></pre>
<p>　　产生ClassNotFoundException异常的原因是数组算是一个类，在声明时可以定义为String[]，但编译器编译后为不同的数组类型生成不同的类，具体如下表所示：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/image-20211225210357001-16404374389067.png" alt="image-20211225210357001"></p>
<p>　　在编码期，我们可以声明一个变量为String[]，但是经过编译后就成为了[Ljava.lang.String。明白了这一点，再根据以上的表格可知，动态加载一个对象数组只要加载编译后的数组对象就可以了，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//加载一个数组</span>
Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"[Ljava.lang.String;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//加载一个Long数组</span>
Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"[J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　　虽然以上代码可以加载一个数组类，但这是没有任何意义的，因为它不能产生一个数组对象，也就是说以上代码只是把一个String类型的数组类和Long类型的数组类加载到了内存中(如果内存中没有改类的话)，并不能通过newInstance方法生成一个实例对象，因为它没有定义数组的长度，在Java中数组是定长的，没有长度的数组是不允许存在的。</p>
<p>　　既然反射不能定义一个数组，那问题就来了：如何动态加载一个数组呢？比如依据输入动态生成一个数组。其实可以使用Array数组反射类动态加载，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 动态创建数组</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 创建一个多维数组</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　　因为数组比较特殊，要想动态创建和访问数组，基本的反射是无法实现的，“上帝对你关闭一扇门，同时会为你打开一扇窗。”，于是Java就专门定义了一个Array数组反射工具类来实现动态探知数组的功能。</p>
<p>　　<strong><font color="red">注意：通过反射操作数组使用Array类，不要采用通用的反射处理API。</font></strong></p>
<h3><span id="建议106动态代理可以使代理模式更加灵活">建议106：动态代理可以使代理模式更加灵活</span></h3><p>　　Java的反射框架提供了动态代理(Dynamic Proxy)机制，允许在运行期对目标类生成代理，避免重复开发。我们知道一个静态代理是通过主题角色(Proxy)和具体主题角色(Real Subject)共同实现主题角色(Subject)的逻辑的，只是代理角色把相关的执行逻辑委托给了具体角色而已，一个简单的静态代理如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 定义一个方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 具体主题角色</span>
<span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 实现方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 实现具体业务逻辑</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 要代理那个实现类</span>
    <span class="token keyword">private</span> Subject subject <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 默认被代理者</span>
    <span class="token keyword">public</span> <span class="token function">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 通过构造函数传递被代理者</span>
    <span class="token keyword">public</span> <span class="token function">Proxy</span><span class="token punctuation">(</span>Subject _subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        subject <span class="token operator">=</span> _subject<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        subject<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 预处理</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// doSomething</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 善后处理</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// doSomething</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这是一个简单的静态代理。Java还提供了java.lang.reflect.Proxy用于实现动态代理：只要提供一个抽象主题角色和具体主题角色，就可以动态实现其逻辑的，其实例代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 定义一个方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 具体主题角色</span>
<span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 实现方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 实现具体业务逻辑</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SubjectHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 被代理的对象</span>
    <span class="token keyword">private</span> Subject subject<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">SubjectHandler</span><span class="token punctuation">(</span>Subject _subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        subject <span class="token operator">=</span> _subject<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 预处理</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"预处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//直接调用被代理的方法</span>
        Object obj <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 后处理</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"后处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>　　注意这里没有代理主题角色，取而代之的是SubjectHandler 作为主要的逻辑委托处理，其中invoke方法是接口InvocationHandler定义必须实现的，它完成了对真实方法的调用。</p>
<p>　　我们来详细解释一下InvocationHandler接口，动态代理是根据被代理的接口生成的所有方法的，也就是说给定一个或多个接口，动态代理会宣称“我已经实现该接口下的所有方法了”，那大家想想看，动态代理是怎么才能实现接口中的方法呢？在默认情况下所有方法的返回值都是空的，是的，虽然代理已经实现了它，但是没有任何的逻辑含义，那怎么办？好办，通过InvocationHandler接口的实现类来实现，所有的方法都是由该Handler进行处理的，即所有被代理的方法都由InvocationHandler接管实际的处理任务。</p>
<p>　　我们开看看动态代理的场景，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//具体主题角色，也就是被代理类</span>
    Subject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//代理实例的处理Handler</span>
    InvocationHandler handler <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SubjectHandler</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//当前加载器</span>
    ClassLoader cl <span class="token operator">=</span> subject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//动态代理</span>
    Subject proxy <span class="token operator">=</span> <span class="token punctuation">(</span>Subject<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>cl<span class="token punctuation">,</span>subject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//执行具体主题角色方法</span>
    proxy<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　此时就实现了，不用显式创建代理类即实现代理的功能，例如可以在被代理的角色执行前进行权限判断，或者执行后进行数据校验。</p>
<p>　　动态代理很容易实现通用的代理类，只要在InvocationHandler的invoke方法中读取持久化的数据即可实现，而且还能实现动态切入的效果，这也是AOP(Aspect Oriented Programming)变成理念。</p>
<h3><span id="建议107使用反射增加装饰模式的普适性">建议107：使用反射增加装饰模式的普适性</span></h3><p>　　装饰模式(Decorator Pattern)的定义是“动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比于生成子类更为灵活”，不过，使用Java的动态代理也可以实现装饰模式的效果，而且其灵活性、适应性都会更强。</p>
<p>　　我们以卡通片《猫和老鼠》(Tom and Jerry)为例，看看如何包装小Jerry让它更强大。首先定义Jerry的类：老鼠（Rat类），代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Rat</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Jerry will play with Tom ......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>
</code></pre>
<p>　　接下来，我们要给Jerry增加一些能力，比如飞行，钻地等能力，当然使用继承也很容易实现，但我们这里只是临时的为Rat类增加这些能力，使用装饰模式更符合此处的场景，首先定义装饰类，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//定义某种能力</span>
<span class="token keyword">interface</span> <span class="token class-name">Feature</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//加载特性</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//飞行能力</span>
<span class="token keyword">class</span> <span class="token class-name">FlyFeature</span> <span class="token keyword">implements</span> <span class="token class-name">Feature</span><span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"增加一对翅膀..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//钻地能力</span>
<span class="token keyword">class</span> <span class="token class-name">DigFeature</span> <span class="token keyword">implements</span> <span class="token class-name">Feature</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"增加钻地能力..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>
</code></pre>
<p>　　此处定义了两种能力：一种是飞行，另一种是钻地，我们如果把这两种属性赋予到Jerry身上，那就需要一个包装动作类了，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">DecorateAnimal</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 被包装的动物</span>
    <span class="token keyword">private</span> Animal animal<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 使用哪一个包装器</span>
    <span class="token keyword">private</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Feature</span><span class="token operator">></span> clz<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">DecorateAnimal</span><span class="token punctuation">(</span>Animal _animal<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Feature</span><span class="token operator">></span> _clz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        animal <span class="token operator">=</span> _animal<span class="token punctuation">;</span>
        clz <span class="token operator">=</span> _clz<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        InvocationHandler handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 具体包装行为</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
                    <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>
                Object obj <span class="token operator">=</span> null<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    obj <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>clz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                animal<span class="token punctuation">.</span><span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//当前加载器</span>
        ClassLoader cl <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//动态代理，又handler决定如何包装</span>
        Feature proxy <span class="token operator">=</span> <span class="token punctuation">(</span>Feature<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>cl<span class="token punctuation">,</span> clz<span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
        proxy<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>　　注意看doStuff方法，一个装饰类型必然是抽象构建(Component)的子类型，它必须实现doStuff方法，此处的doStuff方法委托给了动态代理执行，并且在动态代理的控制器Handler中还设置了决定装饰方式和行为的条件(即代码中InvocationHandler匿名类中的if判断语句)，当然，此处也可以通过读取持久化数据的方式进行判断，这样就更加灵活了。</p>
<p>　　抽象构建有了，装饰类也有了，装饰动作类也完成了，那我们就可以编写客户端进行调用了，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//定义Jerry这只老鼠</span>
    Animal jerry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//为Jerry增加飞行能力</span>
    jerry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecorateAnimal</span><span class="token punctuation">(</span>jerry<span class="token punctuation">,</span> FlyFeature<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//jerry增加挖掘能力</span>
    jerry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecorateAnimal</span><span class="token punctuation">(</span>jerry<span class="token punctuation">,</span> DigFeature<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//Jerry开始戏弄毛了</span>
    jerry<span class="token punctuation">.</span><span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　此类代码只一个比较通用的装饰模式，只需要定义被装饰的类及装饰类即可，装饰行为由动态代理实现，实现了对装饰类和被装饰类的完全解耦，提供了系统的扩展性。</p>
<h3><span id="建议108反射让模板方法模式更强大">建议108：反射让模板方法模式更强大</span></h3><p>　　模板方法模式(Template Method Pattern)的定义是：定义一个操作中的算法骨架，将一些步骤延迟到子类中，使子类不改变一个算法的结构即可重定义该算法的某些特定步骤。简单的说，就是父类定义抽象模板作为骨架，其中包括基本方法(是由子类实现的方法，并且在模板方法中被调用)和模板方法（实现对基本方法的调度，完成固定的逻辑），它是用了简单的继承和覆写机制，我么来看一个基本的例子。</p>
<p>　　我们经常会开发一些测试或演示程序，期望系统在启动时自动初始化，以方便测试或讲解，一般的做法是写一个SQL文件，在系统启动前自动导入，不过，这样不仅麻烦而且容易出错，于是我们就手写了一个自动初始化数据的框架：在系统（或容器）自动启动时自行初始化数据。但问题是每个应用程序要初始化的内容我们并不知道，只能由实现者自行编写，那我们就必须给作者预留接口，此时就得考虑使用模板方法模式了，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbsPopulator</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 模板方法</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">dataInitialing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 调用基本方法</span>
        <span class="token function">doInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 基本方法</span>
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　    这里定义了一个抽象模板类AbsPopulator，它负责数据初始化，但是具体要初始化哪些数据则是由doInit方法决定的，这是一个抽象方法，子类必须实现，我们来看一个用户表数据的加载：　　</p>
<pre><code>public class UserPopulator extends AbsPopulator&#123;
    @Override
    protected void doInit() &#123;
        //初始化用户表，如创建、加载数据等
    &#125;
&#125;
</code></pre>
<p>　　该系统在启动时查找所有的AbsPopulator实现类，然后dataInitialing实现数据的初始化。那大家可能要想了，怎么让容器指导这个AbsPopulator类呢？很简单，如果是使用Spring作为Ioc容器的项目，直接在dataInitialing方法上加上@PostConstruct注解，Spring容器启动完毕后自动运行dataInitialing方法。具体大家看spring的相关知识，这里不再赘述。</p>
<p>　　现在问题是：初始化一张User表需要非常多的操作，比如先建表，然后筛选数据，之后插入，最后校验，如果把这些都放入到一个doInit方法里会非常庞大(即使提炼出多个方法承担不同的责任，代码的可读性依然很差)，那该如何做呢？又或者doInit是没有任何的也无意义的，是否可以起一个优雅而又动听的名字呢？</p>
<p>　　答案是我们可以使用反射增强模板方法模式，使模板方法实现对一批固定的规则的基本方法的调用。代码是最好的交流语言，我们看看怎么改造AbsPopulator类，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbsPopulator</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 模板方法</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">dataInitialing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 获得所有的public方法</span>
        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Method m <span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 判断是否是数据初始化方法</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isInitDataMethod</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 判断是否是数据初始化方法，基本方法鉴定器</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isInitDataMethod</span><span class="token punctuation">(</span>Method m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"init"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// init开始</span>
                <span class="token operator">&amp;&amp;</span> Modifier<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 公开方法</span>
                <span class="token operator">&amp;&amp;</span> m<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>Void<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 返回值是void</span>
                <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>m<span class="token punctuation">.</span><span class="token function">isVarArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 输出参数为空</span>
                <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Modifier<span class="token punctuation">.</span><span class="token function">isAbstract</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 不能是抽象方法</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　在一般的模板方法模式中，抽象模板(这里是AbsPopulator类)需要定义一系列的基本方法，一般都是protected访问级别的，并且是抽象方法，这标志着子类必须实现这些基本方法，这对子类来说既是一个约束也是一个负担。但是使用了反射后，不需要定义任何抽象方法，只需要定义一个基本方法鉴定器(例子中的isInitDataMethod)即可加载符合规则的基本方法。鉴别器在此处的作用是鉴别子类方法中哪些是基本方法，模板方法(例子中的dataInitaling)则需要基本方法鉴定器返回的结果通过反射执行相应的方法。</p>
<p>　　此时，如果需要进行大量的初始化工作，子类的实现就非常简单了，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserPopulator</span> <span class="token keyword">extends</span> <span class="token class-name">AbsPopulator</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/* 初始化用户表，如创建、加载数据等 */</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/* 初始化密码 */</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initJobs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/* 初始化工作任务 */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　UserPopulator类中的方法只要符合基本方法鉴别器条件即会被模板方法调用，方法的数据量也不再受父类的约束，实现了子类灵活定义基本方法、父类批量调用的功能，并且缩减了子类的代码量。</p>
<p>　　如果大家熟悉JUnit的话，就会看出此处的实现与JUnit非常相似，JUnit4之前要求测试的方法名必须是以test开头的，并且无返回值、无参数，而且是public修饰，其实现的原理与此非常类似，大家有兴趣可以看看Junit的源码。</p>
<h3><span id="建议109不需要太多关注反射效率">建议109：不需要太多关注反射效率</span></h3><p>　　反射的效率是一个老生常谈的问题，有”经验” 的开发人员经常会使用这句话恐吓新人：反射的效率是非常低的，不到万不得已就不要使用。事实上，这句话前半句是对的，后半句是错的。</p>
<p>　　反射的效率相对于正常的代码执行确实低很多，但它是一个非常有效的运行期工具类，只要代码结构清晰、可读性好那就先开发起来，等到进行性能测试时证明此处性能确实有问题再修改也不迟(一般情况下，反射并不是性能的终极杀手，而代码结构混乱、可读性差则可能会埋下性能隐患)。我们看这样一个例子，在运行期获得泛型类的泛型，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Utils</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获得一个泛型类的实际泛型类型</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getGenricClassType</span><span class="token punctuation">(</span>Class <span class="token class-name">clz</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Type type <span class="token operator">=</span> clz<span class="token punctuation">.</span><span class="token function">getGenericSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ParameterizedType pt <span class="token operator">=</span> <span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> type<span class="token punctuation">;</span>
            Type<span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> pt<span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>types<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> types<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 若有多个泛型参数，依据位置索引返回</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> types<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　前面我们讲过，Java泛型只存在于编译器，那为什么这个工具类可以取得运行期的泛型类型呢?那是因为该工具只支持继承的泛型类，如果是在Java编译时已经确定了泛型类的类型参数，那当然可以通过泛型类获得了。例如有这样一个泛型类：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BaseDao</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//获得T运行期的类型</span>
    <span class="token keyword">private</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> clz <span class="token operator">=</span> Utils<span class="token punctuation">.</span><span class="token function">getGenricClassType</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//根据主键获得一条记录</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>
        session<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clz<span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//操作user表</span>
<span class="token keyword">class</span> <span class="token class-name">UserDao</span> <span class="token keyword">extends</span> <span class="token class-name">BaseDao</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
</code></pre>
<p>　　对于UserDao类，编译器编译时已经明确了其参数类型是String，因此可以通过反射的方式来获取其类型，这也是getGenricClassType方法使用的场景。</p>
<p>　　BaseDao和UserDao是ORM中的常客，BaseDao实现对数据库的基本操作，比如增删改查，而UserDao则是一个比较具体的数据库操作，其作用是对User表进行操作，如果BaseDao能够提供足够多的基本方法，比如单表的增删改查，哪些与UserDao类似的BaseDao子类就可以省却大量的开发工作。但问题是持久层的session对象(这里模拟的是Hibernate 　Session)需要明确一个具体的类型才能操作，比如get查询，需要获得两个参数：实体类类型(用于确定映射的数据表)和主键，主键好办，问题是实体类类型怎么获得呢？</p>
<p>　　子类进行传递?麻烦，而且也容易产生错误。</p>
<p>　　读取配置问题？可行，但效率不高。</p>
<p>　　最好的办法就是父类泛型化，子类明确泛型参数，然后通过反射读取相应的类型即可，于是就有了我们代码中clz变量：通过反射获得泛型类型。如此实现后，UserDao可不用定义任何方法，继承过来的父类操作方法已经满足基本需求了，这样的代码结构清晰，可读性又好。</p>
<p>　　想想看，如果考虑反射效率问题，没有clz变量，不使用反射，每个BaseDao的子类都要实现一个查询操作，代码将会大量重复，违反了” Don’t Repeat Yourself “ 这条最基本的编码规则，这会致使项目重构、优化难度加大，代码的复杂度也会提高很多。</p>
<p>   对于反射效率的问题，不要做任何的提前优化和预期，这基本上是杞人忧天，很少有项目是因为反射问题引起系统效率故障的（除非是拷贝的垃圾代码），而且根据二八原则，80%的性能消耗在20%的代码上，这20%的代码才是我们关注的重点，不要单单把反射作为重点关注对象。</p>
<p>　　<strong><font color="red">注意：反射效率低是个真命题，但因为这一点而不使用它就是个假命题。</font></strong></p>
<h2><span id="第8章-异常">第8章 异常</span></h2><p>大成若缺，其用不弊。大盈若冲，其用不穷。——老子《道德经》</p>
<p>​        不管人类的思维有多么缜密，也存在“智者千虑必有一失”的缺憾。无论计算机技术怎么发展，也不可能穷尽所有的情景—这个世界是不完美的，是有缺陷的，完美的世界只存在于理想中。</p>
<p>​        对于软件帝国的缔造者来说，程序也是不完美的，异常情况随时都会出现，我们需要它为我们描述例外事件，需要它处理非预期的情景，需要它帮我们建立“完美世界”。</p>
<h3><span id="建议110提倡异常封装">建议110：提倡异常封装</span></h3><p>Java语言的异常处理机制可以去确保程序的健壮性，提高系统的可用率，但是Java API提供的异常都是比较低级的(这里的低级是指 “ 低级别的 “ 异常)，只有开发人员才能看的懂，才明白发生了什么问题。而对于终端用户来说，这些异常基本上就是天书，与业务无关，是纯计算机语言的描述，那该怎么办？这就需要我们对异常进行封装了。异常封装有三方面的优点：</p>
<p><strong>(1)、提高系统的友好性</strong></p>
<p>　　例如，打开一个文件，如果文件不存在，则回报FileNotFoundException异常，如果该方法的编写者不做任何处理，直接抛到上层，则会降低系统的友好性，代码如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> FileNotFoundException <span class="token punctuation">{</span>
    InputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"无效文件.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* 文件操作 */</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　此时doStuff的友好性极差，出现异常时(如果文件不存在)，该方法直接把FileNotFoundException异常抛到上层应用中(或者是最终用户)，而上层应用(或用户要么自己处理)，要么接着抛，最终的结果就是让用户面对着” 天书 “ 式的文字发呆，用户不知道这是什么问题，只是知道系统告诉他” 哦，我出错了，什么错误？你自己看着办吧 “。</p>
<p>　　解决办法就是封装异常，可以把异常的阅读者分为两类：开发人员和用户。开发人员查找问题，需要打印出堆栈信息，而用户则需要了解具体的业务原因，比如文件太大、不能同时编写文件等，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doStuff2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> MyBussinessException<span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        InputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"无效文件.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//方便开发人员和维护人员而设置的异常信息</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//抛出业务异常</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyBussinessException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/* 文件操作 */</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>(2)、提高系统的可维护性</strong></p>
<p>　　看如下代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">doStuff3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//doSomething</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>
</code></pre>
<p>　　这是大家很容易犯的错误，抛出异常是吧?分类处理多麻烦，就写一个catch块来处理所有的异常吧，而且还信誓旦旦的说” JVM会打印出栈中的错误信息 “，虽然这没错，但是该信息只有开发人员自己看的懂，维护人员看到这段异常时基本上无法处理，因为需要到代码逻辑中去分析问题。</p>
<p>　　正确的做法是对异常进行分类处理，并进行封装输出，代码如下：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">doStuff4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//doSomething</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>FileNotFoundException e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"文件未找到，使用默认配置文件...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>SecurityException e1<span class="token punctuation">)</span><span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">" 无权访问，可能原因是......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　如此包装后，维护人员看到这样的异常就有了初步的判断，或者检查配置，或者初始化环境，不需要直接到代码层级去分析了。</p>
<p><strong>(3)、解决Java异常机制自身的缺陷</strong></p>
<p>　　Java中的异常一次只能抛出一个，比如doStuff方法有两个逻辑代码片段，如果在第一个逻辑片段中抛出异常，则第二个逻辑片段就不再执行了，也就无法抛出第二个异常了，现在的问题是：如何才能一次抛出两个(或多个)异常呢？</p>
<p>　　其实，使用自行封装的异常可以解决该问题，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 容纳所有的异常</span>
    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Throwable<span class="token operator">></span> causes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Throwable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 构造函数，传递一个异常列表</span>
    <span class="token keyword">public</span> <span class="token function">MyException</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token operator">></span> _causes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        causes<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>_causes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 读取所有的异常</span>
    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Throwable<span class="token operator">></span> <span class="token function">getExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> causes<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　MyException异常只是一个异常容器，可以容纳多个异常，但它本身并不代表任何异常含义，它所解决的是一次抛出多个异常的问题，具体调用如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> MyException <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>Throwable<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Throwable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 第一个逻辑片段</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Do Something</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 第二个逻辑片段</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Do Something</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 检查是否有必要抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyException</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这样一来，DoStuff方法的调用者就可以一次获得多个异常了，也能够为用户提供完整的例外情况说明。可能有人会问：这种情况会出现吗？怎么回要求一个方法抛出多个异常呢？</p>
<p>　　绝对有可能出现，例如Web界面注册时，展现层依次把User对象传递到逻辑层，Register方法需要对各个Field进行校验并注册，例如用户名不能重复，密码必须符合密码策略等，不要出现用户第一次提交时系统显示” 用户名重复 “，在用户修改用户名再次提交后，系统又提示” 密码长度小于6位 “ 的情况，这种操作模式下的用户体验非常糟糕，最好的解决办法就是异常封装，建立异常容器，一次性地对User对象进行校验，然后返回所有的异常。</p>
<h3><span id="建议111采用异常链传递异常">建议111：采用异常链传递异常</span></h3><p>　　设计模式中有一个模式叫做责任链模式(Chain of Responsibility) ,它的目的是将多个对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止，异常的传递处理也应该采用责任链模式。</p>
<p>　　上一建议中我们提出了异常需要封装，但仅仅封装还是不够的，还需要传递异常。我们知道，一个系统友好性的标志是用户对该系统的” 粘性”，粘性越高，系统越友好，粘性越低系统友好性越差，那问题是怎么提高系统的“粘性”呢？友好的界面和功能是一个方面，另外一个方面就是系统出现非预期情况的处理方式了。</p>
<p>　　比如我们的JavaEE项目一般都有三层结构：持久层，逻辑层，展现层，持久层负责与数据库交互，逻辑层负责业务逻辑的实现，展现层负责UI数据库的处理，有这样一个模块：用户第一次访问的时候，需要从持久层user.xml中读取信息，如果该文件不存在则提示用户创建之，那问题来了：如果我们直接把持久层的异常FileNotFoundException抛弃掉，逻辑层根本无法得知发生了何事，也就不能为展现层提供一个友好的处理结果了，最终倒霉的就是发展层：没有办法提供异常信息，只能告诉用户说“出错了，我也不知道出什么错了”___毫无友好性可言。</p>
<p>　　正确的做法是先封装，然后传递，过程如下：</p>
<p>(1)、把FIleNotFoundException封装为MyException。</p>
<p>(2)、抛出到逻辑层，逻辑层根据异常代码(或者自定义的异常类型)确定后续处理逻辑，然后抛出到展现层。</p>
<p>(3)、展现层自行决定要展现什么，如果是管理员则可以展现低层级的异常，如果是普通用户则展示封装后的异常。</p>
<p>　　明白了异常为什么要传递，那接着的问题就是如何传递了。很简单，使用异常链进行异常的传递，我们以IOException为例来看看是如何传递的，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IOException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token function">IOException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//定义异常原因</span>
    <span class="token keyword">public</span> <span class="token function">IOException</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//定义异常原因，并携带原始异常</span>
    <span class="token keyword">public</span> <span class="token function">IOException</span><span class="token punctuation">(</span>String message<span class="token punctuation">,</span> Throwable cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//保留原始异常信息</span>
    <span class="token keyword">public</span> <span class="token function">IOException</span><span class="token punctuation">(</span>Throwable cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　在IOException的构造函数中，上一个层级的异常可以通过异常链进行传递，链中传递异常的代码如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//doSomething</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　捕捉到Exception异常，然后把它转化为IOException异常并抛出(此种方式也叫作异常转译)，调用者获得该异常后再调用getCause方法即可获得Exception的异常信息，如此即可方便地查找到产生异常的基本信息，便于解决问题。</p>
<p>　　结合上一建议来说，异常需要封装和传递，我们在进行系统开发时不要” 吞噬 “ 异常，也不要赤裸裸的抛出异常，封装后再抛出，或者通过异常链传递，可以达到系统更健壮，更友好的目的。</p>
<h3><span id="建议112受检异常尽可能转化为非受检异常">建议112：受检异常尽可能转化为非受检异常</span></h3><p>　为什么说是” 尽可能”的转化呢？因为” 把所有的受检异常(Checked Exception)”都转化为非受检异常(Unchecked Exception)” 这一想法是不现实的：受检异常是正常逻辑的一种补偿手段，特别是对可靠性要求比较高的系统来说，在某些条件下必须抛出受检异常以便由程序进行补偿处理，也就是说受检异常有合理存在的理由，那为什么要把受检异常转化为非受检异常呢？难道说受检异常有什么缺陷或者不足吗？是的，受检异常确实有不足的地方：</p>
<p><strong>(1)、受检异常使接口声明脆弱</strong></p>
<p>　　OOP(Object Oriented Programming,面向对象程序设计) 要求我们尽量多地面向接口编程，可以提高代码的扩展性、稳定性等，但是涉及异常问题就不一样了，例如系统初期是这样设计一个接口的：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">User</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//修改用户密码，抛出安全异常</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">changePassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> MySecurityException<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　随着系统的开发，User接口有了多个实现者，比如普通的用户UserImpl、模拟用户MockUserImpl(用作测试或系统管理)、非实体用户NonUserImpl(如自动执行机，逻辑处理器等)，此时如果发现changePassword方法可能还需要抛出RejectChangeException(拒绝修改异常，如自动执行正在处理的任务时不能修改其代码)，那就需要修改User接口了：changePassword方法增加抛出RejectChangeException异常，这会导致所有的User调用者都要追加了对RejectChangeException异常问题的处理。</p>
<p>　　这里产生了两个问题：一、 异常是主逻辑的补充逻辑，修改一个补充逻辑，就会导致主逻辑也被修改，也就是出现了实现类 “ 逆影响 “ 接口的情景，我们知道实现类是不稳定的，而接口是稳定的，一旦定义了异常，则增加了接口的不稳定性，这是面向对象设计的严重亵渎；二、实现的变更最终会影响到调用者，破坏了封装性，这也是迪米特法则所不能容忍的。</p>
<p><strong>(2)、受检异常使代码的可读性降低</strong></p>
<p>　　一个方法增加可受检异常，则必须有一个调用者对异常进行处理，比如无受检异常方法doStuff是这样调用的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　doStuff方法一旦增加受检异常就不一样了，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　doStuff方法增加了throws Exception，调用者就必须至少增加4条语句来处理该异常，代码膨胀许多，可读性也降低了，特别是在多个异常需要捕捉的情况下，多个catch块多个异常处理，而且还可能在catch块中再次抛出异常，这大大降低了代码的可读性。</p>
<p><strong>(3)、受检异常增加了开发工作量</strong></p>
<p>　　我们知道，异常需要封装和传递，只有封装才能让异常更容易理解，上层模块才能更好的处理，可这会导致低层级的异常没玩没了的封装，无端加重了开发的工作量。比如FileNotFoundException进行封装，并抛出到上一个层级，于是增加了开发工作量。</p>
<p>　　受检异常有这么多的缺点，那有没有什么方法可以避免或减少这些缺点呢？有，很简单的一个规则：将受检异常转化为非受检异常即可，但是我们也不能把所有的受检异常转化为非受检异常，原因是在编码期上层模块不知道下层模块会抛出何种非受检异常，只有通过规则或文档来描述，可以这样说：　</p>
<ul>
<li>受检异常提出的是” 法律下的自由 “，必须遵守异常的约定才能自由编写代码。</li>
<li>非受检异常则是“ 协约性质的自由 ”，你必须告诉我你要抛什么异常，否则不会处理。</li>
</ul>
<p>　　以User接口为例，我们在声明接口时不再声明异常，而是在具体实现时根据不同的情况产生不同的非受检异常，这样持久层和逻辑层抛出的异常将会由展现自行决定如何展示，不再受异常的规则约束了，大大简化开发工作，提高了代码的可读性。</p>
<p>　　那问题又来了，在开发和设计时什么样的受检异常有必要化为非受检异常呢？” 尽可能 “ 是以什么作为判断依据呢？受检异常转换为非受检异常是需要根据项目的场景来决定的，例如同样是刷卡，员工拿着自己的工卡到考勤机上打考勤，此时如果附近有磁性物质干扰，则考勤机可以把这种受检异常转化为非受检异常，黄灯闪烁后不做任何记录登记，因为考勤失败这种情景不是” 致命 “的业务逻辑，出错了，重新刷一下即可。但是到银行网点取钱就不一样了，拿着银行卡到银行取钱，同样有磁性物质干扰，刷不出来，那这种异常就必须登记处理，否则会成为威胁银行卡安全的事件。汇总成一句话：当受检异常威胁到了系统的安全性，稳定性，可靠性、正确性时，则必须处理，不能转化为非受检异常，其它情况则可以转化为非受检异常。</p>
<p>　　注意：受检异常威胁到系统的安全性，稳定性、可靠性、正确性时，不能转换为非受检异常。</p>
<h3><span id="建议113不要在finally块中处理返回值">建议113：不要在finally块中处理返回值</span></h3><p>　在finally代码块中处理返回值，这是考试和面试中经常出现的题目。虽然可以以此来出考试题，但在项目中绝对不能再finally代码块中出现return语句，这是因为这种处理方式非常容易产生” 误解 “，会误导开发者。例如如下代码：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client113</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这里是永远不会到达的"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//该方法抛出受检异常</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token keyword">int</span> _p<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>_p <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">DataFormatException</span><span class="token punctuation">(</span><span class="token string">" 数据格式错误 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> _p<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 异常处理</span>
            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　对于这段代码，有两个问题：main方法中的doStuff方法的返回值是什么？doStuff方法永远都不会抛出异常吗？</p>
<p>　　答案是：doStuff(-1)的值是-1，doStuff(100)的值也是-1，调用doStuff方法永远都不会抛出异常，有这么神奇？原因就是我们在finally代码块中加入了return语句，而这会导致出现以下两个问题：</p>
<p><strong>(1)、覆盖了try代码块中的return返回值</strong></p>
<p>　　当执行doStuff(-1)时，doStuff方法产生了DataFormatException异常，catch块在捕捉此异常后直接抛出，之后代码执行到finally代码块，就会重置返回值，结果就是-1了。也就是出现先返回，再重置返回的情况。</p>
<p>　　有人可能会思考，是不是可以定义变量，在finally中修改后return呢？代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 重新修改一下返回值</span>
        a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　该方法的返回值永远是1，不会是-1或0(为什么不会执行到” return 0 “ 呢？原因是finally执行完毕后该方法已经有返回值了，后续代码就不会再执行了)，这都是源于异常代码块的处理方式，在代码中try代码块就标志着运行时会有一个Throwale线程监视着该方法的运行，若出现异常，则交由异常逻辑处理。</p>
<p>　　我们知道方法是在栈内存中运行的，并且会按照“ 先进后出 ”的原则执行，main方法调用了doStuff方法，则main方法在下层，doStuff方法在上层，当doStuff方法执行完” return a “ 时，此方法的返回值已经确定int类型1(a变量的值，注意基本类型都是拷贝值，而不是引用)，此时finally代码块再修改a的值已经与doStuff返回者没有任何关系了，因此该方法永远都会返回1.</p>
<p>　　继续追问，那是不是可以在finally代码块中修改引用类型的属性以达到修改返回值的效果呢？代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Person <span class="token function">doStuffw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> person<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    

    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 重新修改一下值</span>
        person<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    person<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> person<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　此方法的返回值永远都是name为李四的Person对象，原因是Person是一个引用对象，在try代码块中的返回值是Person对象的地址，finally中再修改那当然会是李四了。</p>
<p><strong>(2)、屏蔽异常</strong></p>
<p>　　为什么明明把异常throw出去了，但main方法却捕捉不到呢？这是因为异常线程在监视到有异常发生时，就会登记当前的异常类型为DataFormatException，但是当执行器执行finally代码块时，则会重新为doStuff方法赋值，也就是告诉调用者” 该方法执行正确，没有产生异常，返回值为1 “，于是乎，异常神奇的消失了，其简化代码如下所示：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//正常抛出异常</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//告诉JVM：该方法正常返回</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这里是永远不会到达的"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　上面finally代码块中的return已经告诉JVM：doSomething方法正常执行结束，没有异常，所以main方法就不可能获得任何异常信息了。这样的代码会使可读性大大降低，读者很难理解作者的意图，增加了修改的难度。</p>
<p>　　在finally中处理return返回值，代码看上去很完美，都符合逻辑，但是执行起来就会产生逻辑错误，最重要的一点是finally是用来做异常的收尾处理的，一旦加上了return语句就会<strong>让程序的复杂度徒然上升</strong>，而且会产生一些隐蔽性非常高的错误。</p>
<p>　　与return语句相似，System.exit(0)或RunTime.getRunTime().exit(0)出现在异常代码块中也会产生非常多的错误假象，增加代码的复杂性，大家有兴趣可以自行研究一下.</p>
<p>　　<strong><font color="red">注意：不要在finally代码块中出现return语句.</font></strong></p>
<h3><span id="建议114不要在构造函数中抛出异常">建议114：不要在构造函数中抛出异常</span></h3><p>　　Java异常的机制有三种：</p>
<ul>
<li>Error类及其子类表示的是错误，它是不需要程序员处理也不能处理的异常，比如VirtualMachineError虚拟机错误，ThreadDeath线程僵死等。</li>
<li>RunTimeException类及其子类表示的是非受检异常，是系统可能会抛出的异常，程序员可以去处理，也可以不处理，最经典的就是NullPointException空指针异常和IndexOutOfBoundsException越界异常。</li>
<li>Exception类及其子类(不包含非受检异常)，表示的是受检异常，这是程序员必须处理的异常，不处理则程序不能通过编译，比如IOException表示的是I/O异常，SQLException表示的数据库访问异常。　　</li>
</ul>
<p>我们知道，一个对象的创建过程经过内存分配，静态代码初始化、构造函数执行等过程，对象生成的关键步骤是构造函数，那是不是也允许在构造函数中抛出异常呢？从Java语法上来说，完全可以在构造函数中抛出异常，三类异常都可以，但是从系统设计和开发的角度来分析，则尽量不要在构造函数中抛出异常，我们以三种不同类型的异常来说明之。</p>
<p><strong>(1)、构造函数中抛出错误是程序员无法处理的</strong></p>
<p>　　在构造函数执行时，若发生了VirtualMachineError虚拟机错误，那就没招了，只能抛出，程序员不能预知此类错误的发生，也就不能捕捉处理。</p>
<p><strong>(2)、构造函数不应该抛出非受检异常</strong></p>
<p>　　我们来看这样一个例子，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> _age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 不满18岁的用户对象不能建立</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_age <span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"年龄必须大于18岁."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doSomething......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这段代码的意图很明显，年龄不满18岁的用户不会生成一个Person实例对象，没有对象，类行为doSomething方法就不可执行，想法很好，但这会导致不可预测的结果，比如我们这样引用Person类：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Person p <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/*其它的业务逻辑*/</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　很显然，p对象不能建立，因为是一个RunTimeException异常，开发人员可以捕捉也可以不捕捉，代码看上去逻辑很正确，没有任何瑕疵，但是事实上，这段程序会抛出异常，无法执行。这段代码给了我们两个警示：</p>
<ol>
<li><strong>加重了上层代码编写者的负担</strong>：捕捉这个RuntimeException异常吧，那谁来告诉我有这个异常呢？只有通过文档约束了，一旦Person类的构造函数经过重构后再抛出其它非受检异常，那main方法不用修改也是可以测试通过的，但是这里就可能会产生隐藏的缺陷，而写还是很难重现的缺陷。不捕捉这个RuntimeException异常，这个是我们通常的想法，既然已经写成了非受检异常，main方法的编码者完全可以不处理这个异常嘛，大不了不执行Person的方法！这是非常危险的，一旦产生异常，整个线程都不再继续执行，或者链接没有关闭，或者数据没有写入数据库，或者产生内存异常，这些都是会对整个系统产生影响。</li>
<li><strong>后续代码不会执行</strong>：main方法的实现者原本是想把p对象的建立作为其代码逻辑的一部分，执行完doSomething方法后还需要完成其它逻辑，但是因为没有对非受检异常进行捕捉，异常最终会抛出到JVM中，这会导致整个线程执行结束后，后面所有的代码都不会继续执行了，这就对业务逻辑产生了致命的影响。</li>
</ol>
<p><strong>(3)、构造函数尽可能不要抛出受检异常</strong></p>
<p>　　我们来看下面的例子，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//父类</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 父类抛出IOException</span>
    <span class="token keyword">public</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//子类</span>
<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 子类抛出Exception异常</span>
    <span class="token keyword">public</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　就这么一段简单的代码，展示了在构造函数中抛出受检异常的三个不利方面：</p>
<ol>
<li><strong>导致子类膨胀</strong>：在我们的例子中子类的无参构造函数不能省略，原因是父类的无参构造函数抛出了IOException异常，子类的无参构造函数默认调用的是父类的构造函数，所以子类无参构造函数也必须抛出IOException或其父类。</li>
<li><strong>违背了里氏替换原则</strong>：”里氏替换原则” 是说父类能出现的地方子类就可以出现，而且将父类替换为子类也不会产生任何异常。那我们回头看看Sub类是否可以替换Base类，比如我们的上层代码是这样写的：</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Base base <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　然后，我们期望把new Base()替换成new Sub()，而且代码能够正常编译和运行。非常可惜，编译不通过，原因是Sub的构造函数抛出了Exception异常，它比父类的构造函数抛出更多的异常范围要宽，必须增加新的catch块才能解决。　　</p>
<p>　　可能大家要问了，为什么Java的构造函数允许子类的构造函数抛出更广泛的异常类呢？这正好与类方法的异常机制相反，类方法的异常是这样要求的：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 父类</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 父类方法抛出Exception</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 子类</span>
<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 父类方法抛出Exception</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　子类的方法可以抛出多个异常，但都必须是覆写方法的子类型，对我们的例子来说，Sub类的testMethod方法抛出的异常必须是Exception的子类或Exception类，这是Java覆写的要求。构造函数之所以于此相反，是因为构造函数没有覆写的概念，只是构造函数间的引用调用而已，所以在构造函数中抛出受检异常会违背里氏替换原则原则，使我们的程序缺乏灵活性。</p>
<p>　　<strong>3.子类构造函数扩展受限：</strong>子类存在的原因就是期望实现扩展父类的逻辑，但父类构造函数抛出异常却会让子类构造函数的灵活性大大降低，例如我们期望这样的构造函数。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 父类</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 子类</span>
<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//异常处理后再抛出</span>
            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//收尾处理</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　很不幸，这段代码编译不通过，原因是构造函数Sub没有把super()放在第一句话中，想把父类的异常重新包装再抛出是不可行的(当然，这里有很多种 “曲线” 的实现手段，比如重新定义一个方法，然后父子类的构造函数都调用该方法，那么子类构造函数就可以自由处理异常了)，这是Java语法机制。</p>
<p>　　将以上三种异常类型汇总起来，对于构造函数，错误只能抛出，这是程序人员无能为力的事情；非受检异常不要抛出，抛出了 “ 对己对人 “ 都是有害的；受检异常尽量不抛出，能用曲线的方式实现就用曲线方式实现，总之一句话：在构造函数中尽可能不出现异常。</p>
<p>　　<strong><font color="red">注意 ：在构造函数中不要抛出异常，尽量曲线实现。</font></strong></p>
<h3><span id="建议115使用throwable获得栈信息">建议115：使用Throwable获得栈信息</span></h3><p>​    AOP编程可以很轻松的控制一个方法调用哪些类，也能够控制哪些方法允许被调用，一般来说切面编程(比如AspectJ)，只能控制到方法级别，不能实现代码级别的植入(Weave)，比如一个方法被类A的m1方法调用时返回1，在类B的m2方法调用时返回0(同参数情况下)，这就要求被调用者具有识别调用者的能力。在这种情况下，可以使用Throwable获得栈信息，然后鉴别调用者并分别输出，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 取得当前栈信息</span>
        StackTraceElement<span class="token punctuation">[</span><span class="token punctuation">]</span> sts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Throwable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 检查是否是methodA方法调用</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>StackTraceElement st <span class="token operator">:</span> sts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"methodA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//调用者</span>
<span class="token keyword">class</span> <span class="token class-name">Invoker</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//该方法打印出true</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//该方法打印出false</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　注意看Invoker类，两个方法methodA和methodB都调用了Foo的method方法，都是无参调用，返回值却不同，这是我们的Throwable类发挥效能了。JVM在创建一本Throwable类及其子类时会把当前线程的栈信息记录下来，以便在输出异常时准确定位异常原因，我们来看Throwable源代码。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Throwable</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> StackTraceElement<span class="token punctuation">[</span><span class="token punctuation">]</span> UNASSIGNED_STACK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackTraceElement</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//出现异常记录的栈帧</span>
    <span class="token keyword">private</span> StackTraceElement<span class="token punctuation">[</span><span class="token punctuation">]</span> stackTrace <span class="token operator">=</span> UNASSIGNED_STACK<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//默认构造函数</span>
    <span class="token keyword">public</span> <span class="token function">Throwable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//记录栈帧</span>
        <span class="token function">fillInStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//本地方法，抓取执行时的栈信息</span>
    <span class="token keyword">private</span> <span class="token keyword">native</span> Throwable <span class="token function">fillInStackTrace</span><span class="token punctuation">(</span><span class="token keyword">int</span> dummy<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> Throwable <span class="token function">fillInStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>stackTrace <span class="token operator">!=</span> null <span class="token operator">||</span> backtrace <span class="token operator">!=</span> null <span class="token comment" spellcheck="true">/* Out of protocol state */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">fillInStackTrace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            stackTrace <span class="token operator">=</span> UNASSIGNED_STACK<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>　　在出现异常时(或主动声明一个Throwable对象时)，JVM会通过fillInStackTrace方法记录下栈帧信息，然后生成一个Throwable对象，这样我们就可以知道类间的调用顺序，方法名称及当前行号等了。</p>
<p>　　获得栈信息可以对调用者进行判断，然后决定不同的输出，比如我们的methodA和methodB方法，同样地输入参数，同样的调用方法，但是输出却不同，这看起来很想是一个bug：方法methodA调用method方法正常显示，而方法methodB调用却会返回错误数据，因此我们虽然可以根据调用者的不同产生不同的逻辑，但这仅局限在对此方法的广泛认知上，更多的时候我们使用method方法的变形体，代码如下:　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 取得当前栈信息</span>
        StackTraceElement<span class="token punctuation">[</span><span class="token punctuation">]</span> sts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Throwable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 检查是否是methodA方法调用</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>StackTraceElement st <span class="token operator">:</span> sts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"methodA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"除了methodA方法外，该方法不允许其它方法调用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　只是把“return false” 替换成了一个运行期异常，除了methodA方法外，其它方法调用都会产生异常，该方法常用作离线注册码校验，让破解者视图暴力破解时，由于执行者不是期望的值，因此会返回一个经过包装和混淆的异常信息，大大增加了破解难度。</p>
<h3><span id="建议116异常只为异常服务">建议116：异常只为异常服务</span></h3><p>​    　异常只为异常服务，这是何解？难道异常还能为其它服务不成？确实能，异常原本是正常逻辑的一个补充，但是有时候会被当做主逻辑使用，看如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//判断一个枚举是否包含String枚举项</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">boolean</span> <span class="token function">Contain</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> clz<span class="token punctuation">,</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        Enum<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>clz<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>RuntimeException e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//只要是抛出异常，则认为不包含</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　判断一个枚举是否包含指定的枚举项，这里会根据valueOf方法是否抛出异常来进行判断，如果抛出异常(一般是IllegalArgumentException异常)，则认为是不包含，若不抛出异常则可以认为包含该枚举项，看上去这段代码很正常，但是其中有是哪个错误：</p>
<ol>
<li><strong>异常判断降低了系统的性能</strong></li>
<li><strong>降低了代码的可读性，只有详细了解valueOf方法的人才能读懂这样的代码，因为valueOf抛出的是一个非受检异常</strong></li>
<li><strong>隐藏了运行期可能产生的错误，catch到异常，但没有做任何处理。</strong></li>
</ol>
<p>　　我们这段代码是用一段异常实现了一个正常的业务逻辑，这导致代码产生了坏味道。要解决从问题也很容易，即不在主逻辑中实使用异常，代码如下：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 判断一个枚举是否包含String枚举项</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">boolean</span> <span class="token function">Contain</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> clz<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 遍历枚举项</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>T t <span class="token operator">:</span> clz<span class="token punctuation">.</span><span class="token function">getEnumConstants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 枚举项名称是否相等</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　异常只能用在非正常的情况下，不能成为正常情况下的主逻辑，也就是说，异常是是主逻辑的辅助场景，不能喧宾夺主。</p>
<p>　　而且，异常虽然是描述例外事件的，但能避免则避免之，除非是确实无法避免的异常，例如：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 其它业务处理</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 异常处理</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这样一段代码经常在我们的项目中出现，但经常写并不代表不可优化，这里的异常类FileNotFoundException完全可以在它诞生前就消除掉：先判断文件是否存在，然后再生成FileInputStream对象，这也是项目中常见的代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 经常出现的异常，可以先做判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 其它业务处理</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 异常处理</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　虽然增加了if判断语句，增加了代码量，但是却减少了FileNotFoundException异常出现的几率，提高了程序的性能和稳定性。</p>
<h3><span id="建议117多使用异常把性能问题放一边">建议117：多使用异常，把性能问题放一边</span></h3><p>　　我们知道异常是主逻辑的例外逻辑，举个简单的例子来说，比如我在马路上走(这是主逻辑)，突然开过一辆车，我要避让(这是受检异常，必须处理)，继续走着，突然一架飞机从我头顶飞过(非受检异常)，我们可以选在继续行走(不捕捉)，也可以选择指责其噪音污染(捕捉，主逻辑的补充处理)，再继续走着，突然一颗流星砸下来，这没有选择，属于错误，不能做任何处理。这样具备完整例外场景的逻辑就具备了OO的味道，任何一个事务的处理都可能产生非预期的效果，问题是需要以何种手段来处理，如果不使用异常就需要依靠返回值的不同来进行处理了，这严重失去了面向对象的风格。</p>
<p>　　我们在编写用例文档（User case Specification）时，其中有一项叫做 “ 例外事件 “，是用来描述主场景外的例外场景的，例如用户登录的用例，就会在” 例外事件 “中说明” 连续3此登录失败即锁定用户账号 “，这就是登录事件的一个异常处理，具体到我们的程序中就是：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//正常登陆</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>InvalidLoginException lie<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//    用户名无效</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>InvalidPasswordException pe<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//密码错误的异常</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>TooMuchLoginException<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//多次登陆失败的异常</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　如此设计则可以让我们的login方法更符合实际的处理逻辑，同时使主逻辑(正常登录，try代码块)更加清晰。当然了，使用异常还有很多优点，可以让正常代码和异常代码分离、能快速查找问题(栈信息快照)等，但是异常有一个缺点：性能比较慢。</p>
<p>　　Java的异常机制确实比较慢，这个”比较慢”是相对于诸如String、Integer等对象来说的，单单从对象的创建上来说，new一个IOException会比String慢5倍，这从异常的处理机制上也可以解释：因为它要执行fillInStackTrace方法，要记录当前栈的快照，而String类则是直接申请一个内存创建对象，异常类慢一筹也就在所难免了。</p>
<p>　　而且，异常类是不能缓存的，期望先建立大量的异常对象以提高异常性能也是不现实的。</p>
<p>　　难道异常的性能问题就没有任何可以提高的办法了？确实没有，但是我们不能因为性能问题而放弃使用异常，而且经过测试，在JDK1.6下，一个异常对象的创建时间只需1.4毫秒左右(注意是毫秒，通常一个交易是在100毫秒左右)，难道我们的系统连如此微小的性能消耗都不予许吗？</p>
<p>　<strong><font color="red">注意：性能问题不是拒绝异常的借口。</font></strong></p>
<h2><span id="第9章-多线程和并发">第9章 多线程和并发</span></h2><p>​    We’re here to put a dent in the universe.Otherwise why else even behere?</p>
<p>​    活着就是为了改变世界，难道还有其他原因吗？——Steve Paul Jobs（史蒂夫·乔布斯）</p>
<p>​    多线程技术可以更好地利用系统资源，减少对用户的响应时间，提高系统的性能和效率，但同时也增加了系统的复杂性和运维难度，特别是在高并发、大压力、高可靠性的项目中，线程资源的同步、抢占、互斥等都需要<strong>慎重考虑</strong>，以避免产生性能损耗和线程死锁。</p>
<h3><span id="建议118不推荐覆写start方法">建议118：不推荐覆写start方法</span></h3><p>​    多线程比较简单的实现方式是继承Thread类，然后覆写run方法，在客户端程序中通过调用对象的start方法即可启动一个线程，这是多线程程序的标准写法。不知道大家能够还能回想起自己写的第一个多线程的demo呢？估计一般是这样写的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MultiThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//调用线程体        run();</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//MultiThread do someThing</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    覆写run方法，这好办，写上自己的业务逻辑即可，但为什么要覆写start方法呢？最常见的理由是：要在客户端调用start方法启动线程，不覆写start方法怎么启动run方法呢？于是乎就覆写了start方法，在方法内调用run方法。客户端代码是一个标准程序，代码如下　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//多线程对象</span>
    MultiThread m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MultiThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//启动多线程</span>
    m<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　相信大家都能看出，这是一个错误的多线程应用，main方法根本就没有启动一个子线程，整个应用程序中只有一个主线程在运行，并不会创建任何其它的线程。对此，有很简单的解决办法。只要删除MultiThread类的start方法即可。</p>
<p>　　然后呢？就结束了吗？是的，很多时候确实到此结束了。那为什么不必而且不能覆写start方法，仅仅就是因为” 多线程应用就是这样写的 “ 这个原因吗？</p>
<p>　　要说明这个问题，就需要看一下Thread类的源码了。Thread类的start方法的代码（这个是JDK7版本的）如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 判断线程状态，必须是为启动状态</span>
        <span class="token comment" spellcheck="true">/**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 加入线程组中</span>
        <span class="token comment" spellcheck="true">/*
         * Notify the group that this thread is about to be started so that it
         * can be added to the group's list of threads and the group's unstarted
         * count can be decremented.
         */</span>
        group<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 分配栈内存，启动线程，运行run方法</span>
            <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>started<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    group<span class="token punctuation">.</span><span class="token function">threadStartFailed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">/*
                 * do nothing. If start0 threw a Throwable then it will be
                 * passed up the call stack
                 */</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>　　　<span class="token comment" spellcheck="true">// 本地方法</span>
     <span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　　这里的关键是本地方法start0,它实现了启动线程、申请栈内存、运行run方法、修改线程状态等职责，线程管理和栈内存管理都是由JVM负责的，如果覆盖了start方法，也就是撤销了线程管理和栈内存管理的能力，这样如何启动一个线程呢？事实上，不需要关注线程和栈内存的管理，主需要编码者实现多线程的逻辑即可(即run方法体)，这也是JVM比较聪明的地方，简化多线程应用。</p>
<p>　　那可能有人要问了：如果确实有必要覆写start方法，那该如何处理呢?这确实是一个罕见的要求，不过覆写也容易，只要在start方法中加上super.start()即可，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MultiThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/* 线程启动前的业务处理 */</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/* 线程启动后的业务处理 */</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// MultiThread do someThing</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　注意看start方法，调用了父类的start方法，没有主动调用run方法，这是由JVM自行调用的，不用我们显示实现，而且是一定不能实现。此方式虽然解决了” 覆写start方法 “的问题，但是基本上无用武之地，到目前为止还没有发现一定要覆写start方法的多线程应用，所以要求覆写start的场景。都可以使用其他的方式实现，例如类变量、事件机制、监听等方式。</p>
<p><strong><font color="red">注意：继承自Thread类的多线程类不必覆写start方法。</font></strong></p>
<h3><span id="建议119启动线程前stop方法是不可靠的">建议119：启动线程前stop方法是不可靠的</span></h3><p>　　有这样一个案例，我们需要一个高效率的垃圾邮件制造机，也就是有尽可能多的线程来尽可能多的制造垃圾邮件，垃圾邮件重要的信息保存在数据库中，如收件地址、混淆后的标题、反应垃圾处理后的内容等，垃圾制造机的作用就是从数据库中读取这些信息，判断是否符合条件(如收件地址必须包含@符号、标题不能为空等)，然后转换成一份真实的邮件发出去。</p>
<p>　　整个应用逻辑很简单，这必然是一个多线程应用，垃圾邮件制造机需要继承Thread类，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//垃圾邮件制造机</span>
<span class="token keyword">class</span> <span class="token class-name">SpamMachine</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//制造垃圾邮件</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"制造大量垃圾邮件......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　在客户端代码中需要发挥计算机的最大潜能来制造邮件，也就是说开尽可能多的线程，这里我们使用一个while循环来处理，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//不分昼夜的制造垃圾邮件</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//多线程多个垃圾邮件制造机</span>
        SpamMachine sm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpamMachine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//xx条件判断，不符合提交就设置该线程不可执行</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            sm<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//如果线程是stop状态，则不会启动</span>
        sm<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　在此段代码中，设置了一个极端条件：所有的线程在启动前都执行stop方法，虽然它是一个过时的方法，但它的运行逻辑还是正常的，况且stop方法在此处的目的并不是停止一个线程，而是设置线程为不可启用状态。想来这应该是没有问题的，但是运行结果却出现了奇怪的现象：部分线程还是启动了，也就是在某些线程(没有规律)中的start方法正常执行了。在不符合判断规则的情况下，不可启用状态的线程还是启用了。这是为什么呢？</p>
<p>　　这是线程启动start方法的一个缺陷。Thread类的stop方法会根据线程状态来判断是终结线程还是设置线程为不可运行状态，对于未启动的线程(线程状态为NEW)来说，会设置其标志位为不可启动，而其他的状态则是直接停止。stop方法的JDK1.6源代码（JDk1.6以上源码于此可能有变化，需要重新观察源码）如下：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Deprecated</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// If the thread is already dead, return.</span>
    <span class="token comment" spellcheck="true">// A zero status value corresponds to "NEW".</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>threadStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">stop1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadDeath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">stop1</span><span class="token punctuation">(</span>Throwable th<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SecurityManager security <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>security <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>th <span class="token keyword">instanceof</span> <span class="token class-name">ThreadDeath</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        security<span class="token punctuation">.</span><span class="token function">checkPermission</span><span class="token punctuation">(</span>SecurityConstants<span class="token punctuation">.</span>STOP_THREAD_PERMISSION<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// A zero status value corresponds to "NEW"</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Wake up thread if it was suspended; no-op otherwise</span>
        <span class="token function">stop0</span><span class="token punctuation">(</span>th<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

            <span class="token comment" spellcheck="true">// Must do the null arg check that the VM would do with stop0</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>th <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

            <span class="token comment" spellcheck="true">// Remember this stop attempt for if/when start is used</span>
        stopBeforeStart <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        throwableFromStop <span class="token operator">=</span> th<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>这里设置了stopBeforeStart变量，标志着是在启动前设置了停止标志，在start方法中(JDK6源码)是这样校验的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * This method is not invoked for the main method thread or "system"
     * group threads created/set up by the VM. Any new functionality added 
     * to this method in the future may have to also be added to the VM.
     *
     * A zero status value corresponds to state "NEW".
         */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    group<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 在启动前设置了停止状态</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stopBeforeStart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">stop0</span><span class="token punctuation">(</span>throwableFromStop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>　　注意看start0方法和stop0方法的顺序，start0方法在前，也就说既是stopBeforeStart为true(不可启动)，也会启动一个线程，然后再stop0结束这个线程，而罪魁祸首就在这里！</p>
<p>　　明白了原因，我们的情景代码就很容易修改了，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 不分昼夜的制造垃圾邮件</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 多线程多个垃圾邮件制造机</span>
        SpamMachine sm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpamMachine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// xx条件判断，不符合提交就设置该线程不可执行</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">SpamMachine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　不再使用stop方法进行状态的设置，直接通过判断条件来决定线程是否可启用。对于start方法的缺陷，一般不会引起太大的问题，只是增加了线程启动和停止的精度而已。</p>
<h3><span id="建议120不使用stop方法停止线程">建议120：不使用stop方法停止线程</span></h3><p>　　线程启动完毕后，在运行时可能需要中止，Java提供的终止方法只有一个stop，但是我不建议使用这个方法，因为它有以下三个问题：</p>
<p>(1)、stop方法是过时的：从Java编码规则来说，已经过时的方法不建议采用。</p>
<p>(2)、stop方法会导致代码逻辑不完整：stop方法是一种” 恶意 “ 的中断，一旦执行stop方法，即终止当前正在运行的线程，不管线程逻辑是否完整，这是非常危险的。看如下的代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 子线程休眠1秒</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 异常处理</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"此处是业务逻辑，永远不会执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动线程</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 主线程休眠0.1秒</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 子线程停止</span>
    thread<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这段代码的逻辑是这样的：子线程是一个匿名内部类，它的run方法在执行时会休眠一秒，然后执行后续的逻辑，而主线程则是休眠0.1秒后终止子线程的运行，也就说JVM在执行tread.stop()时，子线程还在执行sleep(1000)，此时stop方法会清除栈内信息，结束该线程，这也就导致了run方法的逻辑不完整，输出语句println代表的是一段逻辑，可能非常重要，比如子线程的主逻辑、资源回收、情景初始化等，但是因为stop线程了，这些都不再执行，于是就产生了业务逻辑不完整的情况。</p>
<p>　　这是极度危险的，因为我们不知道子线程会在什么时候被终止，stop连基本的逻辑完整性都无法保证。而且此种操作也是非常隐蔽的，子线程执行到何处会被关闭很难定位，这位以后的维护带来了很多麻烦。</p>
<p>(3)、stop方法会破坏原子逻辑</p>
<p>　　多线程为了解决共享资源抢占的问题，使用了锁概念，避免资源不同步，但是正因为此，stop方法却会带来更大的麻烦，它会丢弃所有的锁，导致原子逻辑受损。例如有这样一段程序：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MultiThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 同步代码块，保证原子操作</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 自增</span>
            a<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//线程休眠0.1秒</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 自减</span>
            a<span class="token operator">--</span><span class="token punctuation">;</span>
            String tn <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tn <span class="token operator">+</span> <span class="token string">":a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　MultiThread实现了Runnable接口，具备多线程能力，其中run方法中加上了synchronized代码块，表示内部是原子逻辑，它会先自增然后自减，按照synchronized同步代码块的规则来处理，此时无论启动多少线程，打印出来的结果应该是a=0，但是如果有一个正在执行的线程被stop，就会破坏这种原子逻辑，代码如下：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MultiThread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MultiThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动t1线程</span>
    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//停止t1线程</span>
    t1<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　首先说明的是所有线程共享了一个MultiThread的实例变量t，其次由于在run方法中加入了同步代码块，所以只能有一个线程进入到synchronized块中。这段代码的执行顺序如下：</p>
<ol>
<li>线程t1启动，并执行run方法，由于没有其它线程同步代码块的锁，所以t1线程执行后自加后执行到sleep方法即开始休眠，此时a=1</li>
<li>JVM又启动了5个线程，也同时运行run方法，由于synchronized关键字的阻塞作用，这5个线程不能执行自增和自减操作，等待t1线程锁释放。</li>
<li>主线程执行了t1.stop方法，终止了t1线程，注意，由于a变量是所有线程共享的，所以其它5个线程获得的a变量也是1</li>
<li>其它5个线程依次获得CPU执行机会，打印出a值</li>
</ol>
<p>　　分析了这么多，相信大家也明白了输出结果，结果如下：</p>
<p>　　　　Thread-5:a = 1<br>　　　　Thread-4:a = 1<br>　　　　Thread-3:a = 1<br>　　　　Thread-2:a = 1<br>　　　　Thread-1:a = 1</p>
<p>　　原本期望synchronized同步代码块中的逻辑都是原子逻辑，不受外界线程的干扰，但是结果却出现原子逻辑被破坏的情况，这也是stop方法被废弃的一个重要原因：破坏了原子逻辑。</p>
<p>　　既然终止一个线程不能使用stop方法，那怎样才能终止一个正在运行的线程呢？答案也简单，使用自定义的标志位决定线程的执行情况，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SafeStopThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 此变量必须加上volatile</span>
    <span class="token comment" spellcheck="true">/*
     * volatile: 1.作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值.
     * 2.被设计用来修饰被不同线程访问和修改的变量。如果不加入volatile
     * ，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> stop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 判断线程体是否运行</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// doSomething</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这是很简单的办法，在线程体中判断是否需要停止运行，即可保证线程体的逻辑完整性，而且也不会破坏原子逻辑。可能大家对JavaAPI比较熟悉，于是提出疑问：Thread不是还提供了interrupt中断线程的方法吗？这个方法可不是过时方法，那可以使用吗?它可以终止一个线程吗？</p>
<p>　　interrupt，名字看上去很像是终止一个线程的方法，但它不能终止一个正在执行着的线程，它只是修改中断标志而已，例如下面一段代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 线程一直运行</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Running......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动线程</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 中断线程</span>
    thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　执行这段代码，你会发现一直有Running在输出，永远不会停止，似乎执行了interrupt没有任何变化，那是因为interrupt方法不能终止一个线程状态，它只会改变中断标志位(如果在thread.interrupt()前后输出thread.isInterrupted()则会发现分别输出了false和true)，如果需要终止该线程，还需要自己进行判断，例如我们可以使用interrupt编写出更简洁、安全的终止线程代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SafeStopThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//判断线程体是否运行</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// do SomeThing</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　总之，如果期望终止一个正在运行的线程，则不能使用已过时的stop方法。需要自行编码实现，如此即可保证原子逻辑不被破坏，代码逻辑不会出现异常。当然，如果我们使用的是线程池(比如ThreadPoolExecutor类)，那么可以通过shutdown方法逐步关闭池中的线程，它采用的是比较温和、安全的关闭线程方法，完全不会产生类似stop方法的弊端。</p>
<h3><span id="建议121线程优先级只使用三个等级">建议121：线程优先级只使用三个等级</span></h3><p>​        线程的优先级(Priority)决定了线程获得CPU运行的机会，优先级越高获得的运行机会越大，优先级越低获得的机会越小。Java的线程有10个级别(准确的说是11个级别，级别为0的线程是JVM的，应用程序不能设置该级别)，那是不是说级别是10的线程肯定比级别是9的线程先运行呢?我们来看如下一个多线程类：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TestThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> _priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 设置优先级别</span>
        t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>_priority<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 消耗CPU的计算</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Math<span class="token punctuation">.</span><span class="token function">hypot</span><span class="token punctuation">(</span><span class="token number">924526789</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 输出线程优先级</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Priority："</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　该多线程实现了Runnable接口，实现了run方法，注意在run方法中有一个比较占用CPU的计算，该计算毫无意义，</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//启动20个不同优先级的线程</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">TestThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​     这里创建了20个线程，每个线程在运行时都耗尽了CPU的资源，因为优先级不同，线程调度应该是先处理优先级高的，然后处理优先级低的，也就是先执行2个优先级为10的线程，然后执行2个优先级为9的线程，2个优先级为8的线程……但是结果却并不是这样的。</p>
<p>　　<strong>Priority：5</strong><br>　　<strong>Priority：7</strong><br>　　<strong>Priority：10</strong><br>　　<strong>Priority：6</strong><br>　　<strong>Priority：9</strong><br>　　<strong>Priority：6</strong><br>　　<strong>Priority：5</strong><br>　　<strong>Priority：7</strong><br>　　<strong>Priority：10</strong><br>　　<strong>Priority：3</strong><br>　　<strong>Priority：4</strong><br>　　<strong>Priority：8</strong><br>　　<strong>Priority：8</strong><br>　　<strong>Priority：9</strong><br>　　<strong>Priority：4</strong><br>　　<strong>Priority：1</strong><br>　　<strong>Priority：3</strong><br>　　<strong>Priority：1</strong><br>　　<strong>Priority：2</strong><br>　　<strong>Priority：2</strong></p>
<p>　　println方法虽然有输出损耗，可能会影响到输出结果，但是不管运行多少次，你都会发现两个不争的事实：</p>
<p>(1)、并不是严格按照线程优先级来执行的</p>
<p>　　比如线程优先级为5的线程比优先级为7的线程先执行，优先级为1的线程比优先级为2的线程先执行，很少出现优先级为2的线程比优先级为10的线程先执行(注意，这里是” 很少 “，是说确实有可能出现，只是几率低，因为优先级只是表示线程获得CPU运行的机会，并不代表强制的排序号)。</p>
<p>(2)、优先级差别越大，运行机会差别越明显</p>
<p>　　比如优先级为10的线程通常会比优先级为2的线程先执行，但是优先级为6的线程和优先级为5的线程差别就不太明显了，执行多次，你会发现有不同的顺序。</p>
<p>　　这两个现象是线程优先级的一个重要表现，之所以会出现这种情况，是因为线程运行是需要获得CPU资源的，那谁能决定哪个线程先获得哪个线程后获得呢？这是依照操作系统设置的线程优先级来分配的，也就是说，每个线程要运行，需要操作系统分配优先级和CPU资源，对于JAVA来说，JVM调用操作系统的接口设置优先级，比如windows操作系统优先级都相同吗？</p>
<p>　　事实上，不同的操作系统线程优先级是不同的，Windows有7个优先级，Linux有140个优先级，Freebsd则由255个(此处指的优先级个数，不同操作系统有不同的分类，如中断级线程，操作系统级等，各个操作系统具体用户可用的线程数量也不相同)。Java是跨平台的系统，需要把这10个优先级映射成不同的操作系统的优先级，于是界定了Java的优先级只是代表抢占CPU的机会大小，优先级越高，抢占CPU的机会越大，被优先执行的可能性越高，优先级相差不大，则抢占CPU的机会差别也不大，这就是导致了优先级为9的线程可能比优先级为10的线程先运行。</p>
<p>　　Java的缔造者们也觉察到了线程优先问题，于是Thread类中设置了三个优先级，此意就是告诉开发者，建议使用优先级常量，而不是1到10的随机数字。常量代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * The minimum priority that a thread can have. 
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> MIN_PRIORITY <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * The default priority that is assigned to a thread. 
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> NORM_PRIORITY <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * The maximum priority that a thread can have. 
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> MAX_PRIORITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre>
<p>　　在编码时直接使用这些优先级常量，可以说在大部分情况下MAX_PRIORITY的线程回比MIN_PRIORITY的线程优先运行，但是不能认为是必然会先运行，不能把这个优先级做为核心业务的必然条件，Java无法保证优先级高肯定会先执行，只能保证高优先级有更多的执行机会。因此，建议在开发时只使用此三类优先级，没有必要使用其他7个数字，这样也可以保证在不同的操作系统上优先级的表现基本相同。</p>
<p>　　大家也许会问，如果优先级相同呢？这很好办，也是由操作系统决定的。基本上是按照FIFO原则(先入先出，First Input First Output)，但也是不能完全保证。</p>
<h3><span id="建议122使用线程异常处理器提升系统可靠性">建议122：使用线程异常处理器提升系统可靠性</span></h3><p>　    我们要编写一个Socket应用，监听指定端口，实现数据包的接收和发送逻辑，这在早期系统间进行数据交互是经常使用的，这类接口通常需要考虑两个问题：一个是避免线程阻塞，保证接收的数据尽快处理；二是：接口的稳定性和可靠性问题，数据包很复杂，接口服务的系统也很多，一旦守候线程出现异常就会导致Socket停止，这是非常危险的，那我们有什么办法避免吗？</p>
<p>　　Java1.5版本以后在Thread类中增加了setUncaughtExceptionHandler方法，实现了线程异常的捕捉和处理。可能大家会有一个疑问：如果Socket应用出现了不可预测的异常是否可以自动重启呢？其实使用线程异常处理器很容易解决，我们来看一个异常处理器应用实例，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TcpServer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建后即运行</span>
    <span class="token keyword">public</span> <span class="token function">TcpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">setUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TcpServerExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"系统正常运行:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 抛出异常</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 异常处理器</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TcpServerExceptionHandler</span> <span class="token keyword">implements</span>
            <span class="token class-name">Thread<span class="token punctuation">.</span>UncaughtExceptionHandler</span> <span class="token punctuation">{</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">uncaughtException</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 记录线程异常信息</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 出现异常,自行重启，请分析原因。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 重启线程，保证业务不中断</span>
            <span class="token keyword">new</span> <span class="token class-name">TcpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　这段代码的逻辑比较简单，在TcpServer类创建时即启动一个线程，提供TCP服务，例如接收和发送文件，具体逻辑在run方法中实现。同时，设置了该线程出现运行期异常(也就是Uncaught Exception)时，由TcpServerExceptionHandler异常处理器来处理异常。那么TcpServerExceptionHandler做什么事呢？两件事：</p>
<ul>
<li>记录异常信息，以便查找问题</li>
<li>重新启动一个新线程，提供不间断的服务</li>
</ul>
<p>　　有了这两点，TcpServer就可以稳定的运行了，即使出现异常也能自动重启，客户端代码比较简单，只需要new TcpServer()即可，运行结果如下：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20161019095811248-9027011.png" alt="img"></p>
<p>​    　从运行结果上可以看出，当Thread-0出现异常时，系统自动重启了Thread-1线程，继续提供服务，大大提高了系统的性能。</p>
<p>　　这段程序只是一个示例程序，若要在实际环境中应用，则需要注意以下三个方面：</p>
<ul>
<li>共享资源锁定：如果线程产生异常的原因是资源被锁定，自动重启应用知会增加系统的负担，无法提供不间断服务。例如一个即时通信服务(XMPP Server)出现信息不能写入的情况，即使再怎么启动服务，也是无法解决问题的。在此情况下最好的办法是停止所有的线程，释放资源。</li>
<li>脏数据引起系统逻辑混乱：异常的产生中断了正在执行的业务逻辑，特别是如果正在处理一个原子操作(像即时通讯服务器的用户验证和签到这两个事件应该在一个操作中处理，不允许出现验证成功，但签到不成功的情况)，但如果此时抛出了运行期异常就有可能会破坏正常的业务逻辑，例如出现用户认证通过了，但签到不成功的情况，在这种情境下重启应用服务器，虽然可以提供服务，但对部分用户却产生了逻辑异常。</li>
<li>内存溢出：线程异常了，但由该线程创建的对象并不会马上回收，如果再重亲启动新线程，再创建一批对象，特别是加入了场景接管，就非常危险了，例如即时通信服务，重新启动一个新线程必须保证原在线用户的透明性，即用户不会察觉服务重启，在此种情况下，就需要在线程初始化时加载大量对象以保证用户的状态信息，但是如果线程反复重启，很可能会引起OutOfMemory内存泄露问题。</li>
</ul>
<h3><span id="建议123volatile不能保证数据同步">建议123：volatile不能保证数据同步</span></h3><p>​    　volatile关键字比较少用，原因无外乎两点，一是在Java1.5之前该关键字在不同的操作系统上有不同的表现，所带来的问题就是移植性较差；而且比较难设计，而且误用较多，这也导致它的”名誉” 受损。</p>
<p>　　我们知道，每个线程都运行在栈内存中，每个线程都有自己的工作内存(Working Memory,比如寄存器Register、高速缓冲存储器Cache等)，线程的计算一般是通过工作内存进行交互的，其示意图如下图所示：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20161018131753435-157368081.png" alt="img"></p>
<p>　从示意图上我们可以看到，线程在初始化时从主内存中加载所需的变量值到工作内存中，然后在线程运行时，如果是读取，则直接从工作内存中读取，若是写入则先写到工作内存中，之后刷新到主内存中，这是JVM的一个简答的内存模型，但是这样的结构在多线程的情况下有可能会出现问题，比如：A线程修改变量的值，也刷新到了主内存，但B、C线程在此时间内读取的还是本线程的工作内存，也就是说它们读取的不是最”新鲜”的值，此时就出现了不同线程持有的公共资源不同步的情况。</p>
<p>　　对于此类问题有很多解决办法，比如使用synchronized同步代码块，或者使用Lock锁来解决该问题，不过，Java可以使用volatile更简单地解决此类问题，比如在一个变量前加上volatile关键字，可以确保每个线程对本地变量的访问和修改都是直接与内存交互的，而不是与本线程的工作内存交互的，保证每个线程都能获得最”新鲜”的变量值，其示意图如下：</p>
<p><img src="https://gitee.com/CandyLoveYL/img/raw/master/img_202112/712052-20161018134019029-840148773.png" alt="img"></p>
<p>　　明白了volatile变量的原理，那我们思考一下：volatile变量是否能够保证数据的同步性呢？两个线程同时修改一个volatile是否会产生脏数据呢？我们看看下面代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">UnsafeThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 共享资源</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 增加CPU的繁忙程度,不必关心其逻辑含义</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Math<span class="token punctuation">.</span><span class="token function">hypot</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">92456789</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　上面的代码定义了一个多线程类，run方法的主要逻辑是共享资源count的自加运算，而且我们还为count变量加上了volatile关键字，确保是从内存中读取和写入的，如果有多个线程运行，也就是多个线程执行count变量的自加操作，count变量会产生脏数据吗？想想看，我们已经为count加上了volatile关键字呀！模拟多线程的代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 理想值，并作为最大循环次数</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 循环次数,防止造成无限循环或者死循环</span>
    <span class="token keyword">int</span> loops <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 主线程组,用于估计活动线程数</span>
    ThreadGroup tg <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>loops<span class="token operator">++</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 共享资源清零</span>
        UnsafeThread ut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnsafeThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ut<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 先等15毫秒，等待活动线程为1</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>tg<span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 检查实际值与理论值是否一致</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ut<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 出现线程不安全的情况</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"循环到："</span> <span class="token operator">+</span> loops <span class="token operator">+</span> <span class="token string">" 遍，出现线程不安全的情况"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"此时，count= "</span> <span class="token operator">+</span> ut<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　想让volatite变量”出点丑”，还是需要花点功夫的。此段程序的运行逻辑如下：</p>
<ul>
<li>启动100个线程，修改共享资源count的值</li>
<li>暂停15秒，观察活动线程数是否为1(即只剩下主线程再运行)，若不为1，则再等待15秒。</li>
<li>判断共享资源是否是不安全的，即实际值与理想值是否相同，若不相同，则发现目标，此时count的值为脏数据。</li>
<li>如果没有找到，继续循环，直到达到最大循环为止。</li>
</ul>
<p>运行结果如下：</p>
<p>　　　<strong>循环到：40 遍，出现线程不安全的情况</strong><br>　　　<strong>此时，count= 999</strong><br>　　这只是一种可能的结果，每次执行都有可能产生不同的结果。这也说明我们的count变量没有实现数据同步，在多个线程修改的情况下，count的实际值与理论值产生了偏差，直接说明了volatile关键字并不能保证线程的安全。<br>　　在解释原因之前，我们先说一下自加操作。count++表示的是先取出count的值然后再加1，也就是count=count+1，所以，在某个紧邻时间片段内会发生如下神奇的事情：</p>
<p>(1)、第一个时间片段</p>
<p>　　A线程获得执行机会，因为有关键字volatile修饰，所以它从主内存中获得count的最新值为998，接下来的事情又分为两种类型：</p>
<ul>
<li>如果是单CPU，此时调度器暂停A线程执行，让出执行机会给B线程，于是B线程也获得了count的最新值998.</li>
<li>如果是多CPU，此时线程A继续执行，而线程B也同时获得了count的最新值998.</li>
</ul>
<p>(2)、第二个片段</p>
<ul>
<li>如果是单CPU，B线程执行完+1操作(这是一个原子处理)，count的值为999，由于是volatile类型的变量，所以直接写入主内存，然后A线程继续执行，计算的结果也是999，重新写入主内存中。</li>
<li>如果是多CPU，A线程执行完加1动作后修改主内存的变量count为999，线程B执行完毕后也修改主内存中的变量为999</li>
</ul>
<p>这两个时间片段执行完毕后，原本期望的结果为1000，单运行后的值为999，这表示出现了线程不安全的情况。这也是我们要说明的：volatile关键字并不能保证线程安全，它只能保证当前线程需要该变量的值时能够获得最新的值，而不能保证线程修改的安全性。</p>
<p>顺便说一下，在上面的代码中，UnsafeThread类的消耗CPU计算是必须的，其目的是加重线程的负荷，以便出现单个线程抢占整个CPU资源的情景，否则很难模拟出volatile线程不安全的情况，大家可以自行模拟测试。</p>
<h3><span id="建议124异步运算考虑使用callable接口">建议124：异步运算考虑使用Callable接口</span></h3><p>　　多线程应用有两种实现方式，一种是实现Runnable接口，另一种是继承Thread类，这两个方法都有缺点：run方法没有返回值，不能抛出异常(这两个缺点归根到底是Runnable接口的缺陷，Thread类也实现了Runnable接口)，如果需要知道一个线程的运行结果就需要用户自行设计，线程类本身也不能提供返回值和异常。但是从Java1.5开始引入了一个新的接口Callable，它类似于Runnable接口，实现它就可以实现多线程任务，Callable的接口定义如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */</span>
    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　实现Callable接口的类，只是表明它是一个可调用的任务，并不表示它具有多线程运算能力，还是需要执行器来执行的，我们先编写一个任务类，代码如下：　</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//税款计算器</span>
<span class="token keyword">class</span> <span class="token class-name">TaxCalculator</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 本金</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> seedMoney<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 接收主线程提供的参数</span>
    <span class="token keyword">public</span> <span class="token function">TaxCalculator</span><span class="token punctuation">(</span><span class="token keyword">int</span> _seedMoney<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        seedMoney <span class="token operator">=</span> _seedMoney<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 复杂计算,运行一次需要2秒</span>
        TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> seedMoney <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　这里模拟了一个复杂运算：税款计算器，该运算可能要花费10秒钟的时间，此时不能让用户一直等着吧，需要给用户输出点什么，让用户知道系统还在运行，这也是系统友好性的体现：用户输入即有输出，若耗时较长，则显示运算进度。如果我们直接计算，就只有一个main线程，是不可能有友好提示的，如果税金不计算完毕，也不会执行后续动作，所以此时最好的办法就是重启一个线程来运算，让main线程做进度提示，代码如下：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span>
ExecutionException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 生成一个单线程的异步执行器</span>
    ExecutorService es <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 线程执行后的期望值</span>
    Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> future <span class="token operator">=</span> es<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TaxCalculator</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>future<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 还没有运算完成，等待200毫秒</span>
        TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 输出进度符号</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n计算完成，税金是："</span> <span class="token operator">+</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"  元 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    es<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　在这段代码中，Executors是一个静态工具类，提供了异步执行器的创建能力，如单线程异步执行器newSingleThreadExecutor、固定线程数量的执行器newFixedThreadPool等，一般它是异步计算的入口类。future关注的是线程执行后的结果，比如没有运行完毕，执行结果是多少等。此段代码的运行结果如下所示：</p>
<p>　　　　　　**********************************************……</p>
<p>　　　　　　计算完成，税金是：10 元</p>
<p>　　执行时，”*”会依次递增，表示系统正在运算，为用户提供了运算进度，此类异步计算的好处是：</p>
<ul>
<li>尽可能多的占用系统资源，提供快速运算</li>
<li>可以监控线程的执行情况，比如是否执行完毕、是否有返回值、是否有异常等。</li>
<li>可以为用户提供更好的支持，比如例子中的运算进度等。</li>
</ul>
<h3><span id="建议125优先选择线程池">建议125：优先选择线程池</span></h3><p>　　在Java1.5之前，实现多线程比较麻烦，需要自己启动线程，并关注同步资源，防止出现线程死锁等问题，在1.5版本之后引入了并行计算框架，大大简化了多线程开发。我们知道一个线程有五个状态：新建状态(NEW)、可运行状态(Runnable，也叫作运行状态)、阻塞状态(Blocked)、等待状态(Waiting)、结束状态(Terminated)，线程的状态只能由新建转变为了运行状态后才能被阻塞或等待，最后终结，不可能产生本末倒置的情况，比如把一个结束状态的线程转变为新建状态，则会出现异常，例如如下代码会抛出异常：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建一个线程，新建状态</span>
    Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程正在运行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 运行状态</span>
    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 是否是运行状态，若不是则等待10毫秒</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>State<span class="token punctuation">.</span>TERMINATED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 直接由结束转变为云心态</span>
    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　此段程序运行时会报java.lang.IllegalThreadStateException异常，原因就是不能从结束状态直接转变为运行状态，我们知道一个线程的运行时间分为3部分：T1为线程启动时间，T2为线程的运行时间，T3为线程销毁时间，如果一个线程不能被重复使用，每次创建一个线程都需要经过启动、运行、销毁时间，这势必增大系统的响应时间，有没有更好的办法降低线程的运行时间呢？</p>
<p>　　T2是无法避免的，只有通过优化代码来实现降低运行时间。T1和T2都可以通过线程池(Thread Pool)来缩减时间，比如在容器(或系统)启动时，创建足够多的线程，当容器(或系统)需要时直接从线程池中获得线程，运算出结果，再把线程返回到线程池中___ExecutorService就是实现了线程池的执行器，我们来看一个示例代码：　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 2个线程的线程池</span>
    ExecutorService es <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 多次执行线程体</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        es<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 关闭执行器</span>
    es<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　此段代码首先创建了一个包含两个线程的线程池，然后在线程池中多次运行线程体，输出运行时的线程名称，结果如下：</p>
<p>　　　　　　　　pool-1-thread-1<br>　　　　　　　　pool-1-thread-2<br>　　　　　　　　pool-1-thread-1<br>　　　　　　　　pool-1-thread-2</p>
<p> 　本次代码执行了4遍线程体，按照我们之前阐述的” 一个线程不可能从结束状态转变为可运行状态 “，那为什么此处的2个线程可以反复使用呢？这就是我们要搞清楚的重点。</p>
<p>　　线程池涉及以下几个名词：</p>
<ul>
<li>工作线程(Worker)：线程池中的线程，只有两个状态：可运行状态和等待状态，没有任务时它们处于等待状态，运行时它们循环的执行任务。</li>
<li>任务接口(Task)：这是每个任务必须实现的接口，以供工作线程调度器调度，它主要规定了任务的入口、任务执行完的场景处理，任务的执行状态等。这里有两种类型的任务：具有返回值(异常)的Callable接口任务和无返回值并兼容旧版本的Runnable接口任务。</li>
<li>任务对列(Work Quene)：也叫作工作队列，用于存放等待处理的任务，一般是BlockingQuene的实现类，用来实现任务的排队处理。</li>
</ul>
<p>　　我们首先从线程池的创建说起，Executors.newFixedThreadPool(2)表示创建一个具有两个线程的线程池，源代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Executors</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//生成一个最大为nThreads的线程池执行器</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>　　这里使用了LinkedBlockingQueue作为队列任务管理器，所有等待处理的任务都会放在该对列中，需要注意的是，此队列是一个阻塞式的单端队列。线程池建立好了，那就需要线程在其中运行了，线程池中的线程是在submit第一次提交任务时建立的，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//检查任务是否为null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//把Runnable任务包装成具有返回值的任务对象，不过此时并没有执行，只是包装</span>
    RunnableFuture<span class="token operator">&lt;</span>Object<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//执行此任务</span>
    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//返回任务预期执行结果</span>
    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　此处的代码关键是execute方法，它实现了三个职责。</p>
<ul>
<li>创建足够多的工作线程数，数量不超过最大线程数量，并保持线程处于运行或等待状态。</li>
<li>把等待处理的任务放到任务队列中</li>
<li>从任务队列中取出任务来执行</li>
</ul>
<p>　　其中此处的关键是工作线程的创建，它也是通过new Thread方式创建的一个线程，只是它创建的并不是我们的任务线程(虽然我们的任务实现了Runnable接口，但它只是起了一个标志性的作用)，而是经过包装的Worker线程，代码如下：　　</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">// 运行一次任务</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">runTask</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/* 这里的task才是我们自定义实现Runnable接口的任务 */</span>
        task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/* 该方法其它代码略 */</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 工作线程也是线程，必须实现run方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            Runnable task <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>
            firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">runTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
                task <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token function">workerDone</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 任务队列中获得任务</span>
    Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/* 其它代码略 */</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> r <span class="token operator">=</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>　　此处为示意代码，删除了大量的判断条件和锁资源。execute方法是通过Worker类启动的一个工作线程，执行的是我们的第一个任务，然后改线程通过getTask方法从任务队列中获取任务，之后再继续执行，但问题是任务队列是一个BlockingQuene，是阻塞式的，也就是说如果该队列的元素为0，则保持等待状态，直到有任务进入为止，我们来看LinkedBlockingQuene的take方法，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    E x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>
    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>
    takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果队列中的元素为0，则等待</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// propagate to a non-interrupted thread</span>
            <span class="token keyword">throw</span> ie<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 等待状态结束，弹出头元素</span>
        x <span class="token operator">=</span> <span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果队列数量还多于一个，唤醒其它线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>
        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 返回头元素</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    　分析到这里，我们就明白了线程池的创建过程：创建一个阻塞队列以容纳任务，在第一次执行任务时创建做够多的线程(不超过许可线程数)，并处理任务，之后每个工作线程自行从任务对列中获得任务，直到任务队列中的任务数量为0为止，此时，线程将处于等待状态，一旦有任务再加入到队列中，即召唤醒工作线程进行处理，实现线程的可复用性。</p>
<p>　　使用线程池减少的是线程的创建和销毁时间，这对于多线程应用来说非常有帮助，比如我们常用的Servlet容器，每次请求处理的都是一个线程，如果不采用线程池技术，每次请求都会重新创建一个新的线程，这会导致系统的性能符合加大，响应效率下降，降低了系统的友好性。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">CANDY</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://codercandy.github.io/2021/12/25/bian-xie-gao-zhi-liang-dai-ma-gai-shan-java-cheng-xu-de-151-ge-jian-yi-du-shu-bi-ji-xia/">https://codercandy.github.io/2021/12/25/bian-xie-gao-zhi-liang-dai-ma-gai-shan-java-cheng-xu-de-151-ge-jian-yi-du-shu-bi-ji-xia/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">CANDY</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%90%8E%E7%AB%AF/">
                                    <span class="chip bg-color">后端</span>
                                </a>
                            
                                <a href="/tags/java/">
                                    <span class="chip bg-color">java</span>
                                </a>
                            
                                <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
                                    <span class="chip bg-color">读书笔记</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC81NDg3My8zMTM0Mg==">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/01/09/chang-jin-hu-jing-dian-yu-ju/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="长津湖经典语句">
                        
                        <span class="card-title">长津湖经典语句</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-01-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%94%9F%E6%B4%BB/" class="post-category">
                                    生活
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%9A%8F%E7%AC%94/">
                        <span class="chip bg-color">随笔</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/12/19/yuan-gong-de-chi-zhi-cheng-ben/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="员工的离职成本">
                        
                        <span class="card-title">员工的离职成本</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-12-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%B7%A5%E4%BD%9C/" class="post-category">
                                    工作
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%9A%8F%E7%AC%94/">
                        <span class="chip bg-color">随笔</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('10')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 梓妤<br />'
            + '文章作者: Candy liu<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2023</span>
            
            <a href="/about" target="_blank">Candy liu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2021";
                        var startMonth = "12";
                        var startDate = "5";
                        var startHour = "22";
                        var startMinute = "49";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
<a href="https://gitee.com/CandyLoveYL" class="tooltipped" target="_blank" data-tooltip="访问我的gitee" data-position="top" data-delay="50">
	<i class="fab fa-github"></i>
</a>
<a href="mailto:595487347@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
	<i class="fas fa-envelope-open"></i>
</a>
<a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=595487347" class="tooltipped" target="_blank" data-tooltip="QQ联系我:595487347" data-position="top" data-delay="50">
	<i class="fab fa-qq"></i>
</a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
